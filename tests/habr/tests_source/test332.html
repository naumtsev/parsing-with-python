<!DOCTYPE html>
<html lang="ru" data-vue-meta="%7B%22lang%22:%7B%22ssr%22:%22ru%22%7D%7D">
<head >
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width,initial-scale=1.0,viewport-fit=cover">
  <title>Как реализован рендеринг «Ведьмака 3»: молнии, ведьмачье чутьё и другие эффекты / Хабр</title>
  <style>
    /* cyrillic-ext */
    @font-face {
      font-family: 'Fira Sans';
      font-style: normal;
      font-weight: 500;
      font-display: swap;
      src: url(https://fonts.gstatic.com/s/firasans/v11/va9B4kDNxMZdWfMOD5VnZKveSxf6TF0.woff2) format('woff2');
      unicode-range: U+0460-052F, U+1C80-1C88, U+20B4, U+2DE0-2DFF, U+A640-A69F, U+FE2E-FE2F;
    }

    /* cyrillic */
    @font-face {
      font-family: 'Fira Sans';
      font-style: normal;
      font-weight: 500;
      font-display: swap;
      src: url(https://fonts.gstatic.com/s/firasans/v11/va9B4kDNxMZdWfMOD5VnZKveQhf6TF0.woff2) format('woff2');
      unicode-range: U+0400-045F, U+0490-0491, U+04B0-04B1, U+2116;
    }

    /* latin-ext */
    @font-face {
      font-family: 'Fira Sans';
      font-style: normal;
      font-weight: 500;
      font-display: swap;
      src: url(https://fonts.gstatic.com/s/firasans/v11/va9B4kDNxMZdWfMOD5VnZKveSBf6TF0.woff2) format('woff2');
      unicode-range: U+0100-024F, U+0259, U+1E00-1EFF, U+2020, U+20A0-20AB, U+20AD-20CF, U+2113, U+2C60-2C7F, U+A720-A7FF;
    }

    /* latin */
    @font-face {
      font-family: 'Fira Sans';
      font-style: normal;
      font-weight: 500;
      font-display: swap;
      src: url(https://fonts.gstatic.com/s/firasans/v11/va9B4kDNxMZdWfMOD5VnZKveRhf6.woff2) format('woff2');
      unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2122, U+2191, U+2193, U+2212, U+2215, U+FEFF, U+FFFD;
    }
  </style>
  <link rel="preload" href="https://assets.habr.com/habr-web/css/chunk-vendors.e7843cc0.css" as="style"><link rel="preload" href="https://assets.habr.com/habr-web/js/chunk-vendors.c2c3fc9a.js" as="script"><link rel="preload" href="https://assets.habr.com/habr-web/css/app.02ee25a4.css" as="style"><link rel="preload" href="https://assets.habr.com/habr-web/js/app.c0af73e7.js" as="script">
  <link rel="stylesheet" href="https://assets.habr.com/habr-web/css/chunk-vendors.e7843cc0.css"><link rel="stylesheet" href="https://assets.habr.com/habr-web/css/app.02ee25a4.css">
  <script>window.i18nFetch = new Promise((res, rej) => {
          const xhr = new XMLHttpRequest();
          xhr.open('GET', '/js/i18n/ru-compiled.85eb77f0b17c8235e7b64b9f81ea5ec2.json');
          xhr.responseType = 'json';
          xhr.onload = function(e) {
            if (this.status === 200) {
              res({ru: xhr.response});
            } else {
              rej(e);
            }
          };
          xhr.send();
        });</script>
  
  <script data-vue-meta="ssr" src="/js/ads.js" onload="window['zhY4i4nJ9K'] = true" data-vmid="checkad"></script><script data-vue-meta="ssr" type="application/ld+json" data-vmid="ldjson-schema">{"@context":"http:\/\/schema.org","@type":"Article","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/habr.com\/ru\/post\/450332\/"},"headline":"Как реализован рендеринг «Ведьмака 3»: молнии, ведьмачье чутьё и другие эффекты","datePublished":"2019-05-03T15:58:39+03:00","dateModified":"2019-05-25T11:01:33+03:00","author":{"@type":"Person","name":"PatientZero"},"publisher":{"@type":"Organization","name":"Habr","logo":{"@type":"ImageObject","url":"https:\/\/habrastorage.org\/webt\/a_\/lk\/9m\/a_lk9mjkccjox-zccjrpfolmkmq.png"}},"description":"Часть 1. Молнии В этой части мы рассмотрим процесс рендеринга молний в Witcher 3: Wild Hunt.  Рендеринг молний выполняется немного позже эффекта занавес дождя,...","url":"https:\/\/habr.com\/ru\/post\/450332\/#post-content-body","about":["h_3d_graphics","h_gamedev","h_reverse-engineering","h_game_design","f_develop","f_design"],"image":["https:\/\/habrastorage.org\/getpro\/habr\/post_images\/abf\/ce7\/1c4\/abfce71c4469b6dcd077723d498c1685.jpg","https:\/\/habrastorage.org\/getpro\/habr\/post_images\/4ba\/7e1\/f20\/4ba7e1f2075dc128baf8b717eeb3ce92.jpg","https:\/\/habrastorage.org\/getpro\/habr\/post_images\/3dd\/37a\/e59\/3dd37ae5986de4621766f4fc64525906.jpg","https:\/\/habrastorage.org\/getpro\/habr\/post_images\/5b7\/23c\/3dc\/5b723c3dc1f934c0f6c14903e2a260cf.jpg","https:\/\/habrastorage.org\/getpro\/habr\/post_images\/6f1\/dca\/ddb\/6f1dcaddbdcd0f6e3c957cd8d2a1121b.jpg","https:\/\/habrastorage.org\/getpro\/habr\/post_images\/609\/289\/c37\/609289c37cea41590ffcb94beebae7e5.jpg","https:\/\/habrastorage.org\/getpro\/habr\/post_images\/56a\/d36\/09c\/56ad3609c6bbe28990bc8894b163c50d.jpg","https:\/\/habrastorage.org\/getpro\/habr\/post_images\/71b\/e90\/b04\/71be90b04a538e953b4a0ee0d4ce2912.jpg","https:\/\/habrastorage.org\/getpro\/habr\/post_images\/15a\/5d0\/48e\/15a5d048e4fcf9b12c51cad50d7bfc3e.png","https:\/\/habrastorage.org\/getpro\/habr\/post_images\/25c\/708\/e50\/25c708e503f4528c313c557abb080222.jpg","https:\/\/habrastorage.org\/getpro\/habr\/post_images\/3cf\/49a\/34d\/3cf49a34dead2ff2e6f2542487edbf65.jpg","https:\/\/habrastorage.org\/getpro\/habr\/post_images\/2d7\/34f\/931\/2d734f931c687dde42e3bb549a695764.jpg","https:\/\/habrastorage.org\/getpro\/habr\/post_images\/360\/38d\/fc6\/36038dfc67c29ef2934d96314ed46aff.jpg","https:\/\/habrastorage.org\/getpro\/habr\/post_images\/7e9\/774\/4c2\/7e97744c28b0997b0b11049bee26fa7b.jpg","https:\/\/habrastorage.org\/getpro\/habr\/post_images\/fd9\/ed7\/de2\/fd9ed7de275ba36551e7751e1d351b8c.jpg","https:\/\/habrastorage.org\/getpro\/habr\/post_images\/0a5\/350\/e14\/0a5350e14231505c0ff1bd5cbf384e15.jpg","https:\/\/habrastorage.org\/getpro\/habr\/post_images\/649\/9df\/02c\/6499df02c248c9bab14a597b6b111d6d.jpg","https:\/\/habrastorage.org\/getpro\/habr\/post_images\/fe6\/4ee\/77c\/fe64ee77c1923920bc01de149ddb60e7.jpg","https:\/\/habrastorage.org\/getpro\/habr\/post_images\/64d\/9e5\/416\/64d9e541622b33d646b887db01c7c1a2.jpg","https:\/\/habrastorage.org\/getpro\/habr\/post_images\/184\/7dd\/daa\/1847dddaa38e0876bc829a2d5747c9ce.jpg","https:\/\/habrastorage.org\/getpro\/habr\/post_images\/7fa\/aff\/002\/7faaff002cc6d328d663c582c74a3628.jpg","https:\/\/habrastorage.org\/getpro\/habr\/post_images\/674\/662\/658\/6746626580dbe0d943c27bcda10f8a9d.jpg","https:\/\/habrastorage.org\/getpro\/habr\/post_images\/b0a\/a4e\/fca\/b0aa4efcae350fe8423e3bc8a1463d78.jpg","https:\/\/habrastorage.org\/getpro\/habr\/post_images\/2a6\/7ed\/667\/2a67ed667870cd52dcf0da4f366975b6.jpg","https:\/\/habrastorage.org\/getpro\/habr\/post_images\/ac7\/a84\/a9c\/ac7a84a9c8aa25c1685a2a5f83f7447f.jpg","https:\/\/habrastorage.org\/getpro\/habr\/post_images\/6f1\/073\/f03\/6f1073f03172250a5b4c052ebfdfd832.jpg","https:\/\/habrastorage.org\/getpro\/habr\/post_images\/077\/c17\/138\/077c1713805b1f95625c05fb11643c53.jpg","https:\/\/habrastorage.org\/getpro\/habr\/post_images\/14f\/7df\/63e\/14f7df63e4e1760304e4a2c6279953d1.jpg","https:\/\/habrastorage.org\/getpro\/habr\/post_images\/6db\/379\/add\/6db379add4ffc7f54a047f79b608d67f.jpg","https:\/\/habrastorage.org\/getpro\/habr\/post_images\/a60\/227\/b57\/a60227b575f307ad5a251aa817a49963.jpg","https:\/\/habrastorage.org\/getpro\/habr\/post_images\/014\/6eb\/5f4\/0146eb5f4da50018f5d28b4453e2424c.jpg","https:\/\/habrastorage.org\/getpro\/habr\/post_images\/164\/373\/d2c\/164373d2c3421c708e40dc9cb26eb7c9.jpg","https:\/\/habrastorage.org\/getpro\/habr\/post_images\/1e5\/3c0\/ae3\/1e53c0ae3680bebe785e64739c4ece43.jpg","https:\/\/habrastorage.org\/getpro\/habr\/post_images\/917\/f0d\/d04\/917f0dd0490ef8faa829ede007838906.jpg","https:\/\/habrastorage.org\/getpro\/habr\/post_images\/68c\/07d\/1d6\/68c07d1d6fd99f81cb0b3b63c9927a53.jpg","https:\/\/habrastorage.org\/getpro\/habr\/post_images\/1bf\/428\/855\/1bf4288554d1cef31c2607a4ca73c2bb.jpg","https:\/\/habrastorage.org\/getpro\/habr\/post_images\/e25\/7b3\/e14\/e257b3e14ac5b8a1f2b65525333924c5.jpg","https:\/\/habrastorage.org\/getpro\/habr\/post_images\/559\/e1c\/242\/559e1c242221886f5c0100fa66837c31.jpg","https:\/\/habrastorage.org\/getpro\/habr\/post_images\/bb5\/108\/a24\/bb5108a241181f23a66c7f3803d33cea.jpg","https:\/\/habrastorage.org\/getpro\/habr\/post_images\/955\/071\/c05\/955071c057420f3c4b083ed174046189.jpg","https:\/\/habrastorage.org\/getpro\/habr\/post_images\/37c\/488\/3ab\/37c4883ab098cd1bc4ef2d22187f7d16.jpg","https:\/\/habrastorage.org\/getpro\/habr\/post_images\/dcb\/332\/626\/dcb332626d34f07ecf1bd85928b7d1dc.jpg","https:\/\/habrastorage.org\/getpro\/habr\/post_images\/ba9\/320\/0d4\/ba93200d4f20e0a5bc361e96994b525b.png","https:\/\/habrastorage.org\/getpro\/habr\/post_images\/70a\/0b0\/dfe\/70a0b0dfeb9ca86eb86f137ac96c9811.jpg","https:\/\/habrastorage.org\/getpro\/habr\/post_images\/1f0\/b6c\/0a9\/1f0b6c0a97ed9ad17a6bc17f3ebcf6c6.png","https:\/\/habrastorage.org\/getpro\/habr\/post_images\/e34\/27e\/5f2\/e3427e5f2a925c8a78f77d81c5840da4.jpg","https:\/\/habrastorage.org\/getpro\/habr\/post_images\/bbc\/4f4\/967\/bbc4f4967c3bf008bf3692af3eb54d69.jpg","https:\/\/habrastorage.org\/getpro\/habr\/post_images\/a08\/746\/0a3\/a087460a37b1b88733e1fef632a566db.jpg","https:\/\/habrastorage.org\/getpro\/habr\/post_images\/0c6\/edc\/995\/0c6edc995e2f6cb4c6aeec6701c30ba3.jpg","https:\/\/habrastorage.org\/getpro\/habr\/post_images\/3e3\/8f1\/de3\/3e38f1de3016256205a5aa9199bb3a0d.jpg","https:\/\/habrastorage.org\/getpro\/habr\/post_images\/5b2\/080\/809\/5b20808099b641be7510714ffd45a737.jpg","https:\/\/habrastorage.org\/getpro\/habr\/post_images\/fa8\/51d\/853\/fa851d8539027d54d2874472d5952448.jpg","https:\/\/habrastorage.org\/getpro\/habr\/post_images\/b55\/9a1\/e0f\/b559a1e0f3ae66041cdf3f9f48ba4b06.jpg","https:\/\/habrastorage.org\/getpro\/habr\/post_images\/c6a\/389\/202\/c6a38920286de2fe269224a6b26ebd77.jpg","https:\/\/habrastorage.org\/getpro\/habr\/post_images\/9ca\/4ea\/52d\/9ca4ea52df8a22889828414ee2bfde05.jpg","https:\/\/habrastorage.org\/getpro\/habr\/post_images\/2ae\/357\/099\/2ae357099e5bfe5185d16103f87a6b69.jpg","https:\/\/habrastorage.org\/getpro\/habr\/post_images\/433\/5be\/2e4\/4335be2e49bd901916567734cc0485a5.jpg"]}</script>
  <script src="//www.googletagservices.com/tag/js/gpt.js" async></script>
  <style>.grecaptcha-badge{visibility: hidden;}</style>
  <meta name="habr-version" content="2.49.0">
  
  <meta data-vue-meta="ssr" property="fb:app_id" content="444736788986613"><meta data-vue-meta="ssr" property="fb:pages" content="472597926099084"><meta data-vue-meta="ssr" name="twitter:card" content="summary_large_image"><meta data-vue-meta="ssr" name="twitter:site" content="@habr_eng"><meta data-vue-meta="ssr" property="og:title" content="Как реализован рендеринг «Ведьмака 3»: молнии, ведьмачье чутьё и другие эффекты" data-vmid="og:title"><meta data-vue-meta="ssr" name="twitter:title" content="Как реализован рендеринг «Ведьмака 3»: молнии, ведьмачье чутьё и другие эффекты" data-vmid="twitter:title"><meta data-vue-meta="ssr" name="aiturec:title" content="Как реализован рендеринг «Ведьмака 3»: молнии, ведьмачье чутьё и другие эффекты" data-vmid="aiturec:title"><meta data-vue-meta="ssr" name="description" content="Часть 1. Молнии
В этой части мы рассмотрим процесс рендеринга молний в Witcher 3: Wild Hunt.

Рендеринг молний выполняется немного позже эффекта занавес дождя, но всё равно происходит в проходе..." data-vmid="description"><meta data-vue-meta="ssr" itemprop="description" content="Часть 1. Молнии
В этой части мы рассмотрим процесс рендеринга молний в Witcher 3: Wild Hunt.

Рендеринг молний выполняется немного позже эффекта занавес дождя, но всё равно происходит в проходе..." data-vmid="description:itemprop"><meta data-vue-meta="ssr" property="og:description" content="Часть 1. Молнии
В этой части мы рассмотрим процесс рендеринга молний в Witcher 3: Wild Hunt.

Рендеринг молний выполняется немного позже эффекта занавес дождя, но всё равно происходит в проходе..." data-vmid="og:description"><meta data-vue-meta="ssr" name="twitter:description" content="Часть 1. Молнии
В этой части мы рассмотрим процесс рендеринга молний в Witcher 3: Wild Hunt.

Рендеринг молний выполняется немного позже эффекта занавес дождя, но всё равно происходит в проходе..." data-vmid="twitter:description"><meta data-vue-meta="ssr" property="aiturec:description" content="Часть 1. Молнии
В этой части мы рассмотрим процесс рендеринга молний в Witcher 3: Wild Hunt.

Рендеринг молний выполняется немного позже эффекта занавес дождя, но всё равно происходит в проходе..." data-vmid="aiturec:description"><meta data-vue-meta="ssr" itemprop="image" content="https://habr.com/share/publication/450332/2a23dc9145a5e6f0c233f01cf73a2d4d/" data-vmid="image:itemprop"><meta data-vue-meta="ssr" property="og:image" content="https://habr.com/share/publication/450332/2a23dc9145a5e6f0c233f01cf73a2d4d/" data-vmid="og:image"><meta data-vue-meta="ssr" property="aiturec:image" content="https://habr.com/share/publication/450332/2a23dc9145a5e6f0c233f01cf73a2d4d/" data-vmid="aiturec:image"><meta data-vue-meta="ssr" name="twitter:image" content="https://habr.com/share/publication/450332/2a23dc9145a5e6f0c233f01cf73a2d4d/" data-vmid="twitter:image"><meta data-vue-meta="ssr" property="vk:image" content="https://habr.com/share/publication/450332/2a23dc9145a5e6f0c233f01cf73a2d4d/" data-vmid="vk:image"><meta data-vue-meta="ssr" property="aiturec:item_id" content="450332" data-vmid="aiturec:item_id"><meta data-vue-meta="ssr" property="aiturec:datetime" content="2019-05-03T12:58:39.000Z" data-vmid="aiturec:datetime"><meta data-vue-meta="ssr" property="og:type" content="article" data-vmid="og:type"><meta data-vue-meta="ssr" property="og:locale" content="ru_RU" data-vmid="og:locale"><meta data-vue-meta="ssr" property="og:image:width" content="1200" data-vmid="og:image:width"><meta data-vue-meta="ssr" property="og:image:height" content="630" data-vmid="og:image:height">
  <link data-vue-meta="ssr" href="https://habr.com/ru/rss/post/450332/?fl=ru" type="application/rss+xml" title="" rel="alternate" name="rss"><link data-vue-meta="ssr" href="https://habr.com/ru/post/450332/" rel="canonical" data-vmid="canonical"><link data-vue-meta="ssr" data-vmid="hreflang"><link data-vue-meta="ssr" image_src="image" href="https://habr.com/share/publication/450332/2a23dc9145a5e6f0c233f01cf73a2d4d/" data-vmid="image:href">
  <meta name="apple-mobile-web-app-status-bar-style" content="#303b44">
  <meta name="msapplication-TileColor" content="#629FBC">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="mobile-web-app-capable" content="yes">
  <link
    rel="shortcut icon"
    type="image/png"
    sizes="16x16"
    href="https://assets.habr.com/habr-web/img/favicons/favicon-16.png"
  >
  <link
    rel="shortcut icon"
    type="image/png"
    sizes="32x32"
    href="https://assets.habr.com/habr-web/img/favicons/favicon-32.png"
  >
  <link
    rel="apple-touch-icon"
    type="image/png"
    sizes="76x76"
    href="https://assets.habr.com/habr-web/img/favicons/apple-touch-icon-76.png"
  >
  <link
    rel="apple-touch-icon"
    type="image/png"
    sizes="120x120"
    href="https://assets.habr.com/habr-web/img/favicons/apple-touch-icon-120.png"
  >
  <link
    rel="apple-touch-icon"
    type="image/png"
    sizes="152x152"
    href="https://assets.habr.com/habr-web/img/favicons/apple-touch-icon-152.png"
  >
  <link
    rel="apple-touch-icon"
    type="image/png"
    sizes="180x180"
    href="https://assets.habr.com/habr-web/img/favicons/apple-touch-icon-180.png"
  >
  <link
    rel="apple-touch-icon"
    type="image/png"
    sizes="256x256"
    href="https://assets.habr.com/habr-web/img/favicons/apple-touch-icon-256.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 320px) and (device-height: 568px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1136x640.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 375px) and (device-height: 812px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_2436x1125.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1792x828.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_828x1792.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 375px) and (device-height: 667px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1334x750.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1242x2668.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 414px) and (device-height: 736px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_2208x1242.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 375px) and (device-height: 812px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1125x2436.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 414px) and (device-height: 736px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1242x2208.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 1024px) and (device-height: 1366px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_2732x2048.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_2688x1242.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 834px) and (device-height: 1112px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_2224x1668.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 375px) and (device-height: 667px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_750x1334.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 1024px) and (device-height: 1366px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_2048x2732.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 834px) and (device-height: 1194px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_2388x1668.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 834px) and (device-height: 1112px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1668x2224.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 320px) and (device-height: 568px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_640x1136.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 834px) and (device-height: 1194px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1668x2388.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 768px) and (device-height: 1024px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_2048x1536.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 768px) and (device-height: 1024px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1536x2048.png"
  >
  <link
    rel="mask-icon"
    color="#77a2b6"
    href="https://assets.habr.com/habr-web/img/favicons/apple-touch-icon-120.svg"
  >
  <link
    crossorigin="use-credentials"
    href="/manifest.webmanifest"
    rel="manifest"
  >
</head>
<body>


<div id="app" data-server-rendered="true" data-async-called="true"><div class="tm-layout__wrapper"><!----> <div></div> <!----> <header class="tm-header"><div class="tm-page-width"><div class="tm-header__container"><!----> <span class="tm-header__logo-wrap"><a href="/ru/" class="tm-header__logo tm-header__logo_ru"><svg height="16" width="16" class="tm-svg-img tm-header__icon"><title>Хабр</title> <use xlink:href="/img/habr-logo-ru.svg#logo"></use></svg></a> <span class="tm-header__beta-sign" style="display:none;">β</span></span> <div class="tm-dropdown tm-header__projects"><div class="tm-dropdown__head"><button class="tm-header__dropdown-toggle"><svg height="16" width="16" class="tm-svg-img tm-header__icon tm-header__icon_dropdown"><title>Открыть список</title> <use xlink:href="/img/megazord-v24.ce74655c.svg#arrow-down"></use></svg></button></div> <!----></div> <a href="/ru/sandbox/start/" class="tm-header__become-author-btn">
            Как стать автором
          </a> <div class="tm-feature tm-header__feature tm-feature_variant-inline"><!----></div> <!----> <!----></div></div></header> <div class="tm-layout"><div class="tm-page-progress-bar"></div> <div data-menu-sticky="true" class="tm-base-layout__header tm-base-layout__header_is-sticky"><div class="tm-page-width"><div class="tm-base-layout__header-wrapper"><div class="tm-main-menu"><div class="tm-main-menu__section"><nav class="tm-main-menu__section-content"><!----> <a href="/ru/all/" class="tm-main-menu__item">
        Все потоки
      </a> <a href="/ru/flows/develop/" class="tm-main-menu__item">
          Разработка
        </a><a href="/ru/flows/admin/" class="tm-main-menu__item">
          Администрирование
        </a><a href="/ru/flows/design/" class="tm-main-menu__item">
          Дизайн
        </a><a href="/ru/flows/management/" class="tm-main-menu__item">
          Менеджмент
        </a><a href="/ru/flows/marketing/" class="tm-main-menu__item">
          Маркетинг
        </a><a href="/ru/flows/popsci/" class="tm-main-menu__item">
          Научпоп
        </a></nav></div></div> <div class="tm-header-user-menu tm-base-layout__user-menu"><a href="/ru/search/" class="tm-header-user-menu__item tm-header-user-menu__search"><svg height="24" width="24" class="tm-svg-img tm-header-user-menu__icon tm-header-user-menu__icon_search tm-header-user-menu__icon_dark"><title>Поиск</title> <use xlink:href="/img/megazord-v24.ce74655c.svg#search"></use></svg></a> <!----> <!----> <!----> <div class="tm-header-user-menu__item tm-header-user-menu__user_desktop"><div class="tm-dropdown"><div class="tm-dropdown__head"><svg height="24" width="24" data-test-id="menu-toggle-guest" class="tm-svg-img tm-header-user-menu__icon"><title>Профиль</title> <use xlink:href="/img/megazord-v24.ce74655c.svg#header-user"></use></svg> <!----></div> <!----></div> <!----></div> <!----></div></div></div></div> <!----> <div class="tm-page-width"></div> <main class="tm-layout__container"><div hl="ru" data-async-called="true" class="tm-page"><div class="tm-page-width"><!----> <div class="tm-page__wrapper"><div class="tm-page__main tm-page__main_has-sidebar"><div class="pull-down"><div class="pull-down__header" style="height:0px;"><div class="pull-down__content" style="bottom:10px;"><svg height="24" width="24" class="tm-svg-img pull-down__arrow"><title>Обновить</title> <use xlink:href="/img/megazord-v24.ce74655c.svg#pull-arrow"></use></svg></div></div> <div class="tm-article-presenter"> <div class="tm-article-presenter__body"><div class="tm-misprint-area"><div class="tm-misprint-area__wrapper"><article class="tm-article-presenter__content tm-article-presenter__content_narrow"><div class="tm-article-presenter__header"> <div class="tm-article-snippet tm-article-presenter__snippet"><div class="tm-article-snippet__meta-container"><div class="tm-article-snippet__meta"><span class="tm-user-info tm-article-snippet__author"><a href="/ru/users/PatientZero/" title="PatientZero" class="tm-user-info__userpic"><div class="tm-entity-image"><img alt="" height="24" loading="lazy" src="//habrastorage.org/r/w32/getpro/habr/avatars/8de/9c5/34a/8de9c534a18a6cb8693270a2b528d4c0.png" width="24" class="tm-entity-image__pic"></div></a> <span class="tm-user-info__user"><a href="/ru/users/PatientZero/" class="tm-user-info__username">
      PatientZero
    </a> </span></span> <span class="tm-article-snippet__datetime-published"><time datetime="2019-05-03T12:58:39.000Z" title="2019-05-03, 15:58">3  мая  2019 в 15:58</time></span></div> <!----></div> <h1 lang="ru" class="tm-article-snippet__title tm-article-snippet__title_h1"><span>Как реализован рендеринг «Ведьмака 3»: молнии, ведьмачье чутьё и другие эффекты</span></h1> <div class="tm-article-snippet__hubs"><span class="tm-article-snippet__hubs-item"><a href="/ru/hub/3d_graphics/" class="tm-article-snippet__hubs-item-link"><span>Работа с 3D-графикой</span> <span title="Профильный хаб" class="tm-article-snippet__profiled-hub">*</span></a></span><span class="tm-article-snippet__hubs-item"><a href="/ru/hub/gamedev/" class="tm-article-snippet__hubs-item-link"><span>Разработка игр</span> <span title="Профильный хаб" class="tm-article-snippet__profiled-hub">*</span></a></span><span class="tm-article-snippet__hubs-item"><a href="/ru/hub/reverse-engineering/" class="tm-article-snippet__hubs-item-link"><span>Реверс-инжиниринг</span> <span title="Профильный хаб" class="tm-article-snippet__profiled-hub">*</span></a></span><span class="tm-article-snippet__hubs-item"><a href="/ru/hub/game_design/" class="tm-article-snippet__hubs-item-link"><span>Дизайн игр</span> <span title="Профильный хаб" class="tm-article-snippet__profiled-hub">*</span></a></span></div> <div class="tm-article-snippet__labels"><div class="tm-article-snippet__label"><span>
        Перевод
      </span></div></div> <!----> <!----></div></div> <div class="tm-article-presenter__origin"><a href="http://astralcode.blogspot.com/2019/03/reverse-engineering-rendering-of.html" target="_blank" class="tm-article-presenter__origin-link">
                Автор оригинала:
                <span>
                  Mateusz Nagórka
                </span></a></div> <div data-gallery-root="" lang="ru" class="tm-article-body"><div id="post-content-body" class="article-formatted-body article-formatted-body_version-1"><div xmlns="http://www.w3.org/1999/xhtml"><div style="text-align:center;"><img src="https://4.bp.blogspot.com/-got60f2XK9Y/XKihDpXA0cI/AAAAAAAABbw/36hozFGj4XszEAa6uD4cZKbowexKxyPYQCEwYBhgL/s1600/after.jpg" alt="image" data-src="https://4.bp.blogspot.com/-got60f2XK9Y/XKihDpXA0cI/AAAAAAAABbw/36hozFGj4XszEAa6uD4cZKbowexKxyPYQCEwYBhgL/s1600/after.jpg" data-blurred="true"/></div><br/>
<h2>Часть 1. Молнии</h2><br/>
В этой части мы рассмотрим процесс рендеринга молний в Witcher 3: Wild Hunt.<br/>
<br/>
Рендеринг молний выполняется немного позже эффекта <a href="https://astralcode.blogspot.com/2019/01/reverse-engineering-rendering-of.html">занавес дождя</a>, но всё равно происходит в проходе прямого рендеринга. Молнии можно увидеть на этом видео:<br/>
<br/>
<div class="oembed"><div><div style="left: 0; width: 100%; height: 0; position: relative; padding-bottom: 56.2493%;"><div class="tm-iframe_temp" data-src="https://www.youtube.com/embed/VXt4PEEqV2k?rel=0&amp;showinfo=1&amp;hl=en-US" data-style="border: 0; top: 0; left: 0; width: 100%; height: 100%; position: absolute;" id="" width=""></div></div></div></div><br/>
Они очень быстро исчезают, поэтому лучше просматривать видео на скорости 0.25.<br/>
<br/>
Можно увидеть, что это не статичные изображения; со временем их яркость слегка меняется.<br/>
<br/>
С точки зрения нюансов рендеринга здесь есть очень много сходств с отрисовкой занавес дождя в отдалении, например, такие же состояния смешивания (аддитивное смешивание) и глубины (проверка включена, запись глубин не выполняется).<br/>
<a name="habracut"></a><br/>
<div style="text-align:center;"><img src="https://4.bp.blogspot.com/-5es7NCJkWgA/XHzXwxzzwKI/AAAAAAAABS4/EuUafquFSooo7fWjCaohDvKVlRDHZoNLgCLcBGAs/s1600/02_before.jpg" data-src="https://4.bp.blogspot.com/-5es7NCJkWgA/XHzXwxzzwKI/AAAAAAAABS4/EuUafquFSooo7fWjCaohDvKVlRDHZoNLgCLcBGAs/s1600/02_before.jpg" data-blurred="true"/></div><br/>
<i>Сцена без молнии</i><br/>
<br/>
<div style="text-align:center;"><img src="https://3.bp.blogspot.com/-0NvAFDUK8AA/XHzXw71T-nI/AAAAAAAABS0/imLLd1Ru6MQLoinlqqge-6OSp5QRwZo4QCLcBGAs/s1600/03_after.jpg" data-src="https://3.bp.blogspot.com/-0NvAFDUK8AA/XHzXw71T-nI/AAAAAAAABS0/imLLd1Ru6MQLoinlqqge-6OSp5QRwZo4QCLcBGAs/s1600/03_after.jpg" data-blurred="true"/></div><br/>
<i>Сцена с молнией</i><br/>
<br/>
С точки зрения геометрии молнии в «Ведьмаке 3» — это древоподобные меши. Данный пример молнии представлен следующим мешем:<br/>
<br/>
<div style="text-align:center;"><img src="https://1.bp.blogspot.com/-gLuV3RWUQD4/XHzYBCYC8sI/AAAAAAAABTE/l9VnSVyp9b4GGeiGWvTBDg2E3Rc79RUrQCLcBGAs/s1600/01_geometry.JPG"/></div><br/>
Он имеет UV-координаты и векторы нормалей. Всё это пригодится на этапе вершинного шейдера.<br/>
<br/>
<h3>Вершинный шейдер</h3><br/>
Давайте взглянем на ассемблерный код вершинного шейдера:<br/>
<br/>
<pre><code class="cpp"> vs_5_0  
    dcl_globalFlags refactoringAllowed  
    dcl_constantbuffer cb1[9], immediateIndexed  
    dcl_constantbuffer cb2[6], immediateIndexed  
    dcl_input v0.xyz  
    dcl_input v1.xy  
    dcl_input v2.xyz  
    dcl_input v4.xyzw  
    dcl_input v5.xyzw  
    dcl_input v6.xyzw  
    dcl_input v7.xyzw  
    dcl_output o0.xy  
    dcl_output o1.xyzw  
    dcl_output_siv o2.xyzw, position  
    dcl_temps 3  
   0: mov o0.xy, v1.xyxx  
   1: mov o1.xyzw, v7.xyzw  
   2: mul r0.xyzw, v5.xyzw, cb1[0].yyyy  
   3: mad r0.xyzw, v4.xyzw, cb1[0].xxxx, r0.xyzw  
   4: mad r0.xyzw, v6.xyzw, cb1[0].zzzz, r0.xyzw  
   5: mad r0.xyzw, cb1[0].wwww, l(0.000000, 0.000000, 0.000000, 1.000000), r0.xyzw  
   6: mov r1.w, l(1.000000)  
   7: mad r1.xyz, v0.xyzx, cb2[4].xyzx, cb2[5].xyzx  
   8: dp4 r2.x, r1.xyzw, v4.xyzw  
   9: dp4 r2.y, r1.xyzw, v5.xyzw  
  10: dp4 r2.z, r1.xyzw, v6.xyzw  
  11: add r2.xyz, r2.xyzx, -cb1[8].xyzx  
  12: dp3 r1.w, r2.xyzx, r2.xyzx  
  13: rsq r1.w, r1.w  
  14: div r1.w, l(1.000000, 1.000000, 1.000000, 1.000000), r1.w  
  15: mul r1.w, r1.w, l(0.000001)  
  16: mad r2.xyz, v2.xyzx, l(2.000000, 2.000000, 2.000000, 0.000000), l(-1.000000, -1.000000, -1.000000, 0.000000)  
  17: mad r1.xyz, r2.xyzx, r1.wwww, r1.xyzx  
  18: mov r1.w, l(1.000000)  
  19: dp4 o2.x, r1.xyzw, r0.xyzw  
  20: mul r0.xyzw, v5.xyzw, cb1[1].yyyy  
  21: mad r0.xyzw, v4.xyzw, cb1[1].xxxx, r0.xyzw  
  22: mad r0.xyzw, v6.xyzw, cb1[1].zzzz, r0.xyzw  
  23: mad r0.xyzw, cb1[1].wwww, l(0.000000, 0.000000, 0.000000, 1.000000), r0.xyzw  
  24: dp4 o2.y, r1.xyzw, r0.xyzw  
  25: mul r0.xyzw, v5.xyzw, cb1[2].yyyy  
  26: mad r0.xyzw, v4.xyzw, cb1[2].xxxx, r0.xyzw  
  27: mad r0.xyzw, v6.xyzw, cb1[2].zzzz, r0.xyzw  
  28: mad r0.xyzw, cb1[2].wwww, l(0.000000, 0.000000, 0.000000, 1.000000), r0.xyzw  
  29: dp4 o2.z, r1.xyzw, r0.xyzw  
  30: mul r0.xyzw, v5.xyzw, cb1[3].yyyy  
  31: mad r0.xyzw, v4.xyzw, cb1[3].xxxx, r0.xyzw  
  32: mad r0.xyzw, v6.xyzw, cb1[3].zzzz, r0.xyzw  
  33: mad r0.xyzw, cb1[3].wwww, l(0.000000, 0.000000, 0.000000, 1.000000), r0.xyzw  
  34: dp4 o2.w, r1.xyzw, r0.xyzw  
  35: ret</code></pre> <br/>
Здесь есть много сходств с вершинным шейдером занавес дождя, поэтому я не буду повторяться. Хочу показать вам важное отличие, которое есть в строках 11-18:<br/>
<br/>
<pre><code class="cpp">  11: add r2.xyz, r2.xyzx, -cb1[8].xyzx  
  12: dp3 r1.w, r2.xyzx, r2.xyzx  
  13: rsq r1.w, r1.w  
  14: div r1.w, l(1.000000, 1.000000, 1.000000, 1.000000), r1.w  
  15: mul r1.w, r1.w, l(0.000001)  
  16: mad r2.xyz, v2.xyzx, l(2.000000, 2.000000, 2.000000, 0.000000), l(-1.000000, -1.000000, -1.000000, 0.000000)  
  17: mad r1.xyz, r2.xyzx, r1.wwww, r1.xyzx  
  18: mov r1.w, l(1.000000)  
  19: dp4 o2.x, r1.xyzw, r0.xyzw</code></pre><br/>
Во-первых, cb1[8].xyz — это позиция камеры, а r2.xyz позиция в мировом пространстве, то есть строка 11 вычисляет вектор из камеры к позиции в мире. Затем строки 12-15 вычисляют <i>length( worldPos — cameraPos) * 0.000001.</i><br/>
<br/>
v2.xyz — это вектор нормали входящей геометрии. Строка 16 расширяет его из интервала [0-1] до интервала [-1;1].<br/>
<br/>
Затем вычисляется конечная позиция в мире:<br/>
<br/>
<i>finalWorldPos = worldPos + length( worldPos — cameraPos) * 0.000001 * normalVector</i><br/>
Фрагмент кода HLSL для этой операции будет примерно таким:<br/>
<br/>
<pre><code class="cpp">      ...  
      // final world-space position  
      float3 vNormal = Input.NormalW * 2.0 - 1.0;  
      float lencameratoworld = length( PositionL - g_cameraPos.xyz) * 0.000001;  
   
      PositionL += vNormal*lencameratoworld;  
   
      // SV_Posiiton   
      float4x4 matModelViewProjection = mul(g_viewProjMatrix, matInstanceWorld );   
      Output.PositionH = mul( float4(PositionL, 1.0), transpose(matModelViewProjection) );      
   
      return Output;</code></pre><br/>
Эта операция приводит к небольшому «взрыву» меша (в направлении вектора нормали). Я поэкспериментировал, заменив 0.000001 на несколько других значений. Вот результаты:<br/>
<br/>
<div style="text-align:center;"><img src="https://3.bp.blogspot.com/-04VBXtCtToU/XHzeCdlnGzI/AAAAAAAABTQ/Jfj--N3P6qwJdWydT2uUiWtrifmPdyKPgCEwYBhgL/s1600/04_value_0.000002.jpg" data-src="https://3.bp.blogspot.com/-04VBXtCtToU/XHzeCdlnGzI/AAAAAAAABTQ/Jfj--N3P6qwJdWydT2uUiWtrifmPdyKPgCEwYBhgL/s1600/04_value_0.000002.jpg" data-blurred="true"/></div><br/>
<i>0.000002</i><br/>
<br/>
<div style="text-align:center;"><img src="https://2.bp.blogspot.com/-URy-AsVMJ08/XHzeCaZEkvI/AAAAAAAABTU/MisCn2gjCSIsTKrqMU3FXTe8DBPCKguhwCEwYBhgL/s1600/05_value_0.000005.jpg" data-src="https://2.bp.blogspot.com/-URy-AsVMJ08/XHzeCaZEkvI/AAAAAAAABTU/MisCn2gjCSIsTKrqMU3FXTe8DBPCKguhwCEwYBhgL/s1600/05_value_0.000005.jpg" data-blurred="true"/></div><br/>
<i>0.000005</i><br/>
<br/>
<div style="text-align:center;"><img src="https://2.bp.blogspot.com/-dckY8djA4Z4/XHzeCprPZjI/AAAAAAAABTY/O4ZXF2miPNs30zuuvAi1wFFvKff2_F17gCEwYBhgL/s1600/06_value_0.00001.jpg" data-src="https://2.bp.blogspot.com/-dckY8djA4Z4/XHzeCprPZjI/AAAAAAAABTY/O4ZXF2miPNs30zuuvAi1wFFvKff2_F17gCEwYBhgL/s1600/06_value_0.00001.jpg" data-blurred="true"/></div><br/>
<i>0.00001</i><br/>
<br/>
<div style="text-align:center;"><img src="https://1.bp.blogspot.com/-xBxlg15e6jI/XHzeDUvtImI/AAAAAAAABTc/WpJ_MwAaQvIgfHj98Z-43cKQd4vVijg-wCEwYBhgL/s1600/07_value_0.000025.jpg" data-src="https://1.bp.blogspot.com/-xBxlg15e6jI/XHzeDUvtImI/AAAAAAAABTc/WpJ_MwAaQvIgfHj98Z-43cKQd4vVijg-wCEwYBhgL/s1600/07_value_0.000025.jpg" data-blurred="true"/></div><br/>
<i>0.000025</i><br/>
<br/>
<h3>Пиксельный шейдер</h3><br/>
Отлично, мы разобрались с вершинным шейдером, теперь пора взяться за ассемблерный код пиксельного шейдера!<br/>
<br/>
<pre><code class="cpp"> ps_5_0  
    dcl_globalFlags refactoringAllowed  
    dcl_constantbuffer cb0[1], immediateIndexed  
    dcl_constantbuffer cb2[3], immediateIndexed  
    dcl_constantbuffer cb4[5], immediateIndexed  
    dcl_input_ps linear v0.x  
    dcl_input_ps linear v1.w  
    dcl_output o0.xyzw  
    dcl_temps 1  
   0: mad r0.x, cb0[0].x, cb4[4].x, v0.x  
   1: add r0.y, r0.x, l(-1.000000)  
   2: round_ni r0.y, r0.y  
   3: ishr r0.z, r0.y, l(13)  
   4: xor r0.y, r0.y, r0.z  
   5: imul null, r0.z, r0.y, r0.y  
   6: imad r0.z, r0.z, l(0x0000ec4d), l(0.0000000000000000000000000000000000001)  
   7: imad r0.y, r0.y, r0.z, l(146956042240.000000)  
   8: and r0.y, r0.y, l(0x7fffffff)  
   9: round_ni r0.z, r0.x  
  10: frc r0.x, r0.x  
  11: add r0.x, -r0.x, l(1.000000)  
  12: ishr r0.w, r0.z, l(13)  
  13: xor r0.z, r0.z, r0.w  
  14: imul null, r0.w, r0.z, r0.z  
  15: imad r0.w, r0.w, l(0x0000ec4d), l(0.0000000000000000000000000000000000001)  
  16: imad r0.z, r0.z, r0.w, l(146956042240.000000)  
  17: and r0.z, r0.z, l(0x7fffffff)  
  18: itof r0.yz, r0.yyzy  
  19: mul r0.z, r0.z, l(0.000000001)  
  20: mad r0.y, r0.y, l(0.000000001), -r0.z  
  21: mul r0.w, r0.x, r0.x  
  22: mul r0.x, r0.x, r0.w  
  23: mul r0.w, r0.w, l(3.000000)  
  24: mad r0.x, r0.x, l(-2.000000), r0.w  
  25: mad r0.x, r0.x, r0.y, r0.z  
  26: add r0.y, -cb4[2].x, cb4[3].x  
  27: mad_sat r0.x, r0.x, r0.y, cb4[2].x  
  28: mul r0.x, r0.x, v1.w  
  29: mul r0.yzw, cb4[0].xxxx, cb4[1].xxyz  
  30: mul r0.xyzw, r0.xyzw, cb2[2].wxyz  
  31: mul o0.xyz, r0.xxxx, r0.yzwy  
  32: mov o0.w, r0.x  
  33: ret</code></pre> <br/>
Хорошая новость: код не такой длинный.<br/>
<br/>
Плохая новость:<br/>
<br/>
<pre><code class="cpp">   3: ishr r0.z, r0.y, l(13)  
   4: xor r0.y, r0.y, r0.z  
   5: imul null, r0.z, r0.y, r0.y  
   6: imad r0.z, r0.z, l(0x0000ec4d), l(0.0000000000000000000000000000000000001)  
   7: imad r0.y, r0.y, r0.z, l(146956042240.000000)  
   8: and r0.y, r0.y, l(0x7fffffff)</code></pre><br/>
… что это вообще такое?<br/>
<br/>
Честно говоря, я не впервые вижу подобный кусок… ассемблерного кода в шейдерах «Ведьмака 3». Но когда я встретил его в первый раз, то подумал: «Что за фигня?»<br/>
<br/>
Нечто подобное можно найти в некоторых других шейдерах TW3. Не буду описывать свои приключения с этим фрагментом, и просто скажу, что ответ заключается в <a href="http://libnoise.sourceforge.net/noisegen/">целочисленном шуме</a>:<br/>
<br/>
<pre><code class="cpp"> // For more details see: http://libnoise.sourceforge.net/noisegen/  
 float integerNoise( int n )  
 {  
      n = (n >> 13) ^ n;  
      int nn = (n * (n * n * 60493 + 19990303) + 1376312589) &amp; 0x7fffffff;  
      return ((float)nn / 1073741824.0);  
 }</code></pre><br/>
Как видите, в пиксельном шейдере он вызывается дважды. Пользуясь руководствами с этого веб-сайта, мы можем понять, как правильно реализуется плавный шум. Я вернусь к этому через минуту.<br/>
<br/>
Посмотрите на строку 0 — здесь мы выполняем анимацию на основании следующей формулы:<br/>
<br/>
<i>animation = elapsedTime * animationSpeed + TextureUV.x</i><br/>
Эти значения, после округления в меньшую сторону (<a href="https://docs.microsoft.com/en-us/windows/desktop/direct3dhlsl/dx-graphics-hlsl-floor">floor</a>) (инструкция <i>round_ni</i>) в дальнейшем становятся входными точками для целочисленного шума. Обычно мы вычисляем значение шума для двух целых чисел, а затем вычисляем окончательное, интерполированное значение между ними (подробности см. на веб-сайте libnoise).<br/>
<br/>
Ну ладно, это <b>целочисленный</b> шум, но ведь все ранее упомянутые значения (тоже округлённые в меньшую сторону) являются float!<br/>
<br/>
Заметьте, что здесь нет инструкций <a href="https://docs.microsoft.com/en-us/windows/desktop/direct3dhlsl/ftoi--sm4---asm-">ftoi</a>. Я предполагаю, что программисты из CD Projekt Red воспользовались здесь внутренней функцией HLSL <a href="https://docs.microsoft.com/en-us/windows/desktop/direct3dhlsl/dx-graphics-hlsl-asint">asint</a>, которая выполняет преобразование «reinterpret_cast» значений с плавающей запятой и обрабатывает их как целочисленный паттерн.<br/>
<br/>
Вес интерполяции для двух значений вычисляется в строках 10-11<br/>
<br/>
<i>interpolationWeight = 1.0 — frac( animation );</i><br/>
Такой подход позволяет нам выполнять интерполирование между значения с учётом времени.<br/>
<br/>
Для создания плавного шума этот интерполятор передается функции <b>SCurve</b>:<br/>
<br/>
<pre><code class="cpp"> float s_curve( float x )  
 {  
   float x2 = x * x;  
   float x3 = x2 * x;  
     
   // -2x^3 + 3x^2  
   return -2.0*x3 + 3.0*x2;  
 }</code></pre><br/>
<div style="text-align:center;"><img src="/img/image-loader.svg" data-src="https://3.bp.blogspot.com/-WxNWwK5n4ug/XHzmnoWFLBI/AAAAAAAABT4/KOeYq786NEYJFJoxaTArBp5lQ0bGmSS8gCLcBGAs/s1600/scurve.png"/></div><br/>
<i>Функция Smoothstep [libnoise.sourceforge.net]</i><br/>
<br/>
Эта функция известна под названием «smoothstep». Но как видно из ассемблерного кода, это <b>не</b> внутренняя функция <a href="https://docs.microsoft.com/en-us/windows/desktop/direct3dhlsl/dx-graphics-hlsl-smoothstep">smoothstep</a> из HLSL. Внутренняя функция применяет ограничения, чтобы значения были верными. Но поскольку мы знаем, что <i>interpolationWeight</i> всегда будет находиться в интервале [0-1], эти проверки можно спокойно пропустить.<br/>
<br/>
При вычислении окончательного значения используется несколько операций умножения. Посмотрите, как может меняться окончательное выходное значение альфы в зависимости от значения шума. Это удобно, потому что будет влиять на непрозрачность отрендеренной молнии, совсем как в реальной жизни.<br/>
<br/>
Готовый пиксельный шейдер:<br/>
<br/>
<pre><code class="cpp"> cbuffer cbPerFrame : register (b0)  
 {  
   float4 cb0_v0;  
   float4 cb0_v1;  
   float4 cb0_v2;  
   float4 cb0_v3;  
 }  
   
 cbuffer cbPerFrame : register (b2)  
 {  
   float4 cb2_v0;  
   float4 cb2_v1;  
   float4 cb2_v2;  
   float4 cb2_v3;  
 }  
   
 cbuffer cbPerFrame : register (b4)  
 {  
   float4 cb4_v0;  
   float4 cb4_v1;  
   float4 cb4_v2;  
   float4 cb4_v3;  
   float4 cb4_v4;  
 }  
   
 struct VS_OUTPUT  
 {  
   float2 Texcoords : Texcoord0;  
   float4 InstanceLODParams : INSTANCE_LOD_PARAMS;  
   float4 PositionH : SV_Position;  
 };  
   
 // Shaders in TW3 use integer noise.  
 // For more details see: http://libnoise.sourceforge.net/noisegen/  
 float integerNoise( int n )  
 {  
   n = (n >> 13) ^ n;  
   int nn = (n * (n * n * 60493 + 19990303) + 1376312589) &amp; 0x7fffffff;  
   return ((float)nn / 1073741824.0);  
 }  
   
 float s_curve( float x )  
 {  
   float x2 = x * x;  
   float x3 = x2 * x;  
   
   // -2x^3 + 3x^2  
   return -2.0*x3 + 3.0*x2;  
 }  
   
 float4 Lightning_TW3_PS( in VS_OUTPUT Input ) : SV_Target
 {  
   // * Inputs  
   float elapsedTime = cb0_v0.x;  
   float animationSpeed = cb4_v4.x;  
   
   float minAmount = cb4_v2.x;  
   float maxAmount = cb4_v3.x;  
   
   float colorMultiplier = cb4_v0.x;  
   float3 colorFilter = cb4_v1.xyz;  
   float3 lightningColorRGB = cb2_v2.rgb;  
   
   
   // Animation using time and X texcoord  
   float animation = elapsedTime * animationSpeed + Input.Texcoords.x;  
   
   // Input parameters for Integer Noise.  
   // They are floored and please note there are using asint.  
   // That might be an optimization to avoid "ftoi" instructions.  
   int intX0 = asint( floor(animation) );  
   int intX1 = asint( floor(animation-1.0) );  
   
   float n0 = integerNoise( intX0 );  
   float n1 = integerNoise( intX1 );    
   
   // We interpolate "backwards" here.  
   float weight = 1.0 - frac(animation);  
   
   // Following the instructions from libnoise, we perform  
   // smooth interpolation here with cubic s-curve function.  
   float noise = lerp( n0, n1, s_curve(weight) );  
   
   // Make sure we are in [0.0 - 1.0] range.  
   float lightningAmount = saturate( lerp(minAmount, maxAmount, noise) );  
   lightningAmount *= Input.InstanceLODParams.w;    // 1.0  
   lightningAmount *= cb2_v2.w;             // 1.0  
   
   // Calculate final lightning color   
   float3 lightningColor = colorMultiplier * colorFilter;  
   lightningColor *= lighntingColorRGB;  
   
   float3 finalLightningColor = lightningColor * lightningAmount;  
   return float4( finalLightningColor, lightningAmount );  
 }</code></pre><br/>
<h3>Подведём итог</h3><br/>
В этой части я описал способ рендеринга молний в «Ведьмаке 3».<br/>
<br/>
Я очень доволен тем, что получившийся из моего шейдера ассемблерный код полностью совпадает с оригинальным!<br/>
<br/>
<div style="text-align:center;"><img src="https://3.bp.blogspot.com/-mzsVLwDyri0/XH6i1ofT5xI/AAAAAAAABUI/CZiE-02xSPElbDuAsCRtDH4Wrninhc4ugCLcBGAs/s1600/08_diff.JPG"/></div><br/>
<h2>Часть 2. Глупые трюки с небом</h2><br/>
Эта часть будет немного отличаться от предыдущих. В ней я хочу показать вам некоторые аспекты шейдеров неба Witcher 3.<br/>
<br/>
Почему «глупые трюки», а не весь шейдер? Ну, на то есть несколько причин. Во-первых, шейдер неба Witcher 3 — довольно сложная зверюга. Пиксельный шейдер из версии 2015 года содержит 267 строк ассемблерного кода, а шейдер из DLC «Кровь и вино» — уже 385 строк.<br/>
<br/>
Более того, они получают множество входных данных, что не очень способствует реверс-инжинирингу полного (и читаемого!) кода на HLSL.<br/>
<br/>
Поэтому я решил показать из этих шейдеров только часть трюков. Если я найду что-то новое, то дополню пост.<br/>
<br/>
Различия между версией 2015 года и DLC (2016 год) сильно заметны. В том, числе в них входят различия в вычислении звёзд и их мерцания, разный подход к рендерингу Солнца… Шейдер <i>«Крови и вина»</i> даже вычисляет ночью Млечный путь.<br/>
<br/>
Я начну с основ, а потом расскажу о глупых трюках.<br/>
<br/>
<h3>Основы</h3><br/>
Как и в большинстве современных игр, в Witcher 3 для моделирования неба используется skydome. Посмотрите на полусферу, которую использовали для этого в Witcher 3 (2015). Примечание: в данном случае ограничивающий параллелепипед этого меша находится в интервале от [0,0,0] до [1,1,1] (Z — это ось, направленная вверх) и имеет плавно распределённые UV. Позже мы их используем.<br/>
<br/>
<div style="text-align:center;"><img src="https://1.bp.blogspot.com/-nibxaoZQU2Q/XI1ryQ_R5pI/AAAAAAAABVs/ncEn1cudCrQczYP4s8ovg7wM2pzORXx7gCLcBGAs/s1600/skybox_mesh_input.JPG"/></div><br/>
Идея в основе skydome схожа с идеей <a href="https://en.wikipedia.org/wiki/Skybox_(video_games)">скайбокса</a> (единственная разница заключается в используемом меше). На этапе вершинного шейдера мы преобразуем skydome относительно наблюдателя (обычно в соответствии с позицией камеры), что создаёт иллюзию того, что небо и в самом деле находится очень далеко — мы никогда до него не доберёмся.<br/>
<br/>
Если вы читали предыдущие части этой серии статей, то знаете, что в «Ведьмаке 3» используется обратная глубина, то есть дальняя плоскость имеет значение 0.0f, а ближняя — 1.0f. Чтобы вывод skydome целиком выполнялся на дальней плоскости, в параметрах окна обзора мы задаём <i>MinDepth</i> то же значение, что и <i>MaxDepth</i>:<br/>
<br/>
<div style="text-align:center;"><img src="https://3.bp.blogspot.com/-xrQqWzpY-k4/XI4rRQsgpzI/AAAAAAAABWY/GkV8mhSb5AQ8Z-FKaWl_zaKtIO9nbe1BgCLcBGAs/s1600/viewport.JPG"/></div><br/>
Чтобы узнать, как поля <i>MinDepth</i> и <i>MaxDepth</i> используются во время преобразования окна обзора, нажмите <a href="https://docs.microsoft.com/en-us/windows/desktop/direct3d11/d3d10-graphics-programming-guide-rasterizer-stage-getting-started">сюда</a> (docs.microsoft.com).<br/>
<br/>
<h3>Вершинный шейдер</h3><br/>
Давайте начнём с вершинного шейдера. В Witcher 3 (2015 год) ассемблерный код шейдера имеет следующий вид:<br/>
<br/>
<pre><code class="cpp"> vs_5_0  
    dcl_globalFlags refactoringAllowed  
    dcl_constantbuffer cb1[4], immediateIndexed  
    dcl_constantbuffer cb2[6], immediateIndexed  
    dcl_input v0.xyz  
    dcl_input v1.xy  
    dcl_output o0.xy  
    dcl_output o1.xyz  
    dcl_output_siv o2.xyzw, position  
    dcl_temps 2  
   0: mov o0.xy, v1.xyxx  
   1: mad r0.xyz, v0.xyzx, cb2[4].xyzx, cb2[5].xyzx  
   2: mov r0.w, l(1.000000)  
   3: dp4 o1.x, r0.xyzw, cb2[0].xyzw  
   4: dp4 o1.y, r0.xyzw, cb2[1].xyzw  
   5: dp4 o1.z, r0.xyzw, cb2[2].xyzw  
   6: mul r1.xyzw, cb1[0].yyyy, cb2[1].xyzw  
   7: mad r1.xyzw, cb2[0].xyzw, cb1[0].xxxx, r1.xyzw  
   8: mad r1.xyzw, cb2[2].xyzw, cb1[0].zzzz, r1.xyzw  
   9: mad r1.xyzw, cb1[0].wwww, l(0.000000, 0.000000, 0.000000, 1.000000), r1.xyzw  
  10: dp4 o2.x, r0.xyzw, r1.xyzw  
  11: mul r1.xyzw, cb1[1].yyyy, cb2[1].xyzw  
  12: mad r1.xyzw, cb2[0].xyzw, cb1[1].xxxx, r1.xyzw  
  13: mad r1.xyzw, cb2[2].xyzw, cb1[1].zzzz, r1.xyzw  
  14: mad r1.xyzw, cb1[1].wwww, l(0.000000, 0.000000, 0.000000, 1.000000), r1.xyzw  
  15: dp4 o2.y, r0.xyzw, r1.xyzw  
  16: mul r1.xyzw, cb1[2].yyyy, cb2[1].xyzw  
  17: mad r1.xyzw, cb2[0].xyzw, cb1[2].xxxx, r1.xyzw  
  18: mad r1.xyzw, cb2[2].xyzw, cb1[2].zzzz, r1.xyzw  
  19: mad r1.xyzw, cb1[2].wwww, l(0.000000, 0.000000, 0.000000, 1.000000), r1.xyzw  
  20: dp4 o2.z, r0.xyzw, r1.xyzw  
  21: mul r1.xyzw, cb1[3].yyyy, cb2[1].xyzw  
  22: mad r1.xyzw, cb2[0].xyzw, cb1[3].xxxx, r1.xyzw  
  23: mad r1.xyzw, cb2[2].xyzw, cb1[3].zzzz, r1.xyzw  
  24: mad r1.xyzw, cb1[3].wwww, l(0.000000, 0.000000, 0.000000, 1.000000), r1.xyzw  
  25: dp4 o2.w, r0.xyzw, r1.xyzw  
  26: ret</code></pre><br/>
В данном случае вершинный шейдер передаёт на выход только texcoords и позицию в мировом пространстве. В <i>«Крови и вине»</i> он также выводит нормализованный вектор нормали. Я буду рассматривать версию 2015 года, потому что она проще.<br/>
<br/>
Посмотрите на буфер констант, обозначенный как <b>cb2</b>:<br/>
<br/>
<div style="text-align:center;"><img src="https://4.bp.blogspot.com/-29-t0eW2ktI/XI4kGUssDOI/AAAAAAAABWA/YOdBgVjrdPsXA_5LBq5NSuxyU96989PCACLcBGAs/s1600/vs_cbuffer_2.JPG"/></div><br/>
Здесь у нас есть матрица мира (однородное масштабирование на 100 и перенос относительно позиции камеры). Ничего сложного. cb2_v4 и cb2_v5 — это коэффициенты масштаба/отклонения, используемые для преобразования позиций вершин из интервала [0-1] в интервал [-1;1]. Но здесь эти коэффициенты «сжимают» ось Z (направленную вверх).<br/>
<br/>
<div style="text-align:center;"><img src="https://2.bp.blogspot.com/-nrd37spltMs/XI1ryfEGe0I/AAAAAAAABV0/dPa03Clb8jwY6dNj69x6coxckHA8K1fYQCPcBGAYYCw/s1600/skybox_mesh_out_Zsqueezed.JPG"/></div><br/>
В предыдущих частях серии у нас были похожие вершинные шейдеры. Общий алгоритм заключается в передаче texcoords дальше, затем вычисляется <i>Position</i> с учётом коэффициентов масштаба/отклонения, затем вычисляется <i>PositionW</i> в мировом пространстве, потом рассчитывается окончательная позиция пространства отсечения перемножением матриц <i>matWorld</i> и <i>matViewProj</i> -> используется их произведение для умножения на <i>Position</i>, чтобы получить окончательную SV_Position.<br/>
<br/>
Поэтому HLSL этого вершинного шейдера должен быть примерно таким:<br/>
<br/>
<pre><code class="cpp"> struct InputStruct {  
      float3 param0 : POSITION;  
      float2 param1 : TEXCOORD;  
      float3 param2 : NORMAL;  
      float4 param3 : TANGENT;  
 };  
   
 struct OutputStruct {  
      float2 param0 : TEXCOORD0;  
      float3 param1 : TEXCOORD1;  
      float4 param2 : SV_Position;  
 };  
   
 OutputStruct EditedShaderVS(in InputStruct IN)  
 {  
      OutputStruct OUT = (OutputStruct)0;  
        
      // Simple texcoords passing  
      OUT.param0 = IN.param1;  
        
        
      // * Manually construct world and viewProj martices from float4s:  
      row_major matrix matWorld = matrix(cb2_v0, cb2_v1, cb2_v2, float4(0,0,0,1) );  
      matrix matViewProj = matrix(cb1_v0, cb1_v1, cb1_v2, cb1_v3);  
   
      // * Some optional fun with worldMatrix  
      // a) Scale  
      //matWorld._11 = matWorld._22 = matWorld._33 = 0.225f;  
   
      // b) Translate  
      // X Y Z  
      //matWorld._14 = 520.0997;  
      //matWorld._24 = 74.4226;  
      //matWorld._34 = 113.9;  
   
      // Local space - note the scale+bias here!  
      //float3 meshScale = float3(2.0, 2.0, 2.0);  
      //float3 meshBias = float3(-1.0, -1.0, -0.4);  
      float3 meshScale = cb2_v4.xyz;  
      float3 meshBias = cb2_v5.xyz;  
   
      float3 Position = IN.param0 * meshScale + meshBias;  
        
      // World space  
      float4 PositionW = mul(float4(Position, 1.0), transpose(matWorld) );  
      OUT.param1 = PositionW.xyz;  
   
      // Clip space - original approach from The Witcher 3  
      matrix matWorldViewProj = mul(matViewProj, matWorld);  
      OUT.param2 = mul( float4(Position, 1.0), transpose(matWorldViewProj) );  
        
      return OUT;  
 }</code></pre><br/>
Сравнение моего шейдера (слева) и оригинального (справа):<br/>
<br/>
<div style="text-align:center;"><img src="https://1.bp.blogspot.com/-BtypYno8Gb8/XI4kGe5LPxI/AAAAAAAABWQ/oQcHYAohVgoWj61Bm03txhgmf5B0tD_SACEwYBhgL/s1600/vs_comparison.JPG"/></div><br/>
Отличным свойством <a href="https://renderdoc.org/">RenderDoc</a> является то, что он позволяет нам выполнить инъекцию собственного шейдера вместо оригинального, и эти изменения повлияют на конвейер до самого конца кадра. Как видите из кода HLSL, я предоставил несколько вариантов изменения масштаба и преобразования конечной геометрии. Можете поэкспериментировать с ними и получить очень забавные результаты:<br/>
<br/>
<div style="text-align:center;"><img src="https://4.bp.blogspot.com/-WUFYJBXaW18/XI4kGlz1xhI/AAAAAAAABWQ/U0_Ng2YwIOU7pMMR9M6KSDMHfQS33zCcwCEwYBhgL/s1600/tw3_2015_distorted.jpg" data-src="https://4.bp.blogspot.com/-WUFYJBXaW18/XI4kGlz1xhI/AAAAAAAABWQ/U0_Ng2YwIOU7pMMR9M6KSDMHfQS33zCcwCEwYBhgL/s1600/tw3_2015_distorted.jpg" data-blurred="true"/></div><br/>
<h4>Оптимизация вершинного шейдера</h4><br/>
Вы заметили проблему оригинального вершинного шейдера? Повершинное перемножение матрицы на матрицу совершенно избыточно! Я обнаружил это по крайней мере в нескольких вершинных шейдерах (например, в шейдере <a href="https://astralcode.blogspot.com/2019/01/reverse-engineering-rendering-of.html">занавес дождя в отдалении</a>). Мы можем оптимизировать его, сразу же умножив <i>PositionW</i> на <i>matViewProj</i>!<br/>
<br/>
Итак, мы можем заменить такой код на HLSL:<br/>
<br/>
<pre><code class="cpp">      // Clip space - original approach from The Witcher 3  
      matrix matWorldViewProj = mul(matViewProj, matWorld);  
      OUT.param2 = mul( float4(Position, 1.0), transpose(matWorldViewProj) );</code></pre><br/>
следующим:<br/>
<br/>
<pre><code class="cpp">      // Clip space - optimized version  
      OUT.param2 = mul( matViewProj, PositionW );</code></pre><br/>
Оптимизированная версия даёт нам следующий ассемблерный код:<br/>
<br/>
<pre><code class="cpp">    vs_5_0  
    dcl_globalFlags refactoringAllowed  
    dcl_constantbuffer CB1[4], immediateIndexed  
    dcl_constantbuffer CB2[6], immediateIndexed  
    dcl_input v0.xyz  
    dcl_input v1.xy  
    dcl_output o0.xy  
    dcl_output o1.xyz  
    dcl_output_siv o2.xyzw, position  
    dcl_temps 2  
   0: mov o0.xy, v1.xyxx  
   1: mad r0.xyz, v0.xyzx, cb2[4].xyzx, cb2[5].xyzx  
   2: mov r0.w, l(1.000000)  
   3: dp4 r1.x, r0.xyzw, cb2[0].xyzw  
   4: dp4 r1.y, r0.xyzw, cb2[1].xyzw  
   5: dp4 r1.z, r0.xyzw, cb2[2].xyzw  
   6: mov o1.xyz, r1.xyzx  
   7: mov r1.w, l(1.000000)  
   8: dp4 o2.x, cb1[0].xyzw, r1.xyzw  
   9: dp4 o2.y, cb1[1].xyzw, r1.xyzw  
  10: dp4 o2.z, cb1[2].xyzw, r1.xyzw  
  11: dp4 o2.w, cb1[3].xyzw, r1.xyzw  
  12: ret</code></pre><br/>
Как видите, мы уменьшили количество инструкций с 26 до 12 — довольно значительное изменение. Я не знаю, насколько широко распространена эта проблема в игре, но ради бога, CD Projekt Red, может, выпустите патч? :)<br/>
<br/>
И я не шучу. Можете вставить мой оптимизированный шейдер вместо оригинального RenderDoc и вы увидите, что эта оптимизация визуально ни на что не влияет. Честно говоря, я не понимаю, зачем CD Projekt Red решила выполнять повершинное умножение матрицы на матрицу…<br/>
<br/>
<h3>Солнце</h3><br/>
В «Ведьмаке 3» (2015 год) вычисление атмосферного рассеяния и Солнца состоит из двух отдельных вызовов отрисовки:<br/>
<br/>
<div style="text-align:center;"><img src="https://2.bp.blogspot.com/-LYlU8tIn_T4/XI1M7ZkimYI/AAAAAAAABVI/CIcniH-PoLkZ6sO6FRkwGSaP6f2T75D_gCEwYBhgL/s1600/01_tw3_2015_before_sun.jpg" data-src="https://2.bp.blogspot.com/-LYlU8tIn_T4/XI1M7ZkimYI/AAAAAAAABVI/CIcniH-PoLkZ6sO6FRkwGSaP6f2T75D_gCEwYBhgL/s1600/01_tw3_2015_before_sun.jpg" data-blurred="true"/></div><br/>
<i>Witcher 3 (2015) — до</i><br/>
<br/>
<div style="text-align:center;"><img src="https://3.bp.blogspot.com/-Osp-nrn3wqc/XI1M7T7YF0I/AAAAAAAABVE/naXCBqa20WwwADMb2SJn-iri72mueIu9gCEwYBhgL/s1600/02_tw3_2015_after_sky.jpg" data-src="https://3.bp.blogspot.com/-Osp-nrn3wqc/XI1M7T7YF0I/AAAAAAAABVE/naXCBqa20WwwADMb2SJn-iri72mueIu9gCEwYBhgL/s1600/02_tw3_2015_after_sky.jpg" data-blurred="true"/></div><br/>
<i>Witcher 3 (2015) — с небом</i><br/>
<br/>
<div style="text-align:center;"><img src="https://2.bp.blogspot.com/-n3IIQ36moI4/XI1M7MEwDbI/AAAAAAAABVA/_UBKawZqvd0vZrjs2D4Byyi8yeKAt7-nACEwYBhgL/s1600/03_tw3_2015_final.jpg" data-src="https://2.bp.blogspot.com/-n3IIQ36moI4/XI1M7MEwDbI/AAAAAAAABVA/_UBKawZqvd0vZrjs2D4Byyi8yeKAt7-nACEwYBhgL/s1600/03_tw3_2015_final.jpg" data-blurred="true"/></div><br/>
<i>Witcher 3 (2015) — с небом + Солнце</i><br/>
<br/>
Рендеринг Солнца в версии 2015 года очень похож на <a href="https://astralcode.blogspot.com/2018/12/reverse-engineering-rendering-of_22.html">рендеринг Луны</a> с точки зрения геометрии и состояний смешивания/глубин.<br/>
<br/>
С другой стороны, в <i>«Крови и вине»</i> небо с Солнцем рендерятся за один проход:<br/>
<br/>
<div style="text-align:center;"><img src="https://2.bp.blogspot.com/-Bwkb24XajSc/XI1M8KSosvI/AAAAAAAABVM/mMWzW-pHQKk3n9yPVMCQv2g4vOqBE2ldwCEwYBhgL/s1600/04_tw3_2016_before.jpg" data-src="https://2.bp.blogspot.com/-Bwkb24XajSc/XI1M8KSosvI/AAAAAAAABVM/mMWzW-pHQKk3n9yPVMCQv2g4vOqBE2ldwCEwYBhgL/s1600/04_tw3_2016_before.jpg" data-blurred="true"/></div><br/>
<i>Ведьмак 3: Кровь и вино (2016 год) — до неба</i><br/>
<br/>
<div style="text-align:center;"><img src="https://1.bp.blogspot.com/-hf4uFG5dlDU/XI1M8a-ShtI/AAAAAAAABVQ/Vp81FC3nW9wrpxv7Gk8ihzmjzQo9EqChgCEwYBhgL/s1600/05_tw3_2016_after.jpg" data-src="https://1.bp.blogspot.com/-hf4uFG5dlDU/XI1M8a-ShtI/AAAAAAAABVQ/Vp81FC3nW9wrpxv7Gk8ihzmjzQo9EqChgCEwYBhgL/s1600/05_tw3_2016_after.jpg" data-blurred="true"/></div><br/>
<i>Ведьмак 3: Кровь и вино (2016 год) — с небом и Солнцем</i><br/>
<br/>
Как бы вы не рендерили Солнце, на каком-то этапе вам всё равно понадобится (нормализованное) направление солнечного света. Наиболее логичный способ получить этот вектор — использовать <a href="https://en.wikipedia.org/wiki/Spherical_coordinate_system">сферические координаты</a>. По сути, нам нужно всего два значения, обозначающие два угла (в радианах!): <i>фи</i> и <i>тета</i>. Получив их, можно допустить, что <i>r = 1</i>, таким образом сократив его. Тогда для декартовых координат с направленной вверх осью Y можно написать следующий код на HLSL:<br/>
<br/>
<pre><code class="cpp"> float3 vSunDir;  
 vSunDir.x = sin(fTheta)*cos(fPhi);  
 vSunDir.y = sin(fTheta)*sin(fPhi);  
 vSunDir.z = cos(fTheta);  
 vSunDir = normalize(vSunDir);</code></pre><br/>
Обычно направление солнечного света вычисляется в приложении, а затем передаётся в буфер констант для дальнейшего использования.<br/>
<br/>
Получив направление солнечного света, мы можем углубиться в ассемблерный код пиксельного шейдера <i>«Крови и вина»</i>…<br/>
<br/>
<pre><code class="cpp">  ...   
  100: add r1.xyw, -r0.xyxz, cb12[0].xyxz  
  101: dp3 r2.x, r1.xywx, r1.xywx  
  102: rsq r2.x, r2.x  
  103: mul r1.xyw, r1.xyxw, r2.xxxx  
  104: mov_sat r2.xy, cb12[205].yxyy  
  105: dp3 r2.z, -r1.xywx, -r1.xywx  
  106: rsq r2.z, r2.z  
  107: mul r1.xyw, -r1.xyxw, r2.zzzz  
  ...</code></pre><br/>
Итак, во-первых, <i>cb12[0].xyz</i> — это позиция камеры, а в <i>r0.xyz</i> мы храним позицию вершины (это выходные данные из вершинного шейдера). Следовательно, строка 100 вычисляет вектор <i>worldToCamera</i>. Но взгляните на строки 105-107. Мы можем записать их как <i>normalize( -worldToCamera)</i>, то есть мы вычисляем нормализованный вектор <i>cameraToWorld</i>.<br/>
<br/>
<pre><code class="cpp">  120: dp3_sat r1.x, cb12[203].yzwy, r1.xywx</code></pre><br/>
Затем мы вычисляем скалярное произведение векторов <i>cameraToWorld</i> и <i>sunDirection</i>! Помните, что они должны быть нормализованными. Также мы насыщаем это полное выражение, чтобы ограничить его интервалом [0-1].<br/>
<br/>
Отлично! Это скалярное произведение хранится в r1.x. Давайте посмотрим, где оно применяется дальше…<br/>
<br/>
<pre><code class="cpp">  152: log r1.x, r1.x  
  153: mul r1.x, r1.x, cb12[203].x  
  154: exp r1.x, r1.x  
  155: mul r1.x, r2.y, r1.x</code></pre><br/>
Троица «log, mul, exp» — это возведение в степень. Как видите, мы возводим наш косинус (скалярное произведение нормализованных векторов) в какую-то степень. Вы можете спросить зачем. Таким образом мы можем создать градиент, имитирующий Солнце. (И строка 155 влияет на непрозрачность этого градиента, чтобы мы, например, обнулить его, чтобы полностью скрыть Солнце). Вот несколько примеров:<br/>
<br/>
<div style="text-align:center;"><img src="https://3.bp.blogspot.com/-SBtWnWFtGIU/XI4x9eNJdHI/AAAAAAAABWo/9P6tTb3yeq0XGs9mSlKOMdP6HdSJyPaJQCLcBGAs/s1600/gradient_exp_56.jpg" data-src="https://3.bp.blogspot.com/-SBtWnWFtGIU/XI4x9eNJdHI/AAAAAAAABWo/9P6tTb3yeq0XGs9mSlKOMdP6HdSJyPaJQCLcBGAs/s1600/gradient_exp_56.jpg" data-blurred="true"/></div><br/>
<i>exponent = 54</i><br/>
<br/>
<div style="text-align:center;"><img src="https://2.bp.blogspot.com/-wPtE8u4rCvI/XI4x9QWxYVI/AAAAAAAABWk/viArrp8YV7QmrITb2LhPIM-nlUqTXfeDACLcBGAs/s1600/gradient_exp_2400.jpg" data-src="https://2.bp.blogspot.com/-wPtE8u4rCvI/XI4x9QWxYVI/AAAAAAAABWk/viArrp8YV7QmrITb2LhPIM-nlUqTXfeDACLcBGAs/s1600/gradient_exp_2400.jpg" data-blurred="true"/></div><br/>
<i>exponent = 2400</i><br/>
<br/>
Имея этот градиент, мы используем его для выполнения интерполяции между <i>skyColor</i> и <i>sunColor</i>! Чтобы избежать появления артефактов, нужно насытить значение в строке 120.<br/>
<br/>
Стоит заметить, что этот трюк можно использовать для имитации <a href="https://en.wikipedia.org/wiki/Corona_(optical_phenomenon)">венцов</a> Луны (при низких значениях exponent). Для этого нам понадобится вектор <i>moonDirection</i>, который легко можно вычислить с помощью сферических координат.<br/>
<br/>
Готовый код на HLSL может походить на следующий фрагмент:<br/>
<br/>
<pre><code class="cpp"> float3 vCamToWorld = normalize( PosW – CameraPos );  
   
 float cosTheta = saturate( dot(vSunDir, vCamToWorld) );  
 float sunGradient = pow( cosTheta, sunExponent );  
   
 float3 color = lerp( skyColor, sunColor, sunGradient );</code></pre><br/>
<h3>Движение звёзд</h3><br/>
Если сделать таймлапс чистого ночного неба Witcher 3, то можно заметить, что звёзды не статичны — они немного движутся по небу! Я заметил это почти случайно и захотел узнать, как это реализовано.<br/>
<br/>
Давайте начнём с того факта, что звёзды в Witcher 3 представлены как кубическая карта размером 1024x1024x6. Если подумать, то можно понять, что это очень удобное решение, которое позволяет с лёгкостью привязывать направления для сэмплирования кубической карты.<br/>
<br/>
Давайте рассмотрим следующий ассемблерный код:<br/>
<br/>
<pre><code class="cpp">  159: add r1.xyz, -v1.xyzx, cb1[8].xyzx  
  160: dp3 r0.w, r1.xyzx, r1.xyzx  
  161: rsq r0.w, r0.w  
  162: mul r1.xyz, r0.wwww, r1.xyzx  
  163: mul r2.xyz, cb12[204].zwyz, l(0.000000, 0.000000, 1.000000, 0.000000)  
  164: mad r2.xyz, cb12[204].yzwy, l(0.000000, 1.000000, 0.000000, 0.000000), -r2.xyzx  
  165: mul r4.xyz, r2.xyzx, cb12[204].zwyz  
  166: mad r4.xyz, r2.zxyz, cb12[204].wyzw, -r4.xyzx  
  167: dp3 r4.x, r1.xyzx, r4.xyzx  
  168: dp2 r4.y, r1.xyxx, r2.yzyy  
  169: dp3 r4.z, r1.xyzx, cb12[204].yzwy  
  170: dp3 r0.w, r4.xyzx, r4.xyzx  
  171: rsq r0.w, r0.w  
  172: mul r2.xyz, r0.wwww, r4.xyzx  
  173: sample_indexable(texturecube)(float,float,float,float) r4.xyz, r2.xyzx, t0.xyzw, s0</code></pre><br/>
Чтобы вычислить конечный вектор сэмплирования (строка 173), мы начинаем с вычисления нормализованного вектора <i>worldToCamera</i> (строки 159-162).<br/>
<br/>
Затем мы вычисляем два векторных произведения (163-164, 165-166) с <i>moonDirection</i>, а позже рассчитываем три скалярных произведения, чтобы получить конечный вектор сэмплирования. Код на HLSL:<br/>
<br/>
<pre><code class="cpp"> float3 vWorldToCamera = normalize( g_CameraPos.xyz - Input.PositionW.xyz );  
 float3 vMoonDirection = cb12_v204.yzw;  
   
 float3 vStarsSamplingDir = cross( vMoonDirection, float3(0, 0, 1) );  
 float3 vStarsSamplingDir2 = cross( vStarsSamplingDir, vMoonDirection );  
   
 float dirX = dot( vWorldToCamera, vStarsSamplingDir2 );  
 float dirY = dot( vWorldToCamera, vStarsSamplingDir );  
 float dirZ = dot( vWorldToCamera, vMoonDirection);  
 float3 dirXYZ = normalize( float3(dirX, dirY, dirZ) );  
   
 float3 starsColor = texNightStars.Sample( samplerAnisoWrap, dirXYZ ).rgb;</code></pre><br/>
Примечание для себя: это очень хорошо продуманный код, и мне стоит исследовать его подробнее.<br/>
<br/>
Примечание для читателей: если вы знаете больше об этой операции, то расскажите мне!<br/>
<br/>
<h3>Мерцающие звёзды</h3><br/>
Ещё один интересный трюк, который бы я хотел исследовать подробнее — это мерцание звёзд. Например, если вы будете бродить в окрестностях Новиграда при ясной погоде, то заметите, что звёзды мерцают.<br/>
<br/>
Мне было любопытно, как это реализовано. Оказалось, что разница между версией 2015 года и <i>«Кровью и вином»</i> довольно велика. Для простоты я буду рассматривать версию 2015 года.<br/>
<br/>
Итак, мы начинаем сразу после сэмплирования <i>starsColor</i> из предыдущего раздела:<br/>
<br/>
<pre><code class="cpp">  174: mul r0.w, v0.x, l(100.000000)  
  175: round_ni r1.w, r0.w  
  176: mad r2.w, v0.y, l(50.000000), cb0[0].x  
  177: round_ni r4.w, r2.w  
  178: bfrev r4.w, r4.w  
  179: iadd r5.x, r1.w, r4.w  
  180: ishr r5.y, r5.x, l(13)  
  181: xor r5.x, r5.x, r5.y  
  182: imul null, r5.y, r5.x, r5.x  
  183: imad r5.y, r5.y, l(0x0000ec4d), l(0.0000000000000000000000000000000000001)  
  184: imad r5.x, r5.x, r5.y, l(146956042240.000000)  
  185: and r5.x, r5.x, l(0x7fffffff)  
  186: itof r5.x, r5.x  
  187: mad r5.y, v0.x, l(100.000000), l(-1.000000)  
  188: round_ni r5.y, r5.y  
  189: iadd r4.w, r4.w, r5.y  
  190: ishr r5.z, r4.w, l(13)  
  191: xor r4.w, r4.w, r5.z  
  192: imul null, r5.z, r4.w, r4.w  
  193: imad r5.z, r5.z, l(0x0000ec4d), l(0.0000000000000000000000000000000000001)  
  194: imad r4.w, r4.w, r5.z, l(146956042240.000000)  
  195: and r4.w, r4.w, l(0x7fffffff)  
  196: itof r4.w, r4.w  
  197: add r5.z, r2.w, l(-1.000000)  
  198: round_ni r5.z, r5.z  
  199: bfrev r5.z, r5.z  
  200: iadd r1.w, r1.w, r5.z  
  201: ishr r5.w, r1.w, l(13)  
  202: xor r1.w, r1.w, r5.w  
  203: imul null, r5.w, r1.w, r1.w  
  204: imad r5.w, r5.w, l(0x0000ec4d), l(0.0000000000000000000000000000000000001)  
  205: imad r1.w, r1.w, r5.w, l(146956042240.000000)  
  206: and r1.w, r1.w, l(0x7fffffff)  
  207: itof r1.w, r1.w  
  208: mul r1.w, r1.w, l(0.000000001)  
  209: iadd r5.y, r5.z, r5.y  
  210: ishr r5.z, r5.y, l(13)  
  211: xor r5.y, r5.y, r5.z  
  212: imul null, r5.z, r5.y, r5.y  
  213: imad r5.z, r5.z, l(0x0000ec4d), l(0.0000000000000000000000000000000000001)  
  214: imad r5.y, r5.y, r5.z, l(146956042240.000000)  
  215: and r5.y, r5.y, l(0x7fffffff)  
  216: itof r5.y, r5.y  
  217: frc r0.w, r0.w  
  218: add r0.w, -r0.w, l(1.000000)  
  219: mul r5.z, r0.w, r0.w  
  220: mul r0.w, r0.w, r5.z  
  221: mul r5.xz, r5.xxzx, l(0.000000001, 0.000000, 3.000000, 0.000000)  
  222: mad r0.w, r0.w, l(-2.000000), r5.z  
  223: frc r2.w, r2.w  
  224: add r2.w, -r2.w, l(1.000000)  
  225: mul r5.z, r2.w, r2.w  
  226: mul r2.w, r2.w, r5.z  
  227: mul r5.z, r5.z, l(3.000000)  
  228: mad r2.w, r2.w, l(-2.000000), r5.z  
  229: mad r4.w, r4.w, l(0.000000001), -r5.x  
  230: mad r4.w, r0.w, r4.w, r5.x  
  231: mad r5.x, r5.y, l(0.000000001), -r1.w  
  232: mad r0.w, r0.w, r5.x, r1.w  
  233: add r0.w, -r4.w, r0.w  
  234: mad r0.w, r2.w, r0.w, r4.w  
  235: mad r2.xyz, r0.wwww, l(0.000500, 0.000500, 0.000500, 0.000000), r2.xyzx  
  236: sample_indexable(texturecube)(float,float,float,float) r2.xyz, r2.xyzx, t0.xyzw, s0  
  237: log r4.xyz, r4.xyzx  
  238: mul r4.xyz, r4.xyzx, l(2.200000, 2.200000, 2.200000, 0.000000)  
  239: exp r4.xyz, r4.xyzx  
  240: log r2.xyz, r2.xyzx  
  241: mul r2.xyz, r2.xyzx, l(2.200000, 2.200000, 2.200000, 0.000000)  
  242: exp r2.xyz, r2.xyzx  
  243: mul r2.xyz, r2.xyzx, r4.xyzx</code></pre> <br/>
Хм. Давайте взглянем в конец этого достаточно длинного ассемблерного кода.<br/>
<br/>
После сэмплирования <i>starsColor</i> в строке 173 мы вычисляем какое-то значение <i>offset</i>. Это <i>offset</i> используется для искажения первого направления сэмплирования (r2.xyz, строка 235), а затем снова сэмплируем кубическую карту звёзд, выполняем гамма-коррекцию этих двух значений (237-242) и перемножаем их (243).<br/>
<br/>
Просто, не правда ли? Ну, не совсем. Давайте немного подумаем об этом <i>offset</i>. Это значение должно быть разным на протяжении всего skydome — одинаково мерцающие звёзды выглядели бы очень нереалистично.<br/>
<br/>
Чтобы <i>offset</i> было как можно более разнообразным, мы воспользуемся тем, что UV растянуты на skydome (v0.xy) и применим прошедшее время, хранящееся в буфере констант (cb[0].x).<br/>
<br/>
Если вам незнакомы эти пугающие ishr/xor/and, то в части про эффект молний прочитайте об целочисленном шуме.<br/>
<br/>
Как видите, целочисленный шум вызывается здесь четыре раза, но он отличается от того, который используется для молний. Чтобы сделать результаты ещё более случайными, входящее целое число для шума является суммой (<i>iadd</i>) и с ним выполняется инвертирование битов (внутренняя функция <a href="https://docs.microsoft.com/en-us/windows/desktop/direct3dhlsl/reversebits">reversebits</a>; инструкция <a href="https://docs.microsoft.com/en-us/windows/desktop/direct3dhlsl/bfrev---sm5---asm-">bfrev</a>).<br/>
<br/>
Так, а теперь помедленнее. Давайте начнём с самого начала.<br/>
<br/>
У нас есть 4 «итерации» целочисленного шума. Я проанализировал ассемблерный код, вычисления всех 4 итераций выглядят так:<br/>
<br/>
<pre><code class="cpp"> int getInt( float x )
 {
     return asint( floor(x) );
 }
 
 int getReverseInt( float x )
 {
     return reversebits( getInt(x) );
 }

 // * Inputs - UV and elapsed time in seconds  
 float2 starsUV;  
 starsUV.x = 100.0 * Input.TextureUV.x;       
 starsUV.y = 50.0  * Input.TextureUV.y + g_fTime;  
             
 // * Iteration 1  
 int iStars1_A = getReverseInt( starsUV.y );
 int iStars1_B = getInt( starsUV.x );            
   
 float fStarsNoise1 = integerNoise( iStars1_A + iStars1_B );  
             
   
 // * Iteration 2  
 int iStars2_A = getReverseInt( starsUV.y );  
 int iStars2_B = getInt( starsUV.x - 1.0 ); 
   
 float fStarsNoise2 = integerNoise( iStars2_A + iStars2_B );  
        
   
 // * Iteration 3  
 int iStars3_A = getReverseInt( starsUV.y - 1.0 );
 int iStars3_B = getInt( starsUV.x );
   
 float fStarsNoise3 = integerNoise( iStars3_A + iStars3_B );  
             
   
 // * Iteration 4  
 int iStars4_A = getReverseInt( starsUV.y - 1.0 ); 
 int iStars4_B = getInt( starsUV.x - 1.0 ); 
   
 float fStarsNoise4 = integerNoise( iStars4_A + iStars4_B );</code></pre><br/>
Конечные выходные данные всех 4 итераций (чтобы найти их, проследите за инструкциями <i>itof</i>):<br/>
<br/>
Итерация 1 — r5.x,<br/>
<br/>
Итерация 2 — r4.w,<br/>
<br/>
Итерация 3 — r1.w,<br/>
<br/>
Итерация 4 — r5.y<br/>
<br/>
После последней <i>itof</i> (строка 216) мы имеем:<br/>
<br/>
<pre><code class="cpp">  217: frc r0.w, r0.w   
  218: add r0.w, -r0.w, l(1.000000)   
  219: mul r5.z, r0.w, r0.w   
  220: mul r0.w, r0.w, r5.z   
  221: mul r5.xz, r5.xxzx, l(0.000000001, 0.000000, 3.000000, 0.000000)   
  222: mad r0.w, r0.w, l(-2.000000), r5.z   
  223: frc r2.w, r2.w   
  224: add r2.w, -r2.w, l(1.000000)   
  225: mul r5.z, r2.w, r2.w   
  226: mul r2.w, r2.w, r5.z   
  227: mul r5.z, r5.z, l(3.000000)   
  228: mad r2.w, r2.w, l(-2.000000), r5.z</code></pre><br/>
Эти строки вычисляют значения S-образной кривой для весов на основании дробной части UV, как и в случае с молниями. Итак:<br/>
<br/>
<pre><code class="cpp">  float s_curve( float x )   
  {   
    float x2 = x * x;   
    float x3 = x2 * x;   
      
    // -2x^3 + 3x^2   
    return -2.0*x3 + 3.0*x2;   
  }  
   
 ...  
 
 // lines 217-222
 float weightX = 1.0 - frac( starsUV.x );  
 weightX = s_curve( weightX );  
   
 // lines 223-228
 float weightY = 1.0 - frac( starsUV.y );  
 weightY = s_curve( weightY );</code></pre><br/>
Как и можно ожидать, эти коэффициенты используются для плавной интерполяции шума и генерации окончательного смещения для координат сэмплирования:<br/>
<br/>
<pre><code class="cpp">  229: mad r4.w, r4.w, l(0.000000001), -r5.x   
  230: mad r4.w, r0.w, r4.w, r5.x   
  float noise0 = lerp( fStarsNoise1, fStarsNoise2, weightX );  
   
  231: mad r5.x, r5.y, l(0.000000001), -r1.w   
  232: mad r0.w, r0.w, r5.x, r1.w   
  float noise1 = lerp( fStarsNoise3, fStarsNoise4, weightX );  
   
  233: add r0.w, -r4.w, r0.w   
  234: mad r0.w, r2.w, r0.w, r4.w   
  float offset = lerp( noise0, noise1, weightY );            
   
  235: mad r2.xyz, r0.wwww, l(0.000500, 0.000500, 0.000500, 0.000000), r2.xyzx   
  236: sample_indexable(texturecube)(float,float,float,float) r2.xyz, r2.xyzx, t0.xyzw, s0   
  float3 starsPerturbedDir = dirXYZ + offset * 0.0005;  
    
  float3 starsColorDisturbed = texNightStars.Sample( samplerAnisoWrap, starsPerturbedDir ).rgb;</code></pre><br/>
Вот небольшая визуализация вычисленного <i>offset</i>:<br/>
<br/>
<div class="oembed"><div><div style="left: 0; width: 100%; height: 0; position: relative; padding-bottom: 56.2493%;"><div class="tm-iframe_temp" data-src="https://www.youtube.com/embed/SAI-cLJFpfg?rel=0&amp;showinfo=1&amp;hl=en-US" data-style="border: 0; top: 0; left: 0; width: 100%; height: 100%; position: absolute;" id="" width=""></div></div></div></div><br/>
После вычисления <i>starsColorDisturbed</i> самая сложная часть завершена. Ура!<br/>
<br/>
Следующий этап — выполнение гамма-коррекции и для <i>starsColor</i>, и для <i>starsColorDisturbed</i>, после чего они перемножаются:<br/>
<br/>
<pre><code class="cpp">  starsColor = pow( starsColor, 2.2 );  
  starsColorDisturbed = pow( starsColorDisturbed, 2.2 );  
   
  float3 starsFinal = starsColor * starsColorDisturbed;</code></pre> <br/>
<h4>Звёзды — финальные штрихи</h4><br/>
У нас есть <i>starsFinal </i>in r1.xyz. В конце обработки звёзд происходит следующее:<br/>
<br/>
<pre><code class="cpp">  256: log r1.xyz, r1.xyzx  
  257: mul r1.xyz, r1.xyzx, l(2.500000, 2.500000, 2.500000, 0.000000)  
  258: exp r1.xyz, r1.xyzx  
  259: min r1.xyz, r1.xyzx, l(1.000000, 1.000000, 1.000000, 0.000000)  
  260: add r0.w, -cb0[9].w, l(1.000000)  
  261: mul r1.xyz, r0.wwww, r1.xyzx  
  262: mul r1.xyz, r1.xyzx, l(10.000000, 10.000000, 10.000000, 0.000000)</code></pre><br/>
Это гораздо проще по сравнению с мерцающими и движущимися звёздами.<br/>
<br/>
Итак, мы начинаем с возведения <i>starsFinal</i> в степень 2.5 — это позволяет нам контролировать плотность звёзд. Довольно умно. Затем мы делаем так, чтобы максимальный цвет звёзд был равен float3(1, 1, 1).<br/>
<br/>
cb0[9].w используется для управления общей видимостью звёзд. Поэтому можно ожидать, что в дневное время это значение равно 1.0 (что даёт умножение на ноль), а ночью — 0.0.<br/>
<br/>
В конце мы увеличиваем видимость звёзд на 10. И на этом всё!<br/>
<br/>
<h2>Часть 3. Ведьмачье чутьё (объекты и карта яркости)</h2><br/>
Почти все описанные ранее эффекты и техники на самом деле не были связаны с Witcher 3. Такие вещи, как тональная коррекция, виньетирование или вычисление средней яркости присутствуют практически в каждой современной игре. Даже эффект опьянения распространён довольно широко.<br/>
<br/>
Именно поэтому я решил внимательнее присмотреться к механикам рендеринга «ведьмачьего чутья». Геральт — ведьмак, а потому его чувства гораздо острее, чем у обычного человека. Следовательно, он может видеть и слышать больше, чем другие люди, что сильно помогает ему в расследованиях. Механика ведьмачьего чутья позволяет игроку визуализировать такие следы.<br/>
<br/>
Вот демонстрация эффекта:<br/>
<br/>
<div class="oembed"><div><div style="left: 0; width: 100%; height: 0; position: relative; padding-bottom: 56.2493%;"><div class="tm-iframe_temp" data-src="https://www.youtube.com/embed/794z0wbcI6U?rel=0&amp;showinfo=1&amp;hl=en-US" data-style="border: 0; top: 0; left: 0; width: 100%; height: 100%; position: absolute;" id="" width=""></div></div></div></div><br/>
И ещё одна, с освещением получше:<br/>
<br/>
<div class="oembed"><div><div style="left: 0; width: 100%; height: 0; position: relative; padding-bottom: 56.2493%;"><div class="tm-iframe_temp" data-src="https://www.youtube.com/embed/ReB6IrOb3ic?rel=0&amp;showinfo=1&amp;hl=en-US" data-style="border: 0; top: 0; left: 0; width: 100%; height: 100%; position: absolute;" id="" width=""></div></div></div></div><br/>
Как видите, есть два типа объектов: те, с которыми Геральт может взаимодействовать (жёлтый контур) и следы, связанные с расследованием (красный контур). После того, как Геральт исследует красный след, он может превратиться в жёлтый (первое видео). Заметьте, что весь экран становится серее и добавляется эффект «рыбьего глаза (второе видео).<br/>
<br/>
Этот эффект довольно сложен, поэтому я решил разделить его исследование на три части.<br/>
<br/>
В первой я расскажу о выборе объектов, во второй — о генерации контура, а в третьей — о финальном объединении всего этого в одно целое.<br/>
<br/>
<h3>Выбор объектов</h3><br/>
Как я и говорил, существует два типа объектов, и нам нужно их различать. В Witcher 3 это реализовано с помощью стенсил-буфера. При генерации мешей GBuffer, которые должны быть помечены как „следы“ (красные), они рендерятся со stencil = 8. Меши, помеченные жёлтым цветом как „интересные“ объекты, рендерятся со stencil = 4.<br/>
<br/>
Например, следующие две текстуры показывают пример кадра с видимым ведьмачьим чутьём и соответствующий стенсил-буфер:<br/>
<br/>
<div style="text-align:center;"><img src="https://1.bp.blogspot.com/-oQKKd9lbcLQ/XKihDzw4ZuI/AAAAAAAABbo/eL4YOcpG3cEHsOLYBg-Gg-XqoO-bUq_VACPcBGAYYCw/s1600/before.jpg" data-src="https://1.bp.blogspot.com/-oQKKd9lbcLQ/XKihDzw4ZuI/AAAAAAAABbo/eL4YOcpG3cEHsOLYBg-Gg-XqoO-bUq_VACPcBGAYYCw/s1600/before.jpg" data-blurred="true"/></div><br/>
<div style="text-align:center;"><img src="https://3.bp.blogspot.com/-AOosFwY75Ro/XKYJB5udsvI/AAAAAAAABYM/o4gon6rPw8wWawHMC0-VLYqzOMeN8MGfgCLcBGAs/s1600/02_stencil.jpg" data-src="https://3.bp.blogspot.com/-AOosFwY75Ro/XKYJB5udsvI/AAAAAAAABYM/o4gon6rPw8wWawHMC0-VLYqzOMeN8MGfgCLcBGAs/s1600/02_stencil.jpg" data-blurred="true"/></div><br/>
<h4>Вкратце о стенсил-буфере</h4><br/>
Стенсил-буфер довольно часто используется в играх для пометки мешей. Определённым категориям мешей назначается одинаковый ID.<br/>
<br/>
Идея заключается в том, чтобы использовать функцию <i>Always</i> с оператором <i>Replace</i>, если стенсил-тест оказался успешным, и с оператором <i>Keep</i> во всех остальных случаях.<br/>
<br/>
Вот как это реализуется с помощью D3D11:<br/>
<br/>
<pre><code class="cpp"> D3D11_DEPTH_STENCIL_DESC depthstencilState;  
 // Set depth parameters....  
   
 // Enable stencil  
 depthstencilState.StencilEnable = TRUE;  
   
 // Read &amp; write all bits  
 depthstencilState.StencilReadMask = 0xFF;  
 depthstencilState.StencilWriteMask = 0xFF;  
   
 // Stencil operator for front face  
 depthstencilState.FrontFace.StencilFunc = D3D11_COMPARISON_ALWAYS;  
 depthstencilState.FrontFace.StencilDepthFailOp = D3D11_STENCIL_OP_KEEP;  
 depthstencilState.FrontFace.StencilFailOp = D3D11_STENCIL_OP_KEEP;  
 depthstencilState.FrontFace.StencilPassOp = D3D11_STENCIL_OP_REPLACE;  
   
 // Stencil operator for back face.  
 depthstencilState.BackFace.StencilFunc = D3D11_COMPARISON_ALWAYS;  
 depthstencilState.BackFace.StencilDepthFailOp = D3D11_STENCIL_OP_KEEP;  
 depthstencilState.BackFace.StencilFailOp = D3D11_STENCIL_OP_KEEP;  
 depthstencilState.BackFace.StencilPassOp = D3D11_STENCIL_OP_REPLACE;  
   
 pDevice->CreateDepthStencilState( &amp;depthstencilState, &amp;m_pDS_AssignValue );</code></pre><br/>
Значение стенсила, которое нужно записать в буфер, передаётся как <i>StencilRef</i> в вызове API:<br/>
<br/>
<pre><code class="cpp"> // from now on set stencil buffer values to 8  
 pDevCon->OMSetDepthStencilState( m_pDS_AssignValue, 8 );  
 ...  
 pDevCon->DrawIndexed( ... );</code></pre><br/>
<h4>Яркость рендеринга</h4><br/>
В этом проходе с точки зрения реализации есть одна полноэкранная текстура в формате R11G11B10_FLOAT, в которую интересные объекты и следы сохраняются в каналы R и G.<br/>
<br/>
Зачем это нужно нам с точки зрения яркости? Оказывается, что чутьё Геральта имеет ограниченный радиус, поэтому объекты получают контуры, только когда игрок находится достаточно близко к ним.<br/>
<br/>
Посмотрите на этот аспект в действии:<br/>
<br/>
<div class="oembed"><div><div style="left: 0; width: 100%; height: 0; position: relative; padding-bottom: 56.2493%;"><div class="tm-iframe_temp" data-src="https://www.youtube.com/embed/Xbs-ZRJ7v1w?rel=0&amp;showinfo=1&amp;hl=en-US" data-style="border: 0; top: 0; left: 0; width: 100%; height: 100%; position: absolute;" id="" width=""></div></div></div></div><br/>
<div style="text-align:center;"><img src="https://4.bp.blogspot.com/-yUB1rKs9M40/XKYJCPmhZ1I/AAAAAAAABYU/PyxObK2KCsoV7DkIfWk_w1HaJHydhGFIQCEwYBhgL/s1600/01_tex.jpg" data-src="https://4.bp.blogspot.com/-yUB1rKs9M40/XKYJCPmhZ1I/AAAAAAAABYU/PyxObK2KCsoV7DkIfWk_w1HaJHydhGFIQCEwYBhgL/s1600/01_tex.jpg" data-blurred="true"/></div><br/>
Мы начинаем с очистки текстуры яркости, заливая её чёрным цветом.<br/>
<br/>
Затем выполняются два полноэкранных вызова отрисовки: первый для „следова“, второй — для интересных объектов:<br/>
<br/>
<div style="text-align:center;"><img src="https://1.bp.blogspot.com/-6loAAWznr9M/XKYfSvZPYEI/AAAAAAAABYk/P7W-zj7mUCkZee1DF02fzpoqgPWfaSgNQCLcBGAs/s1600/03_calss.JPG"/></div><br/>
Первый вызов отрисовки выполняется для следов — зелёный канал:<br/>
<br/>
<div style="text-align:center;"><img src="https://4.bp.blogspot.com/-9Es1Q69_1SM/XKYfSqAV5_I/AAAAAAAABYg/ZO9WpSCerzoDPRD50VOthnPw_5vd7eATgCEwYBhgL/s1600/04_traces1.jpg" data-src="https://4.bp.blogspot.com/-9Es1Q69_1SM/XKYfSqAV5_I/AAAAAAAABYg/ZO9WpSCerzoDPRD50VOthnPw_5vd7eATgCEwYBhgL/s1600/04_traces1.jpg" data-blurred="true"/></div><br/>
Второй вызов выполняется для интересных объектов — красный канал:<br/>
<br/>
<div style="text-align:center;"><img src="https://1.bp.blogspot.com/-CTI51-PHhs4/XKYfS1Bpg_I/AAAAAAAABY8/0ePZBCxKi7YULIPu1l4T-uXopU2bzwI6wCEwYBhgL/s1600/05_interesting.jpg" data-src="https://1.bp.blogspot.com/-CTI51-PHhs4/XKYfS1Bpg_I/AAAAAAAABY8/0ePZBCxKi7YULIPu1l4T-uXopU2bzwI6wCEwYBhgL/s1600/05_interesting.jpg" data-blurred="true"/></div><br/>
Ну ладно, но как нам определить, какие пиксели нужно учитывать? Придётся воспользоваться стенсил-буфером!<br/>
<br/>
При каждом из этих вызовов выполняется стенсил-тест, и принимаются только те пиксели, которые были ранее помечены как „8“ (первый вызов отрисовки) или „4“.<br/>
<br/>
Визуализация стенсил-теста для следов:<br/>
<br/>
<div style="text-align:center;"><img src="https://3.bp.blogspot.com/-Of3CW0wayus/XKYfSX76AOI/AAAAAAAABY0/_ZKvXiHQdj0Gf9bf4BSvznwKG0ZrwxK8gCEwYBhgL/s1600/04_traces1_stenciltest.JPG"/></div><br/>
… и для интересных объектов:<br/>
<br/>
<div style="text-align:center;"><img src="https://4.bp.blogspot.com/-2N_SzHITO5M/XKYfTLF3E-I/AAAAAAAABZA/nA6s23G3JGQrz3wY_Rf9DKO8BsMpMUs9wCEwYBhgL/s1600/06_interesting_stencil.JPG"/></div><br/>
Как в этом случае выполняется тест? Об основах стенсил-тестирования можно узнать в хорошем <a href="http://www.asawicki.info/news_1654_stencil_test_explained_using_code.html">посте</a>. В общем виде формула стенсил-теста имеет следующий вид:<br/>
<br/>
<pre><code class="cpp"> if (StencilRef &amp; StencilReadMask OP StencilValue &amp; StencilReadMask)  
   accept pixel  
 else  
   discard pixel</code></pre><br/>
где:<br/>
<i>StencilRef</i> — значение, передаваемое вызовом API,<br/>
<br/>
<i>StencilReadMask</i> — маска, используемая для чтения значения стенсила (учтите, что она присутствует и на левой, и на правой части),<br/>
<br/>
<i>OP</i> — оператор сравнения, задаётся через API,<br/>
<br/>
<i>StencilValue</i> — значение стенсил-буфера в текущем обрабатываемом пикселе.<br/>
<br/>
Важно понимать, что для вычисления операндов мы используем двоичные AND.<br/>
<br/>
Познакомившись с основами, давайте посмотрим, как эти параметры используются в данных вызовах отрисовки:<br/>
<br/>
<div style="text-align:center;"><img src="https://2.bp.blogspot.com/-IKI0ksekBRQ/XKYjUwlcuRI/AAAAAAAABZM/yH9sPWaoNwUoXSXRwCurljKCi4UAwCcMgCLcBGAs/s1600/08_settings_traces.JPG"/></div><br/>
<i>Состояние стенсила для следов</i><br/>
<br/>
<div style="text-align:center;"><img src="https://4.bp.blogspot.com/-vs_30dlApMc/XKYjU3fQtNI/AAAAAAAABZI/ML-CG4E-L2kdr2FlPvhGrg7gu125bscFwCLcBGAs/s1600/09_settings_interesting.JPG"/></div><br/>
<i>Состояние стенсила для интересных объектов</i><br/>
<br/>
Ха! Как мы видим, единственное отличие заключается в ReadMask. Давайте проверим это! Подставим эти значения в уравнение стенсил-теста:<br/>
<br/>
<pre><code class="cpp"> Let StencilReadMask = 0x08 and StencilRef = 0:  
   
 For a pixel with stencil = 8:  
 0 &amp; 0x08 &lt; 8 &amp; 0x08  
 0 &lt; 8
 TRUE  
   
 For a pixel with stencil = 4:  
 0 &amp; 0x08 &lt; 4 &amp; 0x08  
 0 &lt; 0  
 FALSE</code></pre><br/>
Умно. Как видите, в этом случае мы сравниваем не значение стенсила, а проверяем задан ли определённый бит стенсил-буфера. Каждый пиксель стенсил-буфера имеет формат uint8, поэтому интервал значений составляет [0-255].<br/>
<br/>
Примечание: все вызовы <i>DrawIndexed(36)</i> связаны с рендерингом отпечатков ног как следов, поэтому в этом конкретном кадре карта яркости имеет следующий окончательный вид:<br/>
<br/>
<div style="text-align:center;"><img src="https://3.bp.blogspot.com/-BDtw1sdtDJU/XKYfTAGCenI/AAAAAAAABY4/mLUu8NxQ-MUtxB71zgYEKtb9yTsWiKNkgCEwYBhgL/s1600/07_final.jpg" data-src="https://3.bp.blogspot.com/-BDtw1sdtDJU/XKYfTAGCenI/AAAAAAAABY4/mLUu8NxQ-MUtxB71zgYEKtb9yTsWiKNkgCEwYBhgL/s1600/07_final.jpg" data-blurred="true"/></div><br/>
Но перед стенсил-тестом есть пиксельный шейдер. И 28738, и 28748 используют одинаковый пиксельный шейдер:<br/>
<br/>
<pre><code class="cpp"> ps_5_0  
    dcl_globalFlags refactoringAllowed  
    dcl_constantbuffer cb0[2], immediateIndexed  
    dcl_constantbuffer cb3[8], immediateIndexed  
    dcl_constantbuffer cb12[214], immediateIndexed  
    dcl_sampler s15, mode_default  
    dcl_resource_texture2d (float,float,float,float) t15  
    dcl_input_ps_siv v0.xy, position  
    dcl_output o0.xyzw  
    dcl_output o1.xyzw  
    dcl_output o2.xyzw  
    dcl_output o3.xyzw  
    dcl_temps 2  
   0: mul r0.xy, v0.xyxx, cb0[1].zwzz  
   1: sample_indexable(texture2d)(float,float,float,float) r0.x, r0.xyxx, t15.xyzw, s15  
   2: mul r1.xyzw, v0.yyyy, cb12[211].xyzw  
   3: mad r1.xyzw, cb12[210].xyzw, v0.xxxx, r1.xyzw  
   4: mad r0.xyzw, cb12[212].xyzw, r0.xxxx, r1.xyzw  
   5: add r0.xyzw, r0.xyzw, cb12[213].xyzw  
   6: div r0.xyz, r0.xyzx, r0.wwww  
   7: add r0.xyz, r0.xyzx, -cb3[7].xyzx  
   8: dp3 r0.x, r0.xyzx, r0.xyzx  
   9: sqrt r0.x, r0.x  
  10: mul r0.y, r0.x, l(0.120000)  
  11: log r1.x, abs(cb3[6].y)  
  12: mul r1.xy, r1.xxxx, l(2.800000, 0.800000, 0.000000, 0.000000)  
  13: exp r1.xy, r1.xyxx  
  14: mad r0.zw, r1.xxxy, l(0.000000, 0.000000, 120.000000, 120.000000), l(0.000000, 0.000000, 1.000000, 1.000000)  
  15: lt r1.x, l(0.030000), cb3[6].y  
  16: movc r0.xy, r1.xxxx, r0.yzyy, r0.xwxx  
  17: div r0.x, r0.x, r0.y  
  18: log r0.x, r0.x  
  19: mul r0.x, r0.x, l(1.600000)  
  20: exp r0.x, r0.x  
  21: add r0.x, -r0.x, l(1.000000)  
  22: max r0.x, r0.x, l(0)  
  23: mul o0.xyz, r0.xxxx, cb3[0].xyzx  
  24: mov o0.w, cb3[0].w  
  25: mov o1.xyzw, cb3[1].xyzw  
  26: mov o2.xyzw, cb3[2].xyzw  
  27: mov o3.xyzw, cb3[3].xyzw  
  28: ret</code></pre><br/>
Этот пиксельный шейдер выполняет запись только в один render target, поэтому строки 24-27 избыточны.<br/>
<br/>
Первое, что здесь происходит — сэмплирование глубины (точечным сэмплером с ограничением значений), строка 1. Это значение используется для воссоздания позиции в мире умножением на специальную матрицу с последующим перспективным делением (строки 2-6).<br/>
<br/>
Взяв позицию Геральта (cb3[7].xyz — учтите, что это <i>не</i> позиция камеры!), мы вычисляем расстояние от Геральта до этой конкретной точки (строки 7-9).<br/>
<br/>
В этом шейдере важны следующие входные данные:<br/>
<br/>
 — cb3[0].rgb — цвет вывода. Он может иметь формат float3(0, 1, 0) (следы) или float3(1, 0, 0) (интересные объекты),<br/>
 — cb3[6].y — коэффициент масштабирования расстояния. Непосредственно влияет на радиус и яркость финальных выходных данных.<br/>
<br/>
Позже у нас идут довольно хитрые формулы для вычисления яркости в зависимости от расстояния между Геральтом и объектом. Могу предположить, что все коэффициенты подобраны экспериментально.<br/>
<br/>
Финальными выходными данными являются <i>color</i>*<i>intensity</i>.<br/>
<br/>
Код на HLSL будет выглядеть примерно так:<br/>
<br/>
<pre><code class="cpp"> struct FSInput  
 {  
      float4 param0 : SV_Position;  
 };  
   
 struct FSOutput  
 {  
      float4 param0 : SV_Target0;  
      float4 param1 : SV_Target1;  
      float4 param2 : SV_Target2;  
      float4 param3 : SV_Target3;  
 };  
   
 float3 getWorldPos( float2 screenPos, float depth )  
 {  
   float4 worldPos = float4(screenPos, depth, 1.0);  
   worldPos = mul( worldPos, screenToWorld );  
     
   return worldPos.xyz / worldPos.w;  
 }  
   
 FSOutput EditedShaderPS(in FSInput IN)  
 {  
   // * Inputs    
   // Directly affects radius of the effect  
   float distanceScaling = cb3_v6.y;  
     
   // Color of output at the end  
   float3 color = cb3_v0.rgb;  
        

   // Sample depth  
   float2 uv = IN.param0.xy * cb0_v1.zw;  
   float depth = texture15.Sample( sampler15, uv ).x;  
     
   // Reconstruct world position  
   float3 worldPos = getWorldPos( IN.param0.xy, depth );  
   
   // Calculate distance from Geralt to world position of particular object  
   float dist_geraltToWorld = length( worldPos - cb3_v7.xyz );  
     
   // Calculate two squeezing params  
   float t0 = 1.0 + 120*pow( abs(distanceScaling), 2.8 );  
   float t1 = 1.0 + 120*pow( abs(distanceScaling), 0.8 );  
     
   // Determine nominator and denominator  
   float2 params;  
   params = (distanceScaling > 0.03) ? float2(dist_geraltToWorld * 0.12, t0) : float2(dist_geraltToWorld, t1);  
     
   // Distance Geralt &lt;-> Object  
   float nominator = params.x;   
     
   // Hiding factor  
   float denominator = params.y;  
     
   // Raise to power of 1.6  
   float param = pow( params.x / params.y, 1.6 );  
     
   // Calculate final intensity  
   float intensity = max(0.0, 1.0 - param );   
     
     
   // * Final outputs.  
   // *  
   // * This PS outputs only one color, the rest  
   // * is redundant. I just added this to keep 1-1 ratio with  
   // * original assembly.  
   FSOutput OUT = (FSOutput)0;  
   OUT.param0.xyz = color * intensity;  
     
   // == redundant ==  
   OUT.param0.w = cb3_v0.w;  
   OUT.param1 = cb3_v1;  
   OUT.param2 = cb3_v2;  
   OUT.param3 = cb3_v3;  
   // ===============  
   
   return OUT;  
 }</code></pre> <br/>
Небольшое сравнение оригинального (слева) и моего (справа) ассемблерного кода шейдера.<br/>
<br/>
<div style="text-align:center;"><img src="https://3.bp.blogspot.com/-ZC1xPT4vpYU/XKaEOeOLXYI/AAAAAAAABZc/boAqQidXEv0ee4O5alCSpLIoNI52v_qWwCLcBGAs/s1600/10_comparison.JPG"/></div><br/>
Это был первый этап эффекта <i>ведьмачьего чутья</i>. На самом деле, он самый простой.<br/>
<br/>
<h2>Часть 4. Ведьмачье чутьё (карта контуров)</h2><br/>
Ещё раз взглянем на исследуемую нами сцену:<br/>
<br/>
<div style="text-align:center;"><img src="https://1.bp.blogspot.com/-oQKKd9lbcLQ/XKihDzw4ZuI/AAAAAAAABbo/eL4YOcpG3cEHsOLYBg-Gg-XqoO-bUq_VACPcBGAYYCw/s1600/before.jpg" data-src="https://1.bp.blogspot.com/-oQKKd9lbcLQ/XKihDzw4ZuI/AAAAAAAABbo/eL4YOcpG3cEHsOLYBg-Gg-XqoO-bUq_VACPcBGAYYCw/s1600/before.jpg" data-blurred="true"/></div><br/>
В первой части разбора эффекта ведьмачьего чутья я показал, как генерируется „карта яркости“.<br/>
<br/>
У нас есть одна полноэкранная текстура формата R11G11B10_FLOAT, которая может выглядеть вот так:<br/>
<br/>
<div style="text-align:center;"><img src="https://3.bp.blogspot.com/-BDtw1sdtDJU/XKYfTAGCenI/AAAAAAAABY4/in1Mfyn1cz0JnmtQ2dfrtoh0z_l3DPiQACPcBGAYYCw/s1600/07_final.jpg" data-src="https://3.bp.blogspot.com/-BDtw1sdtDJU/XKYfTAGCenI/AAAAAAAABY4/in1Mfyn1cz0JnmtQ2dfrtoh0z_l3DPiQACPcBGAYYCw/s1600/07_final.jpg" data-blurred="true"/></div><br/>
Зелёный канал обозначает „следы“, красный — интересные объекты, с которыми может взаимодействовать Геральт.<br/>
<br/>
Получив эту текстуру, мы можем переходить к следующему этапу — я назвал его „карта контуров“.<br/>
<br/>
<div style="text-align:center;"><img src="https://4.bp.blogspot.com/--Ad03VW1EUI/XKccbbi4d4I/AAAAAAAABZo/G3YbdjI7b-UbL-AslYxbPUKd_w1FSdI1ACLcBGAs/s1600/01_outline.jpg" data-src="https://4.bp.blogspot.com/--Ad03VW1EUI/XKccbbi4d4I/AAAAAAAABZo/G3YbdjI7b-UbL-AslYxbPUKd_w1FSdI1ACLcBGAs/s1600/01_outline.jpg" data-blurred="true"/></div><br/>
Это немного странная текстура формата 512x512 R16G16_FLOAT. Здесь важно то, что она реализована в стиле „пинг-понг“. Карта контуров из предыдущего кадра является входящими данными (наряду с картой яркости) для генерации новой карты контуров в текущем кадре.<br/>
<br/>
Буферы „пинг-понга“ можно реализовать множеством способов, но лично мне больше всего нравится следующий (псевдокод):<br/>
<br/>
<pre><code class="cpp"> // Declarations  
 Texture2D m_texOutlineMap[2];  
 uint m_outlineIndex = 0;  
   
 // Rendering  
 void Render()  
 {  
   pDevCon->SetInputTexture( m_texOutlineMap[m_outlineIndex] );  
   pDevCon->SetOutputTexture( m_texOutlineMap[!m_outlineIndex] );  
   ...  
   pDevCon->Draw(...);  
   
   // after draw  
   m_outlineIndex = !m_outlineIndex;  
 }</code></pre><br/>
Такой подход, при котором на входе всегда <i>[m_outlineIndex]</i>, а на выходе всегда <i>[!m_outlineIndex]</i>, обеспечивает гибкость в отношении использования дальнейших постэффектов.<br/>
<br/>
Давайте взглянем на пиксельный шейдер:<br/>
<br/>
<pre><code class="cpp"> ps_5_0  
    dcl_globalFlags refactoringAllowed  
    dcl_constantbuffer cb3[1], immediateIndexed  
    dcl_sampler s0, mode_default  
    dcl_sampler s1, mode_default  
    dcl_resource_texture2d (float,float,float,float) t0  
    dcl_resource_texture2d (float,float,float,float) t1  
    dcl_input_ps linear v2.xy  
    dcl_output o0.xyzw  
    dcl_temps 4  
   0: add r0.xyzw, v2.xyxy, v2.xyxy  
   1: round_ni r1.xy, r0.zwzz  
   2: frc r0.xyzw, r0.xyzw  
   3: add r1.zw, r1.xxxy, l(0.000000, 0.000000, -1.000000, -1.000000)  
   4: dp2 r1.z, r1.zwzz, r1.zwzz  
   5: add r1.z, -r1.z, l(1.000000)  
   6: max r2.w, r1.z, l(0)  
   7: dp2 r1.z, r1.xyxx, r1.xyxx  
   8: add r3.xyzw, r1.xyxy, l(-1.000000, -0.000000, -0.000000, -1.000000)  
   9: add r1.x, -r1.z, l(1.000000)  
  10: max r2.x, r1.x, l(0)  
  11: dp2 r1.x, r3.xyxx, r3.xyxx  
  12: dp2 r1.y, r3.zwzz, r3.zwzz  
  13: add r1.xy, -r1.xyxx, l(1.000000, 1.000000, 0.000000, 0.000000)  
  14: max r2.yz, r1.xxyx, l(0, 0, 0, 0)  
  15: sample_indexable(texture2d)(float,float,float,float) r1.xyzw, r0.zwzz, t1.xyzw, s1  
  16: dp4 r1.x, r1.xyzw, r2.xyzw  
  17: add r2.xyzw, r0.zwzw, l(0.003906, 0.000000, -0.003906, 0.000000)  
  18: add r0.xyzw, r0.xyzw, l(0.000000, 0.003906, 0.000000, -0.003906)  
  19: sample_indexable(texture2d)(float,float,float,float) r1.yz, r2.xyxx, t1.zxyw, s1  
  20: sample_indexable(texture2d)(float,float,float,float) r2.xy, r2.zwzz, t1.xyzw, s1  
  21: add r1.yz, r1.yyzy, -r2.xxyx  
  22: sample_indexable(texture2d)(float,float,float,float) r0.xy, r0.xyxx, t1.xyzw, s1  
  23: sample_indexable(texture2d)(float,float,float,float) r0.zw, r0.zwzz, t1.zwxy, s1  
  24: add r0.xy, -r0.zwzz, r0.xyxx  
  25: max r0.xy, abs(r0.xyxx), abs(r1.yzyy)  
  26: min r0.xy, r0.xyxx, l(1.000000, 1.000000, 0.000000, 0.000000)  
  27: mul r0.xy, r0.xyxx, r1.xxxx  
  28: sample_indexable(texture2d)(float,float,float,float) r0.zw, v2.xyxx, t0.zwxy, s0  
  29: mad r0.w, r1.x, l(0.150000), r0.w  
  30: mad r0.x, r0.x, l(0.350000), r0.w  
  31: mad r0.x, r0.y, l(0.350000), r0.x  
  32: mul r0.yw, cb3[0].zzzw, l(0.000000, 300.000000, 0.000000, 300.000000)  
  33: mad r0.yw, v2.xxxy, l(0.000000, 150.000000, 0.000000, 150.000000), r0.yyyw  
  34: ftoi r0.yw, r0.yyyw  
  35: bfrev r0.w, r0.w  
  36: iadd r0.y, r0.w, r0.y  
  37: ishr r0.w, r0.y, l(13)  
  38: xor r0.y, r0.y, r0.w  
  39: imul null, r0.w, r0.y, r0.y  
  40: imad r0.w, r0.w, l(0x0000ec4d), l(0.0000000000000000000000000000000000001)  
  41: imad r0.y, r0.y, r0.w, l(146956042240.000000)  
  42: and r0.y, r0.y, l(0x7fffffff)  
  43: itof r0.y, r0.y  
  44: mad r0.y, r0.y, l(0.000000001), l(0.650000)  
  45: add_sat r1.xyzw, v2.xyxy, l(0.001953, 0.000000, -0.001953, 0.000000)  
  46: sample_indexable(texture2d)(float,float,float,float) r0.w, r1.xyxx, t0.yzwx, s0  
  47: sample_indexable(texture2d)(float,float,float,float) r1.x, r1.zwzz, t0.xyzw, s0  
  48: add r0.w, r0.w, r1.x  
  49: add_sat r1.xyzw, v2.xyxy, l(0.000000, 0.001953, 0.000000, -0.001953)  
  50: sample_indexable(texture2d)(float,float,float,float) r1.x, r1.xyxx, t0.xyzw, s0  
  51: sample_indexable(texture2d)(float,float,float,float) r1.y, r1.zwzz, t0.yxzw, s0  
  52: add r0.w, r0.w, r1.x  
  53: add r0.w, r1.y, r0.w  
  54: mad r0.w, r0.w, l(0.250000), -r0.z  
  55: mul r0.w, r0.y, r0.w  
  56: mul r0.y, r0.y, r0.z  
  57: mad r0.x, r0.w, l(0.900000), r0.x  
  58: mad r0.y, r0.y, l(-0.240000), r0.x  
  59: add r0.x, r0.y, r0.z  
  60: mov_sat r0.z, cb3[0].x  
  61: log r0.z, r0.z  
  62: mul r0.z, r0.z, l(100.000000)  
  63: exp r0.z, r0.z  
  64: mad r0.z, r0.z, l(0.160000), l(0.700000)  
  65: mul o0.xy, r0.zzzz, r0.xyxx  
  66: mov o0.zw, l(0, 0, 0, 0)  
  67: ret</code></pre><br/>
Как видите, выходная карта контуров разделена на четыре равных квадрата, и это первое, что нам нужно изучить:<br/>
<br/>
<pre><code class="cpp">   0: add r0.xyzw, v2.xyxy, v2.xyxy  
   1: round_ni r1.xy, r0.zwzz  
   2: frc r0.xyzw, r0.xyzw  
   3: add r1.zw, r1.xxxy, l(0.000000, 0.000000, -1.000000, -1.000000)  
   4: dp2 r1.z, r1.zwzz, r1.zwzz  
   5: add r1.z, -r1.z, l(1.000000)  
   6: max r2.w, r1.z, l(0)  
   7: dp2 r1.z, r1.xyxx, r1.xyxx  
   8: add r3.xyzw, r1.xyxy, l(-1.000000, -0.000000, -0.000000, -1.000000)  
   9: add r1.x, -r1.z, l(1.000000)  
  10: max r2.x, r1.x, l(0)  
  11: dp2 r1.x, r3.xyxx, r3.xyxx  
  12: dp2 r1.y, r3.zwzz, r3.zwzz  
  13: add r1.xy, -r1.xyxx, l(1.000000, 1.000000, 0.000000, 0.000000)  
  14: max r2.yz, r1.xxyx, l(0, 0, 0, 0)</code></pre> <br/>
Мы начинаем с вычисления floor( TextureUV * 2.0 ), что даёт нам следующее:<br/>
<br/>
<div style="text-align:center;"><img src="https://3.bp.blogspot.com/-AumnXjrV4_Q/XKdtEZvU0LI/AAAAAAAABZ0/Q9BkxBG_Vgki5lAsIBIqk4X8_zWELDdLACLcBGAs/s1600/02_floor.JPG"/></div><br/>
Для определения отдельных квадратов используется небольшая функция:<br/>
<br/>
<pre><code class="cpp"> float getParams(float2 uv)  
 {  
      float d = dot(uv, uv);  
      d = 1.0 - d;  
      d = max( d, 0.0 );  
   
      return d;  
 }</code></pre><br/>
Заметьте, что функция возвращает 1.0 при входных данных float2(0.0, 0.0).<br/>
<br/>
Этот случай возникает в левом верхнем углу. Чтобы получить ту же ситуацию в верхнем правом углу, нужно вычесть из округлённых texcoords float2(1, 0), для зелёного квадрата вычесть float2(0, 1), а для жёлтого — float2(1.0, 1.0).<br/>
<br/>
Итак:<br/>
<br/>
<pre><code class="cpp">   float2 flooredTextureUV = floor( 2.0 * TextureUV );  
   ...
     
   float2 uv1 = flooredTextureUV;  
   float2 uv2 = flooredTextureUV + float2(-1.0, -0.0);   
   float2 uv3 = flooredTextureUV + float2( -0.0, -1.0);  
   float2 uv4 = flooredTextureUV + float2(-1.0, -1.0);  
   
   float4 mask;  
   mask.x = getParams( uv1 );  
   mask.y = getParams( uv2 );  
   mask.z = getParams( uv3 );  
   mask.w = getParams( uv4 );</code></pre><br/>
Каждый из компонентов <i>mask</i> равен или нулю, или единице, и ответственен за один квадрат текстуры. Например, <i>mask.r</i> и <i>mask.w</i>:<br/>
<br/>
<div style="text-align:center;"><img src="https://2.bp.blogspot.com/-HRLzcI0uREI/XKd7WhdtqyI/AAAAAAAABaA/6MImHMFdD2kinZuF1J_2hNY3CoA5T6A6QCLcBGAs/s1600/03_corner_r.jpg" data-src="https://2.bp.blogspot.com/-HRLzcI0uREI/XKd7WhdtqyI/AAAAAAAABaA/6MImHMFdD2kinZuF1J_2hNY3CoA5T6A6QCLcBGAs/s1600/03_corner_r.jpg" data-blurred="true"/></div><br/>
<i>mask.r</i><br/>
<br/>
<div style="text-align:center;"><img src="https://1.bp.blogspot.com/-6bKah1ywVgE/XKd7WkXIdfI/AAAAAAAABaE/MKIpXgMKxeobwGd8GvTNbDbrbGd4Vhm-wCLcBGAs/s1600/03_corner_w.jpg" data-src="https://1.bp.blogspot.com/-6bKah1ywVgE/XKd7WkXIdfI/AAAAAAAABaE/MKIpXgMKxeobwGd8GvTNbDbrbGd4Vhm-wCLcBGAs/s1600/03_corner_w.jpg" data-blurred="true"/></div><br/>
<i>mask.w</i><br/>
<br/>
Мы получили <i>mask</i>, давайте двигаться дальше. Строка 15 сэмплирует карту яркости. Учтите, что текстура яркости имеет формат R11G11B10_FLOAT, хотя мы сэмплируем все компоненты rgba. В этой ситуации подразумевается, что .a равно 1.0f.<br/>
<br/>
Используемые для этой операции Texcoords можно вычислить как <i>frac( TextureUV * 2.0 )</i>. Поэтому результат этой операции может, например, выглядеть вот так:<br/>
<br/>
<div style="text-align:center;"><img src="https://1.bp.blogspot.com/-R7j7zzHxho0/XKd8gBy4VkI/AAAAAAAABaQ/DNScCWS6xjEEiZl44GXq01sofkDtNuAewCLcBGAs/s1600/04_intensity_sampled.jpg" data-src="https://1.bp.blogspot.com/-R7j7zzHxho0/XKd8gBy4VkI/AAAAAAAABaQ/DNScCWS6xjEEiZl44GXq01sofkDtNuAewCLcBGAs/s1600/04_intensity_sampled.jpg" data-blurred="true"/></div><br/>
Видите сходство?<br/>
<br/>
Следующий этап очень умён — выполняется четырёхкомпонентное скалярное произведение (dp4):<br/>
<br/>
<pre><code class="cpp">  16: dp4 r1.x, r1.xyzw, r2.xyzw</code></pre><br/>
Таким образом в верхнем левом углу остаётся только красный канал (то есть только интересные объекты), в верхнем правом — только зелёный канал (только следы), а в нижнем правом — всё (потому что компоненту яркости .w косвенно присвоено значение 1.0). Великолепная идея. Результат скалярного произведения выглядит так:<br/>
<br/>
<div style="text-align:center;"><img src="https://2.bp.blogspot.com/-U4T8Yv-zmyM/XKd-CnMc5KI/AAAAAAAABac/TfqE6j1Mcc4Qg7Bu2ksvejXoL86jyJxDwCLcBGAs/s1600/05_dot_mask_intensity.jpg" data-src="https://2.bp.blogspot.com/-U4T8Yv-zmyM/XKd-CnMc5KI/AAAAAAAABac/TfqE6j1Mcc4Qg7Bu2ksvejXoL86jyJxDwCLcBGAs/s1600/05_dot_mask_intensity.jpg" data-blurred="true"/></div><br/>
Получив этот <i>masterFilter</i>, мы готовы к определению контуров объектов. Это не так сложно, как может показаться. Алгоритм очень похож на применённый при получении резкости — нам нужно получить максимальную абсолютную разность значений.<br/>
<br/>
Вот что происходит: мы сэмплируем четыре тексела рядом с текущим обрабатываемым текселом (важно: в этом случае размер тексела равен 1.0/256.0!) и вычисляем максимальные абсолютные разности для красного и зелёного каналов:<br/>
<br/>
<pre><code class="cpp">   float fTexel = 1.0 / 256;  
     
   float2 sampling1 = TextureUV + float2( fTexel, 0 );  
   float2 sampling2 = TextureUV + float2( -fTexel, 0 );  
   float2 sampling3 = TextureUV + float2( 0, fTexel );  
   float2 sampling4 = TextureUV + float2( 0, -fTexel );  
     
   float2 intensity_x0 = texIntensityMap.Sample( sampler1, sampling1 ).xy;  
   float2 intensity_x1 = texIntensityMap.Sample( sampler1, sampling2 ).xy;  
   float2 intensity_diff_x = intensity_x0 - intensity_x1;  
     
   float2 intensity_y0 = texIntensityMap.Sample( sampler1, sampling3 ).xy;  
   float2 intensity_y1 = texIntensityMap.Sample( sampler1, sampling4 ).xy;  
   float2 intensity_diff_y = intensity_y0 - intensity_y1;  
     
   float2 maxAbsDifference = max( abs(intensity_diff_x), abs(intensity_diff_y) );  
   maxAbsDifference = saturate(maxAbsDifference);</code></pre><br/>
Теперь если мы перемножим <i>filter</i> на <i>maxAbsDifference</i>…<br/>
<br/>
<div style="text-align:center;"><img src="https://2.bp.blogspot.com/-1TsHGaxWlb0/XKeCooV84wI/AAAAAAAABao/lHyhFRkxnTcaQXxXQgwREHm_cldGhPhFwCLcBGAs/s1600/06_outlines.jpg" data-src="https://2.bp.blogspot.com/-1TsHGaxWlb0/XKeCooV84wI/AAAAAAAABao/lHyhFRkxnTcaQXxXQgwREHm_cldGhPhFwCLcBGAs/s1600/06_outlines.jpg" data-blurred="true"/></div><br/>
Очень просто и эффективно.<br/>
<br/>
Получив контуры, мы сэмплируем карту контуров из предыдущего кадра.<br/>
<br/>
Затем, чтобы получить „призрачный“ эффект, мы берём часть параметров, вычисленных на текущем проходе, и значения из карты контуров.<br/>
<br/>
Поздоровайтесь с нашим старым другом — целочисленным шумом. Он присутствует и здесь. Параметры анимации (cb3[0].zw) берутся из буфера констант и со временем изменяются.<br/>
<br/>
<pre><code class="cpp">   float2 outlines = masterFilter * maxAbsDifference;  
     
   // Sample outline map  
   float2 outlineMap = texOutlineMap.Sample( samplerLinearWrap, uv ).xy;  
     
   // I guess it's related with ghosting   
   float paramOutline = masterFilter*0.15 + outlineMap.y;  
   paramOutline += 0.35 * outlines.r;  
   paramOutline += 0.35 * outlines.g;  
     
   // input for integer noise  
   float2 noiseWeights = cb3_v0.zw;
   float2 noiseInputs = 150.0*uv + 300.0*noiseWeights;  
   int2 iNoiseInputs = (int2) noiseInputs;  
     
   float noise0 = clamp( integerNoise( iNoiseInputs.x + reversebits(iNoiseInputs.y) ), -1, 1 ) + 0.65; // r0.y</code></pre><br/>
Примечание: если вы захотите реализовать ведьмачье чутьё самостоятельно, то рекомендую ограничить целочисленный шум интервалом [-1;1] (как и сказано на его веб-сайте). В оригинальном шейдере TW3 ограничения не было, но без него я получал ужасные артефакты и вся карта контуров была нестабильной.<br/>
<br/>
Затем мы сэмплируем карту контуров тем же способом, что и карту яркости ранее (на этот раз тексел имеет размер 1.0/512.0), и вычисляем среднее значение компонента .x:<br/>
<br/>
<pre><code class="cpp">  // sampling of outline map  
   fTexel = 1.0 / 512.0;  
     
   sampling1 = saturate( uv + float2( fTexel, 0 ) );  
   sampling2 = saturate( uv + float2( -fTexel, 0 ) );  
   sampling3 = saturate( uv + float2( 0, fTexel ) );  
   sampling4 = saturate( uv + float2( 0, -fTexel ) );  
     
   float outline_x0 = texOutlineMap.Sample( sampler0, sampling1 ).x;  
   float outline_x1 = texOutlineMap.Sample( sampler0, sampling2 ).x;  
   float outline_y0 = texOutlineMap.Sample( sampler0, sampling3 ).x;  
   float outline_y1 = texOutlineMap.Sample( sampler0, sampling4 ).x;  
   float averageOutline = (outline_x0+outline_x1+outline_y0+outline_y1) / 4.0;</code></pre><br/>
Затем, судя по ассемблерному коду, вычисляется разность между средним и значением этого конкретного пикселя, после чего выполняется искажение целочисленным шумом:<br/>
<br/>
<pre><code class="cpp">   // perturb with noise  
   float frameOutlineDifference = averageOutline - outlineMap.x;  
   frameOutlineDifference *= noise0;</code></pre><br/>
Следующим шагом будет искажение значения из „старой“ карты контуров с помощью шума — это основная линия, придающая выходной текстуре ощущение блочности.<br/>
<br/>
Дальше идут другие вычисления, после чего, в самом конце, вычисляется „затухание“.<br/>
<br/>
<pre><code class="cpp">   // the main place with gives blocky look of texture  
   float newNoise = outlineMap.x * noise0;  
     
   float newOutline = frameOutlineDifference * 0.9 + paramOutline;  
   newOutline -= 0.24*newNoise;  
     
   // 59: add r0.x, r0.y, r0.z  
   float2 finalOutline = float2( outlineMap.x + newOutline, newOutline);  
     
   // * calculate damping  
   float dampingParam = saturate( cb3_v0.x );  
   dampingParam = pow( dampingParam, 100 );    
     
   float damping = 0.7 + 0.16*dampingParam;  
   
   
   // * final multiplication  
   float2 finalColor = finalOutline * damping;  
   return float4(finalColor, 0, 0);</code></pre><br/>
Вот небольшое видео, демонстрирующее в действии карту контуров:<br/>
<br/>
<div class="oembed"><div><div style="left: 0; width: 100%; height: 0; position: relative; padding-bottom: 56.2493%;"><div class="tm-iframe_temp" data-src="https://www.youtube.com/embed/vSscLz2RYsQ?rel=0&amp;showinfo=1&amp;hl=en-US" data-style="border: 0; top: 0; left: 0; width: 100%; height: 100%; position: absolute;" id="" width=""></div></div></div></div><br/>
Если вам интересен полный пиксельный шейдер, то он выложен <a href="https://pastebin.com/JPv7AyXK">здесь</a>. Шейдер совместим с RenderDoc.<br/>
<br/>
Интересно (и, если честно, слегка раздражает) то, что несмотря на идентичность ассемблерного кода с оригинальным шейдером из Witcher 3, окончательный внешний вид карты контуров в RenderDoc меняется!<br/>
<br/>
Примечание: в последнем проходе (см. следующую часть) вы увидите, что используется только канал .r карты контуров. Зачем же тогда нам нужен канал .g? Думаю, что это какой-то буфер „пинг-понга“ в одной текстуре — заметьте, что .r содержит канал .g + какое-то новое значение.<br/>
<br/>
<h2>Часть 5: Ведьмачье чутьё (»рыбий глаз" и окончательный результат)</h2><br/>
Вкратце перечислим, что у нас уже есть: в первой части, посвящённой ведьмачьему чутью, сгенерирована полноэкранная карта яркости, сообщающая насколько заметен должен быть эффект в зависимости от расстояния. Во второй части я подробнее исследовал карту контуров, отвечающую за контуры и анимацию готового эффекта.<br/>
<br/>
Мы подошли к последнему этапу. Всё это нужно объединить! Последний проход — это полноэкранный четырёхугольник. Входные данные: буфер цветов, карта контуров и карта яркости.<br/>
<br/>
До:<br/>
<br/>
<div style="text-align:center;"><img src="https://1.bp.blogspot.com/-oQKKd9lbcLQ/XKihDzw4ZuI/AAAAAAAABbM/DmJUkV9PA4w5m0gf06MrS2t_vt5eQV5dQCEwYBhgL/s1600/before.jpg" data-src="https://1.bp.blogspot.com/-oQKKd9lbcLQ/XKihDzw4ZuI/AAAAAAAABbM/DmJUkV9PA4w5m0gf06MrS2t_vt5eQV5dQCEwYBhgL/s1600/before.jpg" data-blurred="true"/></div><br/>
<br/>
После:<br/>
<br/>
<div style="text-align:center;"><img src="https://3.bp.blogspot.com/-got60f2XK9Y/XKihDpXA0cI/AAAAAAAABbE/6pgzzBB36Ck-RsuRS_lNHv0pmvzSJjywACEwYBhgL/s1600/after.jpg" data-src="https://3.bp.blogspot.com/-got60f2XK9Y/XKihDpXA0cI/AAAAAAAABbE/6pgzzBB36Ck-RsuRS_lNHv0pmvzSJjywACEwYBhgL/s1600/after.jpg" data-blurred="true"/></div><br/>
Ещё раз покажу видео с применённым эффектом:<br/>
<br/>
<div class="oembed"><div><div style="left: 0; width: 100%; height: 0; position: relative; padding-bottom: 56.2493%;"><div class="tm-iframe_temp" data-src="https://www.youtube.com/embed/ReB6IrOb3ic?rel=0&amp;showinfo=1&amp;hl=en-US" data-style="border: 0; top: 0; left: 0; width: 100%; height: 100%; position: absolute;" id="" width=""></div></div></div></div><br/>
Как видите, кроме наложения контуров на объекты, которые может увидеть или услышать Геральт, ко всему экрану применяется эффект «рыбьего глаза», и весь экран (особенно углы) становится сероватым, чтобы передать ощущение реального охотника за чудовищами.<br/>
<br/>
Полный ассемблерный код пиксельного шейдера:<br/>
<br/>
<pre><code class="cpp"> ps_5_0  
    dcl_globalFlags refactoringAllowed  
    dcl_constantbuffer cb0[3], immediateIndexed  
    dcl_constantbuffer cb3[7], immediateIndexed  
    dcl_sampler s0, mode_default  
    dcl_sampler s2, mode_default  
    dcl_resource_texture2d (float,float,float,float) t0  
    dcl_resource_texture2d (float,float,float,float) t2  
    dcl_resource_texture2d (float,float,float,float) t3  
    dcl_input_ps_siv v0.xy, position  
    dcl_output o0.xyzw  
    dcl_temps 7  
   0: div r0.xy, v0.xyxx, cb0[2].xyxx  
   1: mad r0.zw, r0.xxxy, l(0.000000, 0.000000, 2.000000, 2.000000), l(0.000000, 0.000000, -1.000000, -1.000000)  
   2: mov r1.yz, abs(r0.zzwz)  
   3: div r0.z, cb0[2].x, cb0[2].y  
   4: mul r1.x, r0.z, r1.y  
   5: add r0.zw, r1.xxxz, -cb3[2].xxxy  
   6: mul_sat r0.zw, r0.zzzw, l(0.000000, 0.000000, 0.555556, 0.555556)  
   7: log r0.zw, r0.zzzw  
   8: mul r0.zw, r0.zzzw, l(0.000000, 0.000000, 2.500000, 2.500000)  
   9: exp r0.zw, r0.zzzw  
  10: dp2 r0.z, r0.zwzz, r0.zwzz  
  11: sqrt r0.z, r0.z  
  12: min r0.z, r0.z, l(1.000000)  
  13: add r0.z, -r0.z, l(1.000000)  
  14: mov_sat r0.w, cb3[6].x  
  15: add_sat r1.xy, -r0.xyxx, l(0.030000, 0.030000, 0.000000, 0.000000)  
  16: add r1.x, r1.y, r1.x  
  17: add_sat r0.xy, r0.xyxx, l(-0.970000, -0.970000, 0.000000, 0.000000)  
  18: add r0.x, r0.x, r1.x  
  19: add r0.x, r0.y, r0.x  
  20: mul r0.x, r0.x, l(20.000000)  
  21: min r0.x, r0.x, l(1.000000)  
  22: add r1.xy, v0.xyxx, v0.xyxx  
  23: div r1.xy, r1.xyxx, cb0[2].xyxx  
  24: add r1.xy, r1.xyxx, l(-1.000000, -1.000000, 0.000000, 0.000000)  
  25: dp2 r0.y, r1.xyxx, r1.xyxx  
  26: mul r1.xy, r0.yyyy, r1.xyxx  
  27: mul r0.y, r0.w, l(0.100000)  
  28: mul r1.xy, r0.yyyy, r1.xyxx  
  29: max r1.xy, r1.xyxx, l(-0.400000, -0.400000, 0.000000, 0.000000)  
  30: min r1.xy, r1.xyxx, l(0.400000, 0.400000, 0.000000, 0.000000)  
  31: mul r1.xy, r1.xyxx, cb3[1].xxxx  
  32: mul r1.zw, r1.xxxy, cb0[2].zzzw  
  33: mad r1.zw, v0.xxxy, cb0[1].zzzw, -r1.zzzw  
  34: sample_indexable(texture2d)(float,float,float,float) r2.xyz, r1.zwzz, t0.xyzw, s0  
  35: mul r3.xy, r1.zwzz, l(0.500000, 0.500000, 0.000000, 0.000000)  
  36: sample_indexable(texture2d)(float,float,float,float) r0.y, r3.xyxx, t2.yxzw, s2  
  37: mad r3.xy, r1.zwzz, l(0.500000, 0.500000, 0.000000, 0.000000), l(0.500000, 0.000000, 0.000000, 0.000000)  
  38: sample_indexable(texture2d)(float,float,float,float) r2.w, r3.xyxx, t2.yzwx, s2  
  39: mul r2.w, r2.w, l(0.125000)  
  40: mul r3.x, cb0[0].x, l(0.100000)  
  41: add r0.x, -r0.x, l(1.000000)  
  42: mul r0.xy, r0.xyxx, l(0.030000, 0.125000, 0.000000, 0.000000)  
  43: mov r3.yzw, l(0, 0, 0, 0)  
  44: mov r4.x, r0.y  
  45: mov r4.y, r2.w  
  46: mov r4.z, l(0)  
  47: loop  
  48:  ige r4.w, r4.z, l(8)  
  49:  breakc_nz r4.w  
  50:  itof r4.w, r4.z  
  51:  mad r4.w, r4.w, l(0.785375), -r3.x  
  52:  sincos r5.x, r6.x, r4.w  
  53:  mov r6.y, r5.x  
  54:  mul r5.xy, r0.xxxx, r6.xyxx  
  55:  mad r5.zw, r5.xxxy, l(0.000000, 0.000000, 0.125000, 0.125000), r1.zzzw  
  56:  mul r6.xy, r5.zwzz, l(0.500000, 0.500000, 0.000000, 0.000000)  
  57:  sample_indexable(texture2d)(float,float,float,float) r4.w, r6.xyxx, t2.yzwx, s2  
  58:  mad r4.x, r4.w, l(0.125000), r4.x  
  59:  mad r5.zw, r5.zzzw, l(0.000000, 0.000000, 0.500000, 0.500000), l(0.000000, 0.000000, 0.500000, 0.000000)  
  60:  sample_indexable(texture2d)(float,float,float,float) r4.w, r5.zwzz, t2.yzwx, s2  
  61:  mad r4.y, r4.w, l(0.125000), r4.y  
  62:  mad r5.xy, r5.xyxx, r1.xyxx, r1.zwzz  
  63:  sample_indexable(texture2d)(float,float,float,float) r5.xyz, r5.xyxx, t0.xyzw, s0  
  64:  mad r3.yzw, r5.xxyz, l(0.000000, 0.125000, 0.125000, 0.125000), r3.yyzw  
  65:  iadd r4.z, r4.z, l(1)  
  66: endloop  
  67: sample_indexable(texture2d)(float,float,float,float) r0.xy, r1.zwzz, t3.xyzw, s0  
  68: mad_sat r0.xy, -r0.xyxx, l(0.800000, 0.750000, 0.000000, 0.000000), r4.xyxx  
  69: dp3 r1.x, r3.yzwy, l(0.300000, 0.300000, 0.300000, 0.000000)  
  70: add r1.yzw, -r1.xxxx, r3.yyzw  
  71: mad r1.xyz, r0.zzzz, r1.yzwy, r1.xxxx  
  72: mad r1.xyz, r1.xyzx, l(0.600000, 0.600000, 0.600000, 0.000000), -r2.xyzx  
  73: mad r1.xyz, r0.wwww, r1.xyzx, r2.xyzx  
  74: mul r0.yzw, r0.yyyy, cb3[4].xxyz  
  75: mul r2.xyz, r0.xxxx, cb3[5].xyzx  
  76: mad r0.xyz, r0.yzwy, l(1.200000, 1.200000, 1.200000, 0.000000), r2.xyzx  
  77: mov_sat r2.xyz, r0.xyzx  
  78: dp3_sat r0.x, r0.xyzx, l(1.000000, 1.000000, 1.000000, 0.000000)  
  79: add r0.yzw, -r1.xxyz, r2.xxyz  
  80: mad o0.xyz, r0.xxxx, r0.yzwy, r1.xyzx  
  81: mov o0.w, l(1.000000)  
  82: ret</code></pre> <br/>
82 строки — значит, нам предстоит много работы!<br/>
<br/>
Для начала взглянем на входящие данные:<br/>
<br/>
<pre><code class="cpp">   // *** Inputs       
     
   // * Zoom amount, always 1  
   float zoomAmount = cb3_v1.x;  
     
   // Another value which affect fisheye effect  
   // but always set to float2(1.0, 1.0).  
   float2 amount = cb0_v2.zw;  
     
   // Elapsed time in seconds  
   float time = cb0_v0.x;  
     
   // Colors of witcher senses  
   float3 colorInteresting = cb3_v5.rgb;  
   float3 colorTraces = cb3_v4.rgb;  
     
   // Was always set to float2(0.0, 0.0).  
   // Setting this to higher values  
   // makes "grey corners" effect weaker.  
   float2 offset = cb3_v2.xy;  
     
   // Dimensions of fullscreen  
   float2 texSize = cb0_v2.xy;  
   float2 invTexSize = cb0_v1.zw;  
   
   // Main value which causes fisheye effect [0-1]  
   const float fisheyeAmount = saturate( cb3_v6.x );</code></pre><br/>
Основное значение, ответственное за величину эффекта — это <i>fisheyeAmount</i>. Думаю, оно постепенно повышается с 0.0 до 1.0, когда Геральт начинает использовать своё чутьё. Остальные значения почти не меняются, но я подозреваю, что некоторые из них отличались бы, если бы пользователь отключил в опциях эффект fisheye (я это не проверял).<br/>
<br/>
Первое, что здесь происходит — шейдер вычисляет маску, отвечающую за серые углы:<br/>
<br/>
<pre><code class="cpp">   0: div r0.xy, v0.xyxx, cb0[2].xyxx   
   1: mad r0.zw, r0.xxxy, l(0.000000, 0.000000, 2.000000, 2.000000), l(0.000000, 0.000000, -1.000000, -1.000000)   
   2: mov r1.yz, abs(r0.zzwz)   
   3: div r0.z, cb0[2].x, cb0[2].y   
   4: mul r1.x, r0.z, r1.y   
   5: add r0.zw, r1.xxxz, -cb3[2].xxxy   
   6: mul_sat r0.zw, r0.zzzw, l(0.000000, 0.000000, 0.555556, 0.555556)   
   7: log r0.zw, r0.zzzw   
   8: mul r0.zw, r0.zzzw, l(0.000000, 0.000000, 2.500000, 2.500000)   
   9: exp r0.zw, r0.zzzw   
  10: dp2 r0.z, r0.zwzz, r0.zwzz   
  11: sqrt r0.z, r0.z   
  12: min r0.z, r0.z, l(1.000000)   
  13: add r0.z, -r0.z, l(1.000000)</code></pre><br/>
На HLSL мы можем записать это следующим образом:<br/>
<br/>
<pre><code class="cpp">   // Main uv  
   float2 uv = PosH.xy / texSize;  
     
   // Scale at first from [0-1] to [-1;1], then calculate abs  
   float2 uv3 = abs( uv * 2.0 - 1.0);   
        
   // Aspect ratio  
   float aspectRatio = texSize.x / texSize.y;  
        
   // * Mask used to make corners grey  
   float mask_gray_corners;  
   {  
     float2 newUv = float2( uv3.x * aspectRatio, uv3.y ) - offset;  
     newUv = saturate( newUv / 1.8 );  
     newUv = pow(newUv, 2.5);  
       
     mask_gray_corners = 1-min(1.0, length(newUv) );  
   }</code></pre><br/>
Сначала вычисляется интервал [-1; 1] UV и их абсолютные значения. Затем имеет место хитрое «сжимание». Готовая маска выглядит следующим образом:<br/>
<br/>
<div style="text-align:center;"><img src="/img/image-loader.svg" data-src="https://1.bp.blogspot.com/-zsp6VceueIQ/XKihEhtGrPI/AAAAAAAABbw/0RDidmwTWgkOlwtJp20uKByz8ZRK8tRJACEwYBhgL/s1600/mask_gray_corners.png"/></div><br/>
Позже я вернусь к этой маске.<br/>
<br/>
Сейчас я намеренно пропущу несколько строк кода и внимательнее изучу код, отвечающий за эффект «зума».<br/>
<br/>
<pre><code class="cpp">  22: add r1.xy, v0.xyxx, v0.xyxx   
  23: div r1.xy, r1.xyxx, cb0[2].xyxx   
  24: add r1.xy, r1.xyxx, l(-1.000000, -1.000000, 0.000000, 0.000000)   
  25: dp2 r0.y, r1.xyxx, r1.xyxx   
  26: mul r1.xy, r0.yyyy, r1.xyxx   
  27: mul r0.y, r0.w, l(0.100000)   
  28: mul r1.xy, r0.yyyy, r1.xyxx   
  29: max r1.xy, r1.xyxx, l(-0.400000, -0.400000, 0.000000, 0.000000)   
  30: min r1.xy, r1.xyxx, l(0.400000, 0.400000, 0.000000, 0.000000)   
  31: mul r1.xy, r1.xyxx, cb3[1].xxxx   
  32: mul r1.zw, r1.xxxy, cb0[2].zzzw   
  33: mad r1.zw, v0.xxxy, cb0[1].zzzw, -r1.zzzw</code></pre><br/>
Сначала вычисляются «удвоенные» координаты текстур и выполняется вычитание float2(1, 1):<br/>
<br/>
<pre><code class="cpp">   float2 uv4 = 2 * PosH.xy;  
   uv4 /= cb0_v2.xy;  
   uv4 -= float2(1.0, 1.0);</code></pre> <br/>
Такие texcoord можно визуализировать так:<br/>
<br/>
<div style="text-align:center;"><img src="https://2.bp.blogspot.com/-DMQhZp1uF8M/XKihFJTxhgI/AAAAAAAABb4/bcFforMSspcZm57vi4aApZ16pdOr-yMeACEwYBhgL/s1600/zoom_uvs.jpg" data-src="https://2.bp.blogspot.com/-DMQhZp1uF8M/XKihFJTxhgI/AAAAAAAABb4/bcFforMSspcZm57vi4aApZ16pdOr-yMeACEwYBhgL/s1600/zoom_uvs.jpg" data-blurred="true"/></div><br/>
Затем вычисляется скалярное произведение <i>dot(uv4, uv4)</i>, что даёт нам маску:<br/>
<br/>
<div style="text-align:center;"><img src="/img/image-loader.svg" data-src="https://1.bp.blogspot.com/-imbPBINnWFs/XKihE2YDmxI/AAAAAAAABb4/VzLi_7GdAhk19jJgqSGr-cZyoN-tE8F9ACEwYBhgL/s1600/mask_zoom_01.png"/></div><br/>
которая используется для умножения на вышеупомянутые texcoords:<br/>
<br/>
<div style="text-align:center;"><img src="https://4.bp.blogspot.com/-491z4gHKJpg/XKihFbmLJrI/AAAAAAAABb0/e9-ldof2uUoYEh9xDGp9UgurkbkhmxVQwCEwYBhgL/s1600/zoom_uvs_distorted.jpg" data-src="https://4.bp.blogspot.com/-491z4gHKJpg/XKihFbmLJrI/AAAAAAAABb0/e9-ldof2uUoYEh9xDGp9UgurkbkhmxVQwCEwYBhgL/s1600/zoom_uvs_distorted.jpg" data-blurred="true"/></div><br/>
Важно: в верхнем левом углу (чёрные пиксели) значения отрицательны. Они отображаются чёрным (0.0) из-за ограниченной точности формата R11G11B10_FLOAT. У него нет знакового бита, поэтому в нём нельзя хранить отрицательные значения.<br/>
<br/>
Затем вычисляется коэффициент затухания (как я говорил выше, <i>fisheyeAmount</i> изменяется от 0.0 до 1.0).<br/>
<br/>
<pre><code class="cpp">   float attenuation = fisheyeAmount * 0.1;  
   uv4 *= attenuation;</code></pre><br/>
Затем выполняется ограничение (max/min) и одно умножение.<br/>
<br/>
Таким образом вычисляется смещение. Для вычисления конечных uv, которые будут использоваться для сэмплирования текстуры цвета, мы просто выполняем вычитание:<br/>
<br/>
<i>float2 colorUV = mainUv — offset;</i><br/>
<br/>
Выполняя сэмплирование входной текстуры цвета <i>colorUV</i>, мы получаем рядом с углами искажённое изображение:<br/>
<br/>
<div style="text-align:center;"><img src="https://3.bp.blogspot.com/-Q7IHQiilwWM/XKiqbPOjzkI/AAAAAAAABcQ/VkI6vTYGKpY72jCqLxl7Hepwhd7WS1t-wCLcBGAs/s1600/main_color_distorted.jpg" data-src="https://3.bp.blogspot.com/-Q7IHQiilwWM/XKiqbPOjzkI/AAAAAAAABcQ/VkI6vTYGKpY72jCqLxl7Hepwhd7WS1t-wCLcBGAs/s1600/main_color_distorted.jpg" data-blurred="true"/></div><br/>
<h4>Контуры</h4><br/>
Следующий этап — сэмплирование карты контуров для нахождения контуров. Это довольно просто, сначала мы находим texcoords для сэмплирования контуров интересных объектов, а затем то же самое делаем для следов:<br/>
<br/>
<pre><code class="cpp">   // * Sample outline map  
        
   // interesting objects (upper left square)  
   float2 outlineUV = colorUV * 0.5;  
   float outlineInteresting = texture2.Sample( sampler2, outlineUV ).x; // r0.y  
        
   // traces (upper right square)  
   outlineUV = colorUV * 0.5 + float2(0.5, 0.0);  
   float outlineTraces = texture2.Sample( sampler2, outlineUV ).x; // r2.w  
        
   outlineInteresting /= 8.0; // r4.x  
   outlineTraces /= 8.0; // r4.y</code></pre> <br/>
<div style="text-align:center;"><img src="https://2.bp.blogspot.com/-De_y5_2IXYc/XKir4f3kEMI/AAAAAAAABcc/XLghv1K0mU4JcCrE49EQqOykU5FWDCVgACLcBGAs/s1600/outline_int.jpg" data-src="https://2.bp.blogspot.com/-De_y5_2IXYc/XKir4f3kEMI/AAAAAAAABcc/XLghv1K0mU4JcCrE49EQqOykU5FWDCVgACLcBGAs/s1600/outline_int.jpg" data-blurred="true"/></div><br/>
<i>Интересные объекты из карты контуров</i><br/>
<br/>
<div style="text-align:center;"><img src="https://1.bp.blogspot.com/-6sMY4ZZweSg/XKir4Z7PszI/AAAAAAAABcg/JaqmwG_vxEUpKtPuoXBuR8KAoSfbuNiIQCLcBGAs/s1600/outline_traces.jpg" data-src="https://1.bp.blogspot.com/-6sMY4ZZweSg/XKir4Z7PszI/AAAAAAAABcg/JaqmwG_vxEUpKtPuoXBuR8KAoSfbuNiIQCLcBGAs/s1600/outline_traces.jpg" data-blurred="true"/></div><br/>
<i>Следы из карты контуров</i><br/>
<br/>
Стоит заметить, что мы сэмплируем из карты контуров только канал .x и учитываем только верхние квадраты.<br/>
<br/>
<h4>Движение</h4><br/>
Для реализации движения следов используется почти такой же трюк, как и в эффекте опьянения. Добавляется круг единичного размера и мы сэмплируем 8 раз карту контуров для интересных объектов и следов, а также текстуру цвета.<br/>
<br/>
Заметьте, что мы только разделили найденные контуры на 8.0.<br/>
<br/>
Так как мы находимся в пространстве текстурных координат [0-1]<sup>2</sup>, то наличие круга радиусом 1 для обведения отдельного пикселя создаст неприемлемые артефакты:<br/>
<br/>
<div style="text-align:center;"><img src="https://2.bp.blogspot.com/-eL-p8_u_5XE/XKiuJg9MnRI/AAAAAAAABcw/tJYST-efWZQEgXrAefUfyQxmGkND2cHsgCLcBGAs/s1600/unit_circle_artifacts.jpg" data-src="https://2.bp.blogspot.com/-eL-p8_u_5XE/XKiuJg9MnRI/AAAAAAAABcw/tJYST-efWZQEgXrAefUfyQxmGkND2cHsgCLcBGAs/s1600/unit_circle_artifacts.jpg" data-blurred="true"/></div><br/>
Поэтому прежде чем двигаться дальше, давайте узнаем, как вычисляется этот радиус. Для этого нам нужно вернуться к пропущенным строкам 15-21. Небольшая проблем с вычислением этого радиуса заключается в том, что его вычисление разбросано по шейдеру (возможно, из-за оптимизаций шейдера компилятором). Поэтому вот первая часть (15-21) и вторая (41-42):<br/>
<br/>
<pre><code class="cpp">  15: add_sat r1.xy, -r0.xyxx, l(0.030000, 0.030000, 0.000000, 0.000000)  
  16: add r1.x, r1.y, r1.x  
  17: add_sat r0.xy, r0.xyxx, l(-0.970000, -0.970000, 0.000000, 0.000000)  
  18: add r0.x, r0.x, r1.x  
  19: add r0.x, r0.y, r0.x  
  20: mul r0.x, r0.x, l(20.000000)  
  21: min r0.x, r0.x, l(1.000000)  
  ...  
  41: add r0.x, -r0.x, l(1.000000)  
  42: mul r0.xy, r0.xyxx, l(0.030000, 0.125000, 0.000000, 0.000000)</code></pre> <br/>
Как видите, мы рассматриваем только текселы из [0.00 — 0.03] рядом с каждой поверхностью, суммируем их значения, умножаем 20 и насыщаем. Вот как они выглядят после строк 15-21:<br/>
<br/>
<div style="text-align:center;"><img src="https://1.bp.blogspot.com/-RBdcn9rnpzY/XKiwsuUmQqI/AAAAAAAABdA/RLRIrkVlgRcI5LblVV58650kc24DNZ_AQCLcBGAs/s1600/circle_radius_mask_first_stage.jpg" data-src="https://1.bp.blogspot.com/-RBdcn9rnpzY/XKiwsuUmQqI/AAAAAAAABdA/RLRIrkVlgRcI5LblVV58650kc24DNZ_AQCLcBGAs/s1600/circle_radius_mask_first_stage.jpg" data-blurred="true"/></div><br/>
А вот как после строки 41:<br/>
<br/>
<div style="text-align:center;"><img src="https://2.bp.blogspot.com/-DLYvL198NPU/XKiwsjKHfTI/AAAAAAAABc8/7wg3o2FRIg00zaE_jwdTSUpBQRdkI3JyQCEwYBhgL/s1600/circle_radius_mask.jpg" data-src="https://2.bp.blogspot.com/-DLYvL198NPU/XKiwsjKHfTI/AAAAAAAABc8/7wg3o2FRIg00zaE_jwdTSUpBQRdkI3JyQCEwYBhgL/s1600/circle_radius_mask.jpg" data-blurred="true"/></div><br/>
В строке 42 мы умножаем это на 0.03, это значение является радиусом круга для всего экрана. Как видите, ближе к краям экрана радиус становится меньше.<br/>
<br/>
Теперь мы можем посмотреть на ассемблерный код, отвечающий за движение:<br/>
<br/>
<pre><code class="cpp">  40: mul r3.x, cb0[0].x, l(0.100000)  
  41: add r0.x, -r0.x, l(1.000000)  
  42: mul r0.xy, r0.xyxx, l(0.030000, 0.125000, 0.000000, 0.000000)  
  43: mov r3.yzw, l(0, 0, 0, 0)  
  44: mov r4.x, r0.y  
  45: mov r4.y, r2.w  
  46: mov r4.z, l(0)  
  47: loop  
  48:  ige r4.w, r4.z, l(8)  
  49:  breakc_nz r4.w  
  50:  itof r4.w, r4.z  
  51:  mad r4.w, r4.w, l(0.785375), -r3.x  
  52:  sincos r5.x, r6.x, r4.w  
  53:  mov r6.y, r5.x  
  54:  mul r5.xy, r0.xxxx, r6.xyxx  
  55:  mad r5.zw, r5.xxxy, l(0.000000, 0.000000, 0.125000, 0.125000), r1.zzzw  
  56:  mul r6.xy, r5.zwzz, l(0.500000, 0.500000, 0.000000, 0.000000)  
  57:  sample_indexable(texture2d)(float,float,float,float) r4.w, r6.xyxx, t2.yzwx, s2  
  58:  mad r4.x, r4.w, l(0.125000), r4.x  
  59:  mad r5.zw, r5.zzzw, l(0.000000, 0.000000, 0.500000, 0.500000), l(0.000000, 0.000000, 0.500000, 0.000000)  
  60:  sample_indexable(texture2d)(float,float,float,float) r4.w, r5.zwzz, t2.yzwx, s2  
  61:  mad r4.y, r4.w, l(0.125000), r4.y  
  62:  mad r5.xy, r5.xyxx, r1.xyxx, r1.zwzz  
  63:  sample_indexable(texture2d)(float,float,float,float) r5.xyz, r5.xyxx, t0.xyzw, s0  
  64:  mad r3.yzw, r5.xxyz, l(0.000000, 0.125000, 0.125000, 0.125000), r3.yyzw  
  65:  iadd r4.z, r4.z, l(1)  
  66: endloop</code></pre><br/>
Давайте остановимся здесь на минуту. В строке 40 мы получаем временной коэффициент — просто <i>elapsedTime * 0.1</i>. В строке 43 у нас буфер для текстуры цвета, получаемой внутри цикла.<br/>
<br/>
<i>r0.x</i> (строки 41-42) — это, как мы теперь знаем, радиус круга. <i>r4.x</i> (строка 44) — это контур интересных объектов, <i>r4.y</i> (строка 45) — контур следов (ранее разделённый на 8!), а <i>r4.z</i> (строка 46) — счётчик цикла.<br/>
<br/>
Как можно ожидать, цикл имеет 8 итераций. Мы начинаем с вычисления угла в радианах <i>i * PI_4</i>, что даёт нам 2*PI — полный круг. Угол со временем искажается.<br/>
<br/>
С помощью sincos мы определяем точку сэмплирования (единичный круг) и изменяем радиус с помощью умножения (строка 54).<br/>
<br/>
После этого мы обходим пиксель по кругу и сэмплируем контуры и цвет. После цикла мы получим средние значения (благодаря делению на 8) контуров и цвета.<br/>
<br/>
<pre><code class="cpp">   float timeParam = time * 0.1;  
     
   // adjust circle radius  
   circle_radius = 1.0 - circle_radius;  
   circle_radius *= 0.03;  
        
   float3 color_circle_main = float3(0.0, 0.0, 0.0);  
        
   [loop]  
   for (int i=0; 8 > i; i++)  
   {  
      // full 2*PI = 360 angles cycle  
      const float angleRadians = (float) i * PI_4 - timeParam;  
             
      // unit circle  
      float2 unitCircle;  
      sincos(angleRadians, unitCircle.y, unitCircle.x); // unitCircle.x = cos, unitCircle.y = sin  
             
      // adjust radius  
      unitCircle *= circle_radius;  
             
      // * base texcoords (circle) - note we also scale radius here by 8  
      // * probably because of dimensions of outline map.  
      // line 55  
      float2 uv_outline_base = colorUV + unitCircle / 8.0;  
                       
      // * interesting objects (circle)  
      float2 uv_outline_interesting_circle = uv_outline_base * 0.5;  
      float outline_interesting_circle = texture2.Sample( sampler2, uv_outline_interesting_circle ).x;  
      outlineInteresting += outline_interesting_circle / 8.0;  
             
      // * traces (circle)  
      float2 uv_outline_traces_circle = uv_outline_base * 0.5 + float2(0.5, 0.0);  
      float outline_traces_circle = texture2.Sample( sampler2, uv_outline_traces_circle ).x;  
      outlineTraces += outline_traces_circle / 8.0;

      // * sample color texture (zooming effect) with perturbation
      float2 uv_color_circle = colorUV + unitCircle * offsetUV;  
      float3 color_circle = texture0.Sample( sampler0, uv_color_circle ).rgb;
      color_circle_main += color_circle / 8.0;  
   }</code></pre> <br/>
Сэмплирование цвета выполнятся почти так же, но к базовому <i>colorUV</i> мы прибавляем смещение, умноженное на «единичный» круг.<br/>
<br/>
<h4>Яркости</h4><br/>
После цикла мы сэмплируем карту яркости и изменяем финальные значения яркости (потому что карта яркости ничего не знает о контурах):<br/>
<br/>
<pre><code class="cpp">  67: sample_indexable(texture2d)(float,float,float,float) r0.xy, r1.zwzz, t3.xyzw, s0  
  68: mad_sat r0.xy, -r0.xyxx, l(0.800000, 0.750000, 0.000000, 0.000000), r4.xyxx</code></pre><br/>
Код на HLSL:<br/>
<br/>
<pre><code class="cpp">   // * Sample intensity map  
   float2 intensityMap = texture3.Sample( sampler0, colorUV ).xy;  
     
   float intensityInteresting = intensityMap.r;  
   float intensityTraces = intensityMap.g;  
        
   // * Adjust outlines  
   float mainOutlineInteresting = saturate( outlineInteresting - 0.8*intensityInteresting );  
   float mainOutlineTraces = saturate( outlineTraces - 0.75*intensityTraces );</code></pre><br/>
<h4>Серые углы и финальное объединение всего</h4><br/>
Серый цвет ближе к углам вычисляется с помощью скалярного произведения (ассемблерная строка 69):<br/>
<br/>
<pre><code class="cpp">   // * Greyish color  
   float3 color_greyish = dot( color_circle_main, float3(0.3, 0.3, 0.3) ).xxx;</code></pre><br/>
<div style="text-align:center;"><img src="https://4.bp.blogspot.com/-QFIZ2TIMcgs/XKi6RJPXHNI/AAAAAAAABdU/vKYC9Js0C0klw3Sdn0oVL6GPMgrceAAwwCLcBGAs/s1600/color_greyish.jpg" data-src="https://4.bp.blogspot.com/-QFIZ2TIMcgs/XKi6RJPXHNI/AAAAAAAABdU/vKYC9Js0C0klw3Sdn0oVL6GPMgrceAAwwCLcBGAs/s1600/color_greyish.jpg" data-blurred="true"/></div><br/>
Затем идут две интерполяции. Первая комбинирует серый цвет с «цветом в круге» при помощи описанной мной первой маски, поэтому углы становятся серыми. Кроме того, существует коэффициент 0.6, снижающий насыщенность финального изображения:<br/>
<br/>
<div style="text-align:center;"><img src="https://2.bp.blogspot.com/-Rk_oXpawOzI/XKi6Qw1nnXI/AAAAAAAABdQ/2wvoCzvp70QSNBCiXHKaYV09uoC9vSYJgCEwYBhgL/s1600/color_intermediate_01.jpg" data-src="https://2.bp.blogspot.com/-Rk_oXpawOzI/XKi6Qw1nnXI/AAAAAAAABdQ/2wvoCzvp70QSNBCiXHKaYV09uoC9vSYJgCEwYBhgL/s1600/color_intermediate_01.jpg" data-blurred="true"/></div><br/>
Вторая сочетает первый цвет с приведённым выше, используя <i>fisheyeAmount</i>. Это означает, что экран становится постепенно темнее (благодаря умножению на 0.6) и серее по углам! Гениально.<br/>
<br/>
HLSL:<br/>
<br/>
<pre><code class="cpp">   // * Determine main color.  
   // (1) At first, combine "circled" color with gray one.  
   // Now we have have greyish corners here.  
   float3 mainColor = lerp( color_greyish, color_circle_main, mask_gray_corners ) * 0.6;  
     
   // (2) Then mix "regular" color with the above.  
   // Please note this operation makes corners gradually gray (because fisheyeAmount rises from 0 to 1)
   // and gradually darker (because of 0.6 multiplier).  
   mainColor = lerp( color, mainColor, fisheyeAmount );</code></pre><br/>
Теперь мы можем перейти к добавлению контуров объектов.<br/>
<br/>
Цвета (красный и жёлтый) берутся из буфера констант.<br/>
<br/>
<pre><code class="cpp">   // * Determine color of witcher senses  
   float3 senses_traces = mainOutlineTraces * colorTraces;  
   float3 senses_interesting = mainOutlineInteresting * colorInteresting;  
   float3 senses_total = 1.2 * senses_traces + senses_interesting;</code></pre><br/>
<div style="text-align:center;"><img src="https://4.bp.blogspot.com/-B_58cEaYn5E/XKi9BrppHBI/AAAAAAAABd4/hc_1bDKaXDg2Amb6ETOVIYZWaQtOsKGyACLcBGAs/s1600/witcher_senses_total.jpg" data-src="https://4.bp.blogspot.com/-B_58cEaYn5E/XKi9BrppHBI/AAAAAAAABd4/hc_1bDKaXDg2Amb6ETOVIYZWaQtOsKGyACLcBGAs/s1600/witcher_senses_total.jpg" data-blurred="true"/></div><br/>
Фух! Мы почти у финишной черты!<br/>
<br/>
У нас есть окончательный цвет, есть цвет ведьмачьего чутья… осталось их каким-то образом скомбинировать!<br/>
<br/>
И для этого не подойдёт простое сложение. Сначала мы вычисляем скалярное произведение:<br/>
<br/>
<pre><code class="cpp">  78: dp3_sat r0.x, r0.xyzx, l(1.000000, 1.000000, 1.000000, 0.000000)  
   
  float dot_senses_total = saturate( dot(senses_total, float3(1.0, 1.0, 1.0) ) );</code></pre><br/>
которое выглядит вот так:<br/>
<br/>
<div style="text-align:center;"><img src="https://2.bp.blogspot.com/-tb2YvHJCfJk/XKi9BhGVs_I/AAAAAAAABd8/q6PL_3yIS5sWBXcPpDDDKUkIopteYjmgQCEwYBhgL/s1600/witcher_senses_dot.jpg" data-src="https://2.bp.blogspot.com/-tb2YvHJCfJk/XKi9BhGVs_I/AAAAAAAABd8/q6PL_3yIS5sWBXcPpDDDKUkIopteYjmgQCEwYBhgL/s1600/witcher_senses_dot.jpg" data-blurred="true"/></div><br/>
И эти значения в самом конце используются для интерполяции между цветом и (насыщенным) ведьмачьим чутьём:<br/>
<br/>
<pre><code class="cpp">  76: mad r0.xyz, r0.yzwy, l(1.200000, 1.200000, 1.200000, 0.000000), r2.xyzx  
  77: mov_sat r2.xyz, r0.xyzx  
  78: dp3_sat r0.x, r0.xyzx, l(1.000000, 1.000000, 1.000000, 0.000000)  
  79: add r0.yzw, -r1.xxyz, r2.xxyz  
  80: mad o0.xyz, r0.xxxx, r0.yzwy, r1.xyzx  
  81: mov o0.w, l(1.000000)  
  82: ret  
   
   float3 senses_total = 1.2 * senses_traces + senses_interesting;   
     
   // * Final combining  
   float3 senses_total_sat = saturate(senses_total);  
   float dot_senses_total = saturate( dot(senses_total, float3(1.0, 1.0, 1.0) ) );  
        
   float3 finalColor = lerp( mainColor, senses_total_sat, dot_senses_total );  
   return float4( finalColor, 1.0 );</code></pre> <br/>
<div style="text-align:center;"><img src="https://4.bp.blogspot.com/-got60f2XK9Y/XKihDpXA0cI/AAAAAAAABbw/36hozFGj4XszEAa6uD4cZKbowexKxyPYQCEwYBhgL/s1600/after.jpg" data-src="https://4.bp.blogspot.com/-got60f2XK9Y/XKihDpXA0cI/AAAAAAAABbw/36hozFGj4XszEAa6uD4cZKbowexKxyPYQCEwYBhgL/s1600/after.jpg" data-blurred="true"/></div><br/>
И на этом всё.<br/>
<br/>
Полный шейдер выложен <a href="https://pastebin.com/zwFtbhQU">здесь</a>.<br/>
<br/>
Сравнение моего (слева) и оригинального (справа) шейдеров:<br/>
<br/>
<div style="text-align:center;"><img src="https://1.bp.blogspot.com/-6vXTjktgkww/XKi-HvZhYxI/AAAAAAAABeE/Wf4xgoxRoRwo8duWmLidw4BP_5ALZPgtgCLcBGAs/s1600/comparison.JPG"/></div><br/>
Надеюсь, вам понравилась эта статья! В механиках «ведьмачьего чутья» есть множество блестящих идей, а готовый результат очень правдоподобен.<br/>
<br/>
[Предыдущие части анализа: <a href="https://habr.com/ru/post/422573/">первая</a> и <a href="https://habr.com/ru/post/437100/">вторая</a>.]</div></div> <!----> <!----></div> <div class="tm-article-presenter__meta"><div class="tm-separated-list tm-article-presenter__meta-list"><span class="tm-separated-list__title">Теги:</span> <ul class="tm-separated-list__list"><li class="tm-separated-list__item"><a href="/ru/search/?target_type=posts&amp;order=relevance&amp;q=%5B%D1%80%D0%B5%D0%BD%D0%B4%D0%B5%D1%80%D0%B8%D0%BD%D0%B3%5D" class="tm-tags-list__link">рендеринг</a></li><li class="tm-separated-list__item"><a href="/ru/search/?target_type=posts&amp;order=relevance&amp;q=%5B%D0%BA%D0%BE%D0%BD%D0%B2%D0%B5%D0%B9%D0%B5%D1%80%20%D1%80%D0%B5%D0%BD%D0%B4%D0%B5%D1%80%D0%B8%D0%BD%D0%B3%D0%B0%5D" class="tm-tags-list__link">конвейер рендеринга</a></li><li class="tm-separated-list__item"><a href="/ru/search/?target_type=posts&amp;order=relevance&amp;q=%5B%D1%88%D0%B5%D0%B9%D0%B4%D0%B5%D1%80%D1%8B%5D" class="tm-tags-list__link">шейдеры</a></li><li class="tm-separated-list__item"><a href="/ru/search/?target_type=posts&amp;order=relevance&amp;q=%5B%D0%BF%D0%B8%D0%BA%D1%81%D0%B5%D0%BB%D1%8C%D0%BD%D1%8B%D0%B9%20%D1%88%D0%B5%D0%B9%D0%B4%D0%B5%D1%80%5D" class="tm-tags-list__link">пиксельный шейдер</a></li><li class="tm-separated-list__item"><a href="/ru/search/?target_type=posts&amp;order=relevance&amp;q=%5Brenderdoc%5D" class="tm-tags-list__link">renderdoc</a></li><li class="tm-separated-list__item"><a href="/ru/search/?target_type=posts&amp;order=relevance&amp;q=%5Bwitcher%203%5D" class="tm-tags-list__link">witcher 3</a></li><li class="tm-separated-list__item"><a href="/ru/search/?target_type=posts&amp;order=relevance&amp;q=%5B%D0%B2%D0%B5%D0%B4%D1%8C%D0%BC%D0%B0%D0%BA%203%5D" class="tm-tags-list__link">ведьмак 3</a></li><li class="tm-separated-list__item"><a href="/ru/search/?target_type=posts&amp;order=relevance&amp;q=%5Bhlsl%5D" class="tm-tags-list__link">hlsl</a></li><li class="tm-separated-list__item"><a href="/ru/search/?target_type=posts&amp;order=relevance&amp;q=%5Bdirectx%5D" class="tm-tags-list__link">directx</a></li></ul></div> <div class="tm-separated-list tm-article-presenter__meta-list"><span class="tm-separated-list__title">Хабы:</span> <ul class="tm-separated-list__list"><li class="tm-separated-list__item"><a href="/ru/hub/3d_graphics/" class="tm-hubs-list__link">
    Работа с 3D-графикой
  </a></li><li class="tm-separated-list__item"><a href="/ru/hub/gamedev/" class="tm-hubs-list__link">
    Разработка игр
  </a></li><li class="tm-separated-list__item"><a href="/ru/hub/reverse-engineering/" class="tm-hubs-list__link">
    Реверс-инжиниринг
  </a></li><li class="tm-separated-list__item"><a href="/ru/hub/game_design/" class="tm-hubs-list__link">
    Дизайн игр
  </a></li></ul></div></div></article></div> <!----></div> <div class="tm-article-sticky-panel"><div class="tm-data-icons tm-article-sticky-panel__icons"><div class="tm-article-rating tm-data-icons__item"><div class="tm-votes-meter tm-article-rating__votes-switcher"><svg height="16" width="16" class="tm-svg-img tm-votes-meter__icon tm-votes-meter__icon_medium"><title>Всего голосов 48: ↑48 и ↓0</title> <use xlink:href="/img/megazord-v24.ce74655c.svg#counter-rating"></use></svg> <span title="Всего голосов 48: ↑48 и ↓0" class="tm-votes-meter__value tm-votes-meter__value_positive tm-votes-meter__value_medium">+48</span></div> <DIV class="v-portal" style="display:none;"></DIV></div> <!----> <span title="Количество просмотров" class="tm-icon-counter tm-data-icons__item"><svg height="16" width="16" class="tm-svg-img tm-icon-counter__icon"><title>Просмотры</title> <use xlink:href="/img/megazord-v24.ce74655c.svg#counter-views"></use></svg> <span class="tm-icon-counter__value">28K</span></span> <button title="Добавить в закладки" type="button" class="bookmarks-button tm-data-icons__item"><span title="Добавить в закладки" class="tm-svg-icon__wrapper bookmarks-button__icon"><svg height="16" width="16" class="tm-svg-img tm-svg-icon"><title>Добавить в закладки</title> <use xlink:href="/img/megazord-v24.ce74655c.svg#counter-favorite"></use></svg></span> <span title="Количество пользователей, добавивших публикацию в закладки" class="bookmarks-button__counter">
    138
  </span></button> <!----> <div title="Поделиться" class="tm-sharing tm-data-icons__item"><button type="button" class="tm-sharing__button"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" class="tm-sharing__icon"><path fill="currentColor" d="M10.33.275l9.047 7.572a.2.2 0 010 .306l-9.048 7.572a.2.2 0 01-.328-.153V11c-8 0-9.94 6-9.94 6S-1 5 10 5V.428a.2.2 0 01.328-.153z"></path></svg></button> <!----></div> <DIV class="v-portal" style="display:none;"></DIV></div> </div></div> <!----> <!----> <div class="tm-article-presenter__footer"><div class="tm-article-blocks"><!----> <section class="tm-block tm-block_spacing-bottom"><!----> <div class="tm-block__body tm-block__body_variant-balanced"><div class="tm-article-author"> <div class="tm-user-card tm-article-author__user-card tm-user-card_variant-article"><div class="tm-user-card__info-container"><div class="tm-user-card__header"><div class="tm-user-card__header-data"><a href="/ru/users/PatientZero/" class="tm-user-card__userpic tm-user-card__userpic_size-40"><div class="tm-entity-image"><img alt="" src="//habrastorage.org/getpro/habr/avatars/8de/9c5/34a/8de9c534a18a6cb8693270a2b528d4c0.png" class="tm-entity-image__pic"></div></a> <div class="tm-user-card__meta"><div title=" 1325 голосов " class="tm-karma tm-user-card__karma"><div class="tm-karma__votes tm-karma__votes_positive">
    1197
  </div> <div class="tm-karma__text">
    Карма
  </div></div> <div title="Рейтинг пользователя" class="tm-rating tm-user-card__rating"><div class="tm-rating__header"> <div class="tm-rating__counter">82</div></div> <div class="tm-rating__text">
    Рейтинг
  </div></div></div></div></div> <div class="tm-user-card__info tm-user-card__info_variant-article"><div class="tm-user-card__title tm-user-card__title_variant-article"><!----> <a href="/ru/users/PatientZero/" class="tm-user-card__nickname tm-user-card__nickname_variant-article">
          @PatientZero
        </a> <!----></div> <p class="tm-user-card__short-info tm-user-card__short-info_variant-article">Переводчик-фрилансер</p></div></div> <div class="tm-user-card__buttons tm-user-card__buttons_variant-article"><!----> <!----> <button type="submit" class="tm-user-card__button btn btn_transparent btn_small">
      Задонатить
    </button> <!----> <!----></div></div> <!----></div> <DIV class="v-portal" style="display:none;"></DIV></div> <!----></section> <div class="tm-article-blocks__comments"><div class="tm-article-page-comments"><div class="tm-article-comments-counter-link tm-article-comments-counter-button"><a href="/ru/post/450332/comments/" class="tm-article-comments-counter-link__link tm-article-comments-counter-link__link_button-style"><svg height="16" width="16" class="tm-svg-img tm-article-comments-counter-link__icon tm-article-comments-counter-link__icon_contrasted"><title>Комментарии</title> <use xlink:href="/img/megazord-v24.ce74655c.svg#counter-comments"></use></svg> <span class="tm-article-comments-counter-link__value tm-article-comments-counter-link__value_contrasted">
       Комментарии 2 
    </span></a> <!----></div></div></div> <div class="tm-ad-banner__container tm-page-article__banner"><!----> <div id="articleBottomBanner" class="tm-ad-banner"></div></div> <!----> <!----> <!----> <!----> </div></div></div></div></div> <div class="tm-page__sidebar"><div class="tm-layout-sidebar"><div class="tm-layout-sidebar__ads tm-layout-sidebar__ads_initial"><div class="tm-ad-banner__container tm-layout-sidebar__banner"><!----> <div id="sidebarBanner" class="tm-ad-banner"></div></div></div> <div class="tm-sexy-sidebar tm-sexy-sidebar_initial" style="margin-top:0px;"><!----> <!----></div></div></div></div></div></div></main> <!----></div> <div class="tm-footer-menu"><div class="tm-page-width"><div class="tm-footer-menu__container"><div class="tm-footer-menu__block"><h3 class="tm-footer-menu__block-title">
          Ваш аккаунт
        </h3> <div class="tm-footer-menu__block-content"><ul class="tm-footer-menu__list"><li class="tm-footer-menu__list-item"><a href="/kek/v1/auth/habrahabr/?back=/ru/post/450332/&amp;hl=ru" rel="nofollow" target="_self">
                Войти
              </a></li><li class="tm-footer-menu__list-item"><a href="/kek/v1/auth/habrahabr-register/?back=/ru/post/450332/&amp;hl=ru" rel="nofollow" target="_self">
                Регистрация
              </a></li></ul></div></div><div class="tm-footer-menu__block"><h3 class="tm-footer-menu__block-title">
          Разделы
        </h3> <div class="tm-footer-menu__block-content"><ul class="tm-footer-menu__list"><li class="tm-footer-menu__list-item"><a href="/ru/" class="footer-menu__item-link router-link-active">
                Публикации
              </a></li><li class="tm-footer-menu__list-item"><a href="/ru/news/" class="footer-menu__item-link">
                Новости
              </a></li><li class="tm-footer-menu__list-item"><a href="/ru/hubs/" class="footer-menu__item-link">
                Хабы
              </a></li><li class="tm-footer-menu__list-item"><a href="/ru/companies/" class="footer-menu__item-link">
                Компании
              </a></li><li class="tm-footer-menu__list-item"><a href="/ru/users/" class="footer-menu__item-link">
                Авторы
              </a></li><li class="tm-footer-menu__list-item"><a href="/ru/sandbox/" class="footer-menu__item-link">
                Песочница
              </a></li></ul></div></div><div class="tm-footer-menu__block"><h3 class="tm-footer-menu__block-title">
          Информация
        </h3> <div class="tm-footer-menu__block-content"><ul class="tm-footer-menu__list"><li class="tm-footer-menu__list-item"><a href="/ru/docs/help/" class="footer-menu__item-link">
                Устройство сайта
              </a></li><li class="tm-footer-menu__list-item"><a href="/ru/docs/authors/codex/" class="footer-menu__item-link">
                Для авторов
              </a></li><li class="tm-footer-menu__list-item"><a href="/ru/docs/companies/corpblogs/" class="footer-menu__item-link">
                Для компаний
              </a></li><li class="tm-footer-menu__list-item"><a href="/ru/docs/docs/transparency/" class="footer-menu__item-link">
                Документы
              </a></li><li class="tm-footer-menu__list-item"><a href="https://account.habr.com/info/agreement" target="_blank">
                Соглашение
              </a></li><li class="tm-footer-menu__list-item"><a href="https://account.habr.com/info/confidential/" target="_blank">
                Конфиденциальность
              </a></li></ul></div></div><div class="tm-footer-menu__block"><h3 class="tm-footer-menu__block-title">
          Услуги
        </h3> <div class="tm-footer-menu__block-content"><ul class="tm-footer-menu__list"><li class="tm-footer-menu__list-item"><a href="https://docs.google.com/presentation/d/e/2PACX-1vQLwRfQmXibiUlWaRg-BAc38s7oM3lJiaPju7qmdJsp8ysIvZ_G-Npem0njJLMozE2bPHMpDqiI5hhy/pub?start=false&amp;loop=false&amp;delayms=60000&amp;slide=id.g91a03369cd_4_297" target="_blank">
                Реклама
              </a></li><li class="tm-footer-menu__list-item"><a href="https://habrastorage.org/storage/stuff/habr/service_price.pdf" target="_blank">
                Тарифы
              </a></li><li class="tm-footer-menu__list-item"><a href="https://docs.google.com/presentation/d/e/2PACX-1vQJJds8-Di7BQSP_guHxICN7woVYoN5NP_22ra-BIo4bqnTT9FR6fB-Ku2P0AoRpX0Ds-LRkDeAoD8F/pub?start=false&amp;loop=false&amp;delayms=60000" target="_blank">
                Контент
              </a></li><li class="tm-footer-menu__list-item"><a href="https://tmtm.timepad.ru/" target="_blank">
                Семинары
              </a></li><li class="tm-footer-menu__list-item"><a href="/ru/megaprojects/" class="footer-menu__item-link">
                Мегапроекты
              </a></li></ul></div></div></div></div></div> <div class="tm-footer"><div class="tm-page-width"><div class="tm-footer__container"><!----> <div class="tm-footer__social"><a href="https://www.facebook.com/habrahabr.ru" rel="nofollow noopener noreferrer" target="_blank" class="tm-svg-icon__wrapper tm-social-icons__icon"><svg height="16" width="16" class="tm-svg-img tm-svg-icon"><title>Facebook</title> <use xlink:href="/img/social-icons-sprite.svg#social-logo-facebook"></use></svg></a><a href="https://twitter.com/habr_com" rel="nofollow noopener noreferrer" target="_blank" class="tm-svg-icon__wrapper tm-social-icons__icon"><svg height="16" width="16" class="tm-svg-img tm-svg-icon"><title>Twitter</title> <use xlink:href="/img/social-icons-sprite.svg#social-logo-twitter"></use></svg></a><a href="https://vk.com/habr" rel="nofollow noopener noreferrer" target="_blank" class="tm-svg-icon__wrapper tm-social-icons__icon"><svg height="16" width="16" class="tm-svg-img tm-svg-icon"><title>VK</title> <use xlink:href="/img/social-icons-sprite.svg#social-logo-vkontakte"></use></svg></a><a href="https://telegram.me/habr_com" rel="nofollow noopener noreferrer" target="_blank" class="tm-svg-icon__wrapper tm-social-icons__icon"><svg height="16" width="16" class="tm-svg-img tm-svg-icon"><title>Telegram</title> <use xlink:href="/img/social-icons-sprite.svg#social-logo-telegram"></use></svg></a><a href="https://www.youtube.com/channel/UCd_sTwKqVrweTt4oAKY5y4w" rel="nofollow noopener noreferrer" target="_blank" class="tm-svg-icon__wrapper tm-social-icons__icon"><svg height="16" width="16" class="tm-svg-img tm-svg-icon"><title>Youtube</title> <use xlink:href="/img/social-icons-sprite.svg#social-logo-youtube"></use></svg></a><a href="https://zen.yandex.ru/habr" rel="nofollow noopener noreferrer" target="_blank" class="tm-svg-icon__wrapper tm-social-icons__icon"><svg height="16" width="16" class="tm-svg-img tm-svg-icon"><title>Яндекс Дзен</title> <use xlink:href="/img/social-icons-sprite.svg#social-logo-zen"></use></svg></a></div> <DIV class="v-portal" style="display:none;"></DIV> <button class="tm-footer__link"><!---->
        Настройка языка
      </button> <a href="/ru/about" class="tm-footer__link">
        О сайте
      </a> <a href="/ru/feedback/" class="tm-footer__link">
        Техническая поддержка
      </a> <!----> <a href="/berserk-mode-nope" class="tm-footer__link">
        Вернуться на старую версию
      </a> <div class="tm-footer-copyright"><span class="tm-copyright"><span class="tm-copyright__years">© 2006–2021 </span> <span class="tm-copyright__name">«<a href="https://company.habr.com/" rel="noopener" target="_blank" class="tm-copyright__link">Habr</a>»</span></span></div></div></div></div> <!----> <!----></div> <div class="vue-portal-target"></div></div>
<script>window.__INITIAL_STATE__={"adblock":{"hasAcceptableAdsFilter":false,"hasAdblock":false},"articlesList":{"articlesList":{"450332":{"id":"450332","timePublished":"2019-05-03T12:58:39+00:00","isCorporative":false,"lang":"ru","titleHtml":"Как реализован рендеринг «Ведьмака 3»: молнии, ведьмачье чутьё и другие эффекты","leadData":{"textHtml":"\u003Cdiv style=\"text-align:center;\"\u003E\u003Cimg  src=\"https:\u002F\u002F4.bp.blogspot.com\u002F-got60f2XK9Y\u002FXKihDpXA0cI\u002FAAAAAAAABbw\u002F36hozFGj4XszEAa6uD4cZKbowexKxyPYQCEwYBhgL\u002Fs1600\u002Fafter.jpg\" alt=\"image\"\u002F\u003E\u003C\u002Fdiv\u003E\u003Cbr\u002F\u003E\r\n\u003Ch2\u003EЧасть 1. Молнии\u003C\u002Fh2\u003E\u003Cbr\u002F\u003E\r\nВ этой части мы рассмотрим процесс рендеринга молний в Witcher 3: Wild Hunt.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nРендеринг молний выполняется немного позже эффекта \u003Ca href=\"https:\u002F\u002Fastralcode.blogspot.com\u002F2019\u002F01\u002Freverse-engineering-rendering-of.html\"\u003Eзанавес дождя\u003C\u002Fa\u003E, но всё равно происходит в проходе прямого рендеринга. Молнии можно увидеть на этом видео:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cdiv class=\"oembed\"\u003E\u003Cdiv\u003E\u003Cdiv style=\"left: 0; width: 100%; height: 0; position: relative; padding-bottom: 56.2493%;\"\u003E\u003Ciframe src=\"https:\u002F\u002Fwww.youtube.com\u002Fembed\u002FVXt4PEEqV2k?rel=0&amp;showinfo=1&amp;hl=en-US\" style=\"border: 0; top: 0; left: 0; width: 100%; height: 100%; position: absolute;\" allowfullscreen scrolling=\"no\"\u003E\u003C\u002Fiframe\u003E\u003C\u002Fdiv\u003E\u003C\u002Fdiv\u003E\u003C\u002Fdiv\u003E\u003Cbr\u002F\u003E\r\nОни очень быстро исчезают, поэтому лучше просматривать видео на скорости 0.25.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nМожно увидеть, что это не статичные изображения; со временем их яркость слегка меняется.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nС точки зрения нюансов рендеринга здесь есть очень много сходств с отрисовкой занавес дождя в отдалении, например, такие же состояния смешивания (аддитивное смешивание) и глубины (проверка включена, запись глубин не выполняется).\u003Cbr\u002F\u003E\r\n","imageUrl":null,"buttonTextHtml":null,"image":null},"editorVersion":"1.0","postType":"article","postLabels":[{"type":"translation","data":{"originalAuthorName":"Mateusz Nagórka","originalUrl":"http:\u002F\u002Fastralcode.blogspot.com\u002F2019\u002F03\u002Freverse-engineering-rendering-of.html"}}],"author":{"scoreStats":{"score":1197,"votesCount":1325},"rating":82,"relatedData":null,"contacts":[],"authorContacts":[],"paymentDetails":{"paymentYandexMoney":"410013829899665","paymentPayPalMe":"vadimivshin","paymentWebmoney":null},"id":"78894","alias":"PatientZero","fullname":null,"avatarUrl":"\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Favatars\u002F8de\u002F9c5\u002F34a\u002F8de9c534a18a6cb8693270a2b528d4c0.png","speciality":"Переводчик-фрилансер"},"statistics":{"commentsCount":2,"favoritesCount":138,"readingCount":27778,"score":48,"votesCount":48},"hubs":[{"relatedData":null,"id":"643","alias":"3d_graphics","type":"collective","title":"Работа с 3D-графикой","titleHtml":"Работа с 3D-графикой","isProfiled":true},{"relatedData":null,"id":"7773","alias":"gamedev","type":"collective","title":"Разработка игр","titleHtml":"Разработка игр","isProfiled":true},{"relatedData":null,"id":"19011","alias":"reverse-engineering","type":"collective","title":"Реверс-инжиниринг","titleHtml":"Реверс-инжиниринг","isProfiled":true},{"relatedData":null,"id":"20800","alias":"game_design","type":"collective","title":"Дизайн игр","titleHtml":"Дизайн игр","isProfiled":true}],"flows":[{"id":"1","alias":"develop","title":"Разработка"},{"id":"2","alias":"design","title":"Дизайн"}],"relatedData":null,"textHtml":"\u003Cdiv xmlns=\"http:\u002F\u002Fwww.w3.org\u002F1999\u002Fxhtml\"\u003E\u003Cdiv style=\"text-align:center;\"\u003E\u003Cimg src=\"https:\u002F\u002F4.bp.blogspot.com\u002F-got60f2XK9Y\u002FXKihDpXA0cI\u002FAAAAAAAABbw\u002F36hozFGj4XszEAa6uD4cZKbowexKxyPYQCEwYBhgL\u002Fs1600\u002Fafter.jpg\" alt=\"image\" data-src=\"https:\u002F\u002F4.bp.blogspot.com\u002F-got60f2XK9Y\u002FXKihDpXA0cI\u002FAAAAAAAABbw\u002F36hozFGj4XszEAa6uD4cZKbowexKxyPYQCEwYBhgL\u002Fs1600\u002Fafter.jpg\" data-blurred=\"true\"\u002F\u003E\u003C\u002Fdiv\u003E\u003Cbr\u002F\u003E\r\n\u003Ch2\u003EЧасть 1. Молнии\u003C\u002Fh2\u003E\u003Cbr\u002F\u003E\r\nВ этой части мы рассмотрим процесс рендеринга молний в Witcher 3: Wild Hunt.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nРендеринг молний выполняется немного позже эффекта \u003Ca href=\"https:\u002F\u002Fastralcode.blogspot.com\u002F2019\u002F01\u002Freverse-engineering-rendering-of.html\"\u003Eзанавес дождя\u003C\u002Fa\u003E, но всё равно происходит в проходе прямого рендеринга. Молнии можно увидеть на этом видео:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cdiv class=\"oembed\"\u003E\u003Cdiv\u003E\u003Cdiv style=\"left: 0; width: 100%; height: 0; position: relative; padding-bottom: 56.2493%;\"\u003E\u003Cdiv class=\"tm-iframe_temp\" data-src=\"https:\u002F\u002Fwww.youtube.com\u002Fembed\u002FVXt4PEEqV2k?rel=0&amp;showinfo=1&amp;hl=en-US\" data-style=\"border: 0; top: 0; left: 0; width: 100%; height: 100%; position: absolute;\" id=\"\" width=\"\"\u003E\u003C\u002Fdiv\u003E\u003C\u002Fdiv\u003E\u003C\u002Fdiv\u003E\u003C\u002Fdiv\u003E\u003Cbr\u002F\u003E\r\nОни очень быстро исчезают, поэтому лучше просматривать видео на скорости 0.25.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nМожно увидеть, что это не статичные изображения; со временем их яркость слегка меняется.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nС точки зрения нюансов рендеринга здесь есть очень много сходств с отрисовкой занавес дождя в отдалении, например, такие же состояния смешивания (аддитивное смешивание) и глубины (проверка включена, запись глубин не выполняется).\u003Cbr\u002F\u003E\r\n\u003Ca name=\"habracut\"\u003E\u003C\u002Fa\u003E\u003Cbr\u002F\u003E\r\n\u003Cdiv style=\"text-align:center;\"\u003E\u003Cimg src=\"https:\u002F\u002F4.bp.blogspot.com\u002F-5es7NCJkWgA\u002FXHzXwxzzwKI\u002FAAAAAAAABS4\u002FEuUafquFSooo7fWjCaohDvKVlRDHZoNLgCLcBGAs\u002Fs1600\u002F02_before.jpg\" data-src=\"https:\u002F\u002F4.bp.blogspot.com\u002F-5es7NCJkWgA\u002FXHzXwxzzwKI\u002FAAAAAAAABS4\u002FEuUafquFSooo7fWjCaohDvKVlRDHZoNLgCLcBGAs\u002Fs1600\u002F02_before.jpg\" data-blurred=\"true\"\u002F\u003E\u003C\u002Fdiv\u003E\u003Cbr\u002F\u003E\r\n\u003Ci\u003EСцена без молнии\u003C\u002Fi\u003E\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cdiv style=\"text-align:center;\"\u003E\u003Cimg src=\"https:\u002F\u002F3.bp.blogspot.com\u002F-0NvAFDUK8AA\u002FXHzXw71T-nI\u002FAAAAAAAABS0\u002FimLLd1Ru6MQLoinlqqge-6OSp5QRwZo4QCLcBGAs\u002Fs1600\u002F03_after.jpg\" data-src=\"https:\u002F\u002F3.bp.blogspot.com\u002F-0NvAFDUK8AA\u002FXHzXw71T-nI\u002FAAAAAAAABS0\u002FimLLd1Ru6MQLoinlqqge-6OSp5QRwZo4QCLcBGAs\u002Fs1600\u002F03_after.jpg\" data-blurred=\"true\"\u002F\u003E\u003C\u002Fdiv\u003E\u003Cbr\u002F\u003E\r\n\u003Ci\u003EСцена с молнией\u003C\u002Fi\u003E\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nС точки зрения геометрии молнии в «Ведьмаке 3» — это древоподобные меши. Данный пример молнии представлен следующим мешем:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cdiv style=\"text-align:center;\"\u003E\u003Cimg src=\"https:\u002F\u002F1.bp.blogspot.com\u002F-gLuV3RWUQD4\u002FXHzYBCYC8sI\u002FAAAAAAAABTE\u002Fl9VnSVyp9b4GGeiGWvTBDg2E3Rc79RUrQCLcBGAs\u002Fs1600\u002F01_geometry.JPG\"\u002F\u003E\u003C\u002Fdiv\u003E\u003Cbr\u002F\u003E\r\nОн имеет UV-координаты и векторы нормалей. Всё это пригодится на этапе вершинного шейдера.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Ch3\u003EВершинный шейдер\u003C\u002Fh3\u003E\u003Cbr\u002F\u003E\r\nДавайте взглянем на ассемблерный код вершинного шейдера:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"cpp\"\u003E vs_5_0  \n    dcl_globalFlags refactoringAllowed  \n    dcl_constantbuffer cb1[9], immediateIndexed  \n    dcl_constantbuffer cb2[6], immediateIndexed  \n    dcl_input v0.xyz  \n    dcl_input v1.xy  \n    dcl_input v2.xyz  \n    dcl_input v4.xyzw  \n    dcl_input v5.xyzw  \n    dcl_input v6.xyzw  \n    dcl_input v7.xyzw  \n    dcl_output o0.xy  \n    dcl_output o1.xyzw  \n    dcl_output_siv o2.xyzw, position  \n    dcl_temps 3  \n   0: mov o0.xy, v1.xyxx  \n   1: mov o1.xyzw, v7.xyzw  \n   2: mul r0.xyzw, v5.xyzw, cb1[0].yyyy  \n   3: mad r0.xyzw, v4.xyzw, cb1[0].xxxx, r0.xyzw  \n   4: mad r0.xyzw, v6.xyzw, cb1[0].zzzz, r0.xyzw  \n   5: mad r0.xyzw, cb1[0].wwww, l(0.000000, 0.000000, 0.000000, 1.000000), r0.xyzw  \n   6: mov r1.w, l(1.000000)  \n   7: mad r1.xyz, v0.xyzx, cb2[4].xyzx, cb2[5].xyzx  \n   8: dp4 r2.x, r1.xyzw, v4.xyzw  \n   9: dp4 r2.y, r1.xyzw, v5.xyzw  \n  10: dp4 r2.z, r1.xyzw, v6.xyzw  \n  11: add r2.xyz, r2.xyzx, -cb1[8].xyzx  \n  12: dp3 r1.w, r2.xyzx, r2.xyzx  \n  13: rsq r1.w, r1.w  \n  14: div r1.w, l(1.000000, 1.000000, 1.000000, 1.000000), r1.w  \n  15: mul r1.w, r1.w, l(0.000001)  \n  16: mad r2.xyz, v2.xyzx, l(2.000000, 2.000000, 2.000000, 0.000000), l(-1.000000, -1.000000, -1.000000, 0.000000)  \n  17: mad r1.xyz, r2.xyzx, r1.wwww, r1.xyzx  \n  18: mov r1.w, l(1.000000)  \n  19: dp4 o2.x, r1.xyzw, r0.xyzw  \n  20: mul r0.xyzw, v5.xyzw, cb1[1].yyyy  \n  21: mad r0.xyzw, v4.xyzw, cb1[1].xxxx, r0.xyzw  \n  22: mad r0.xyzw, v6.xyzw, cb1[1].zzzz, r0.xyzw  \n  23: mad r0.xyzw, cb1[1].wwww, l(0.000000, 0.000000, 0.000000, 1.000000), r0.xyzw  \n  24: dp4 o2.y, r1.xyzw, r0.xyzw  \n  25: mul r0.xyzw, v5.xyzw, cb1[2].yyyy  \n  26: mad r0.xyzw, v4.xyzw, cb1[2].xxxx, r0.xyzw  \n  27: mad r0.xyzw, v6.xyzw, cb1[2].zzzz, r0.xyzw  \n  28: mad r0.xyzw, cb1[2].wwww, l(0.000000, 0.000000, 0.000000, 1.000000), r0.xyzw  \n  29: dp4 o2.z, r1.xyzw, r0.xyzw  \n  30: mul r0.xyzw, v5.xyzw, cb1[3].yyyy  \n  31: mad r0.xyzw, v4.xyzw, cb1[3].xxxx, r0.xyzw  \n  32: mad r0.xyzw, v6.xyzw, cb1[3].zzzz, r0.xyzw  \n  33: mad r0.xyzw, cb1[3].wwww, l(0.000000, 0.000000, 0.000000, 1.000000), r0.xyzw  \n  34: dp4 o2.w, r1.xyzw, r0.xyzw  \n  35: ret\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E \u003Cbr\u002F\u003E\r\nЗдесь есть много сходств с вершинным шейдером занавес дождя, поэтому я не буду повторяться. Хочу показать вам важное отличие, которое есть в строках 11-18:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"cpp\"\u003E  11: add r2.xyz, r2.xyzx, -cb1[8].xyzx  \n  12: dp3 r1.w, r2.xyzx, r2.xyzx  \n  13: rsq r1.w, r1.w  \n  14: div r1.w, l(1.000000, 1.000000, 1.000000, 1.000000), r1.w  \n  15: mul r1.w, r1.w, l(0.000001)  \n  16: mad r2.xyz, v2.xyzx, l(2.000000, 2.000000, 2.000000, 0.000000), l(-1.000000, -1.000000, -1.000000, 0.000000)  \n  17: mad r1.xyz, r2.xyzx, r1.wwww, r1.xyzx  \n  18: mov r1.w, l(1.000000)  \n  19: dp4 o2.x, r1.xyzw, r0.xyzw\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nВо-первых, cb1[8].xyz — это позиция камеры, а r2.xyz позиция в мировом пространстве, то есть строка 11 вычисляет вектор из камеры к позиции в мире. Затем строки 12-15 вычисляют \u003Ci\u003Elength( worldPos — cameraPos) * 0.000001.\u003C\u002Fi\u003E\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nv2.xyz — это вектор нормали входящей геометрии. Строка 16 расширяет его из интервала [0-1] до интервала [-1;1].\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nЗатем вычисляется конечная позиция в мире:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Ci\u003EfinalWorldPos = worldPos + length( worldPos — cameraPos) * 0.000001 * normalVector\u003C\u002Fi\u003E\u003Cbr\u002F\u003E\r\nФрагмент кода HLSL для этой операции будет примерно таким:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"cpp\"\u003E      ...  \n      \u002F\u002F final world-space position  \n      float3 vNormal = Input.NormalW * 2.0 - 1.0;  \n      float lencameratoworld = length( PositionL - g_cameraPos.xyz) * 0.000001;  \n   \n      PositionL += vNormal*lencameratoworld;  \n   \n      \u002F\u002F SV_Posiiton   \n      float4x4 matModelViewProjection = mul(g_viewProjMatrix, matInstanceWorld );   \n      Output.PositionH = mul( float4(PositionL, 1.0), transpose(matModelViewProjection) );      \n   \n      return Output;\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nЭта операция приводит к небольшому «взрыву» меша (в направлении вектора нормали). Я поэкспериментировал, заменив 0.000001 на несколько других значений. Вот результаты:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cdiv style=\"text-align:center;\"\u003E\u003Cimg src=\"https:\u002F\u002F3.bp.blogspot.com\u002F-04VBXtCtToU\u002FXHzeCdlnGzI\u002FAAAAAAAABTQ\u002FJfj--N3P6qwJdWydT2uUiWtrifmPdyKPgCEwYBhgL\u002Fs1600\u002F04_value_0.000002.jpg\" data-src=\"https:\u002F\u002F3.bp.blogspot.com\u002F-04VBXtCtToU\u002FXHzeCdlnGzI\u002FAAAAAAAABTQ\u002FJfj--N3P6qwJdWydT2uUiWtrifmPdyKPgCEwYBhgL\u002Fs1600\u002F04_value_0.000002.jpg\" data-blurred=\"true\"\u002F\u003E\u003C\u002Fdiv\u003E\u003Cbr\u002F\u003E\r\n\u003Ci\u003E0.000002\u003C\u002Fi\u003E\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cdiv style=\"text-align:center;\"\u003E\u003Cimg src=\"https:\u002F\u002F2.bp.blogspot.com\u002F-URy-AsVMJ08\u002FXHzeCaZEkvI\u002FAAAAAAAABTU\u002FMisCn2gjCSIsTKrqMU3FXTe8DBPCKguhwCEwYBhgL\u002Fs1600\u002F05_value_0.000005.jpg\" data-src=\"https:\u002F\u002F2.bp.blogspot.com\u002F-URy-AsVMJ08\u002FXHzeCaZEkvI\u002FAAAAAAAABTU\u002FMisCn2gjCSIsTKrqMU3FXTe8DBPCKguhwCEwYBhgL\u002Fs1600\u002F05_value_0.000005.jpg\" data-blurred=\"true\"\u002F\u003E\u003C\u002Fdiv\u003E\u003Cbr\u002F\u003E\r\n\u003Ci\u003E0.000005\u003C\u002Fi\u003E\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cdiv style=\"text-align:center;\"\u003E\u003Cimg src=\"https:\u002F\u002F2.bp.blogspot.com\u002F-dckY8djA4Z4\u002FXHzeCprPZjI\u002FAAAAAAAABTY\u002FO4ZXF2miPNs30zuuvAi1wFFvKff2_F17gCEwYBhgL\u002Fs1600\u002F06_value_0.00001.jpg\" data-src=\"https:\u002F\u002F2.bp.blogspot.com\u002F-dckY8djA4Z4\u002FXHzeCprPZjI\u002FAAAAAAAABTY\u002FO4ZXF2miPNs30zuuvAi1wFFvKff2_F17gCEwYBhgL\u002Fs1600\u002F06_value_0.00001.jpg\" data-blurred=\"true\"\u002F\u003E\u003C\u002Fdiv\u003E\u003Cbr\u002F\u003E\r\n\u003Ci\u003E0.00001\u003C\u002Fi\u003E\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cdiv style=\"text-align:center;\"\u003E\u003Cimg src=\"https:\u002F\u002F1.bp.blogspot.com\u002F-xBxlg15e6jI\u002FXHzeDUvtImI\u002FAAAAAAAABTc\u002FWpJ_MwAaQvIgfHj98Z-43cKQd4vVijg-wCEwYBhgL\u002Fs1600\u002F07_value_0.000025.jpg\" data-src=\"https:\u002F\u002F1.bp.blogspot.com\u002F-xBxlg15e6jI\u002FXHzeDUvtImI\u002FAAAAAAAABTc\u002FWpJ_MwAaQvIgfHj98Z-43cKQd4vVijg-wCEwYBhgL\u002Fs1600\u002F07_value_0.000025.jpg\" data-blurred=\"true\"\u002F\u003E\u003C\u002Fdiv\u003E\u003Cbr\u002F\u003E\r\n\u003Ci\u003E0.000025\u003C\u002Fi\u003E\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Ch3\u003EПиксельный шейдер\u003C\u002Fh3\u003E\u003Cbr\u002F\u003E\r\nОтлично, мы разобрались с вершинным шейдером, теперь пора взяться за ассемблерный код пиксельного шейдера!\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"cpp\"\u003E ps_5_0  \n    dcl_globalFlags refactoringAllowed  \n    dcl_constantbuffer cb0[1], immediateIndexed  \n    dcl_constantbuffer cb2[3], immediateIndexed  \n    dcl_constantbuffer cb4[5], immediateIndexed  \n    dcl_input_ps linear v0.x  \n    dcl_input_ps linear v1.w  \n    dcl_output o0.xyzw  \n    dcl_temps 1  \n   0: mad r0.x, cb0[0].x, cb4[4].x, v0.x  \n   1: add r0.y, r0.x, l(-1.000000)  \n   2: round_ni r0.y, r0.y  \n   3: ishr r0.z, r0.y, l(13)  \n   4: xor r0.y, r0.y, r0.z  \n   5: imul null, r0.z, r0.y, r0.y  \n   6: imad r0.z, r0.z, l(0x0000ec4d), l(0.0000000000000000000000000000000000001)  \n   7: imad r0.y, r0.y, r0.z, l(146956042240.000000)  \n   8: and r0.y, r0.y, l(0x7fffffff)  \n   9: round_ni r0.z, r0.x  \n  10: frc r0.x, r0.x  \n  11: add r0.x, -r0.x, l(1.000000)  \n  12: ishr r0.w, r0.z, l(13)  \n  13: xor r0.z, r0.z, r0.w  \n  14: imul null, r0.w, r0.z, r0.z  \n  15: imad r0.w, r0.w, l(0x0000ec4d), l(0.0000000000000000000000000000000000001)  \n  16: imad r0.z, r0.z, r0.w, l(146956042240.000000)  \n  17: and r0.z, r0.z, l(0x7fffffff)  \n  18: itof r0.yz, r0.yyzy  \n  19: mul r0.z, r0.z, l(0.000000001)  \n  20: mad r0.y, r0.y, l(0.000000001), -r0.z  \n  21: mul r0.w, r0.x, r0.x  \n  22: mul r0.x, r0.x, r0.w  \n  23: mul r0.w, r0.w, l(3.000000)  \n  24: mad r0.x, r0.x, l(-2.000000), r0.w  \n  25: mad r0.x, r0.x, r0.y, r0.z  \n  26: add r0.y, -cb4[2].x, cb4[3].x  \n  27: mad_sat r0.x, r0.x, r0.y, cb4[2].x  \n  28: mul r0.x, r0.x, v1.w  \n  29: mul r0.yzw, cb4[0].xxxx, cb4[1].xxyz  \n  30: mul r0.xyzw, r0.xyzw, cb2[2].wxyz  \n  31: mul o0.xyz, r0.xxxx, r0.yzwy  \n  32: mov o0.w, r0.x  \n  33: ret\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E \u003Cbr\u002F\u003E\r\nХорошая новость: код не такой длинный.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nПлохая новость:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"cpp\"\u003E   3: ishr r0.z, r0.y, l(13)  \n   4: xor r0.y, r0.y, r0.z  \n   5: imul null, r0.z, r0.y, r0.y  \n   6: imad r0.z, r0.z, l(0x0000ec4d), l(0.0000000000000000000000000000000000001)  \n   7: imad r0.y, r0.y, r0.z, l(146956042240.000000)  \n   8: and r0.y, r0.y, l(0x7fffffff)\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n… что это вообще такое?\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nЧестно говоря, я не впервые вижу подобный кусок… ассемблерного кода в шейдерах «Ведьмака 3». Но когда я встретил его в первый раз, то подумал: «Что за фигня?»\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nНечто подобное можно найти в некоторых других шейдерах TW3. Не буду описывать свои приключения с этим фрагментом, и просто скажу, что ответ заключается в \u003Ca href=\"http:\u002F\u002Flibnoise.sourceforge.net\u002Fnoisegen\u002F\"\u003Eцелочисленном шуме\u003C\u002Fa\u003E:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"cpp\"\u003E \u002F\u002F For more details see: http:\u002F\u002Flibnoise.sourceforge.net\u002Fnoisegen\u002F  \n float integerNoise( int n )  \n {  \n      n = (n \u003E\u003E 13) ^ n;  \n      int nn = (n * (n * n * 60493 + 19990303) + 1376312589) &amp; 0x7fffffff;  \n      return ((float)nn \u002F 1073741824.0);  \n }\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nКак видите, в пиксельном шейдере он вызывается дважды. Пользуясь руководствами с этого веб-сайта, мы можем понять, как правильно реализуется плавный шум. Я вернусь к этому через минуту.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nПосмотрите на строку 0 — здесь мы выполняем анимацию на основании следующей формулы:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Ci\u003Eanimation = elapsedTime * animationSpeed + TextureUV.x\u003C\u002Fi\u003E\u003Cbr\u002F\u003E\r\nЭти значения, после округления в меньшую сторону (\u003Ca href=\"https:\u002F\u002Fdocs.microsoft.com\u002Fen-us\u002Fwindows\u002Fdesktop\u002Fdirect3dhlsl\u002Fdx-graphics-hlsl-floor\"\u003Efloor\u003C\u002Fa\u003E) (инструкция \u003Ci\u003Eround_ni\u003C\u002Fi\u003E) в дальнейшем становятся входными точками для целочисленного шума. Обычно мы вычисляем значение шума для двух целых чисел, а затем вычисляем окончательное, интерполированное значение между ними (подробности см. на веб-сайте libnoise).\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nНу ладно, это \u003Cb\u003Eцелочисленный\u003C\u002Fb\u003E шум, но ведь все ранее упомянутые значения (тоже округлённые в меньшую сторону) являются float!\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nЗаметьте, что здесь нет инструкций \u003Ca href=\"https:\u002F\u002Fdocs.microsoft.com\u002Fen-us\u002Fwindows\u002Fdesktop\u002Fdirect3dhlsl\u002Fftoi--sm4---asm-\"\u003Eftoi\u003C\u002Fa\u003E. Я предполагаю, что программисты из CD Projekt Red воспользовались здесь внутренней функцией HLSL \u003Ca href=\"https:\u002F\u002Fdocs.microsoft.com\u002Fen-us\u002Fwindows\u002Fdesktop\u002Fdirect3dhlsl\u002Fdx-graphics-hlsl-asint\"\u003Easint\u003C\u002Fa\u003E, которая выполняет преобразование «reinterpret_cast» значений с плавающей запятой и обрабатывает их как целочисленный паттерн.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nВес интерполяции для двух значений вычисляется в строках 10-11\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Ci\u003EinterpolationWeight = 1.0 — frac( animation );\u003C\u002Fi\u003E\u003Cbr\u002F\u003E\r\nТакой подход позволяет нам выполнять интерполирование между значения с учётом времени.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nДля создания плавного шума этот интерполятор передается функции \u003Cb\u003ESCurve\u003C\u002Fb\u003E:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"cpp\"\u003E float s_curve( float x )  \n {  \n   float x2 = x * x;  \n   float x3 = x2 * x;  \n     \n   \u002F\u002F -2x^3 + 3x^2  \n   return -2.0*x3 + 3.0*x2;  \n }\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003Cdiv style=\"text-align:center;\"\u003E\u003Cimg src=\"\u002Fimg\u002Fimage-loader.svg\" data-src=\"https:\u002F\u002F3.bp.blogspot.com\u002F-WxNWwK5n4ug\u002FXHzmnoWFLBI\u002FAAAAAAAABT4\u002FKOeYq786NEYJFJoxaTArBp5lQ0bGmSS8gCLcBGAs\u002Fs1600\u002Fscurve.png\"\u002F\u003E\u003C\u002Fdiv\u003E\u003Cbr\u002F\u003E\r\n\u003Ci\u003EФункция Smoothstep [libnoise.sourceforge.net]\u003C\u002Fi\u003E\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nЭта функция известна под названием «smoothstep». Но как видно из ассемблерного кода, это \u003Cb\u003Eне\u003C\u002Fb\u003E внутренняя функция \u003Ca href=\"https:\u002F\u002Fdocs.microsoft.com\u002Fen-us\u002Fwindows\u002Fdesktop\u002Fdirect3dhlsl\u002Fdx-graphics-hlsl-smoothstep\"\u003Esmoothstep\u003C\u002Fa\u003E из HLSL. Внутренняя функция применяет ограничения, чтобы значения были верными. Но поскольку мы знаем, что \u003Ci\u003EinterpolationWeight\u003C\u002Fi\u003E всегда будет находиться в интервале [0-1], эти проверки можно спокойно пропустить.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nПри вычислении окончательного значения используется несколько операций умножения. Посмотрите, как может меняться окончательное выходное значение альфы в зависимости от значения шума. Это удобно, потому что будет влиять на непрозрачность отрендеренной молнии, совсем как в реальной жизни.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nГотовый пиксельный шейдер:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"cpp\"\u003E cbuffer cbPerFrame : register (b0)  \n {  \n   float4 cb0_v0;  \n   float4 cb0_v1;  \n   float4 cb0_v2;  \n   float4 cb0_v3;  \n }  \n   \n cbuffer cbPerFrame : register (b2)  \n {  \n   float4 cb2_v0;  \n   float4 cb2_v1;  \n   float4 cb2_v2;  \n   float4 cb2_v3;  \n }  \n   \n cbuffer cbPerFrame : register (b4)  \n {  \n   float4 cb4_v0;  \n   float4 cb4_v1;  \n   float4 cb4_v2;  \n   float4 cb4_v3;  \n   float4 cb4_v4;  \n }  \n   \n struct VS_OUTPUT  \n {  \n   float2 Texcoords : Texcoord0;  \n   float4 InstanceLODParams : INSTANCE_LOD_PARAMS;  \n   float4 PositionH : SV_Position;  \n };  \n   \n \u002F\u002F Shaders in TW3 use integer noise.  \n \u002F\u002F For more details see: http:\u002F\u002Flibnoise.sourceforge.net\u002Fnoisegen\u002F  \n float integerNoise( int n )  \n {  \n   n = (n \u003E\u003E 13) ^ n;  \n   int nn = (n * (n * n * 60493 + 19990303) + 1376312589) &amp; 0x7fffffff;  \n   return ((float)nn \u002F 1073741824.0);  \n }  \n   \n float s_curve( float x )  \n {  \n   float x2 = x * x;  \n   float x3 = x2 * x;  \n   \n   \u002F\u002F -2x^3 + 3x^2  \n   return -2.0*x3 + 3.0*x2;  \n }  \n   \n float4 Lightning_TW3_PS( in VS_OUTPUT Input ) : SV_Target\n {  \n   \u002F\u002F * Inputs  \n   float elapsedTime = cb0_v0.x;  \n   float animationSpeed = cb4_v4.x;  \n   \n   float minAmount = cb4_v2.x;  \n   float maxAmount = cb4_v3.x;  \n   \n   float colorMultiplier = cb4_v0.x;  \n   float3 colorFilter = cb4_v1.xyz;  \n   float3 lightningColorRGB = cb2_v2.rgb;  \n   \n   \n   \u002F\u002F Animation using time and X texcoord  \n   float animation = elapsedTime * animationSpeed + Input.Texcoords.x;  \n   \n   \u002F\u002F Input parameters for Integer Noise.  \n   \u002F\u002F They are floored and please note there are using asint.  \n   \u002F\u002F That might be an optimization to avoid \"ftoi\" instructions.  \n   int intX0 = asint( floor(animation) );  \n   int intX1 = asint( floor(animation-1.0) );  \n   \n   float n0 = integerNoise( intX0 );  \n   float n1 = integerNoise( intX1 );    \n   \n   \u002F\u002F We interpolate \"backwards\" here.  \n   float weight = 1.0 - frac(animation);  \n   \n   \u002F\u002F Following the instructions from libnoise, we perform  \n   \u002F\u002F smooth interpolation here with cubic s-curve function.  \n   float noise = lerp( n0, n1, s_curve(weight) );  \n   \n   \u002F\u002F Make sure we are in [0.0 - 1.0] range.  \n   float lightningAmount = saturate( lerp(minAmount, maxAmount, noise) );  \n   lightningAmount *= Input.InstanceLODParams.w;    \u002F\u002F 1.0  \n   lightningAmount *= cb2_v2.w;             \u002F\u002F 1.0  \n   \n   \u002F\u002F Calculate final lightning color   \n   float3 lightningColor = colorMultiplier * colorFilter;  \n   lightningColor *= lighntingColorRGB;  \n   \n   float3 finalLightningColor = lightningColor * lightningAmount;  \n   return float4( finalLightningColor, lightningAmount );  \n }\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003Ch3\u003EПодведём итог\u003C\u002Fh3\u003E\u003Cbr\u002F\u003E\r\nВ этой части я описал способ рендеринга молний в «Ведьмаке 3».\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nЯ очень доволен тем, что получившийся из моего шейдера ассемблерный код полностью совпадает с оригинальным!\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cdiv style=\"text-align:center;\"\u003E\u003Cimg src=\"https:\u002F\u002F3.bp.blogspot.com\u002F-mzsVLwDyri0\u002FXH6i1ofT5xI\u002FAAAAAAAABUI\u002FCZiE-02xSPElbDuAsCRtDH4Wrninhc4ugCLcBGAs\u002Fs1600\u002F08_diff.JPG\"\u002F\u003E\u003C\u002Fdiv\u003E\u003Cbr\u002F\u003E\r\n\u003Ch2\u003EЧасть 2. Глупые трюки с небом\u003C\u002Fh2\u003E\u003Cbr\u002F\u003E\r\nЭта часть будет немного отличаться от предыдущих. В ней я хочу показать вам некоторые аспекты шейдеров неба Witcher 3.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nПочему «глупые трюки», а не весь шейдер? Ну, на то есть несколько причин. Во-первых, шейдер неба Witcher 3 — довольно сложная зверюга. Пиксельный шейдер из версии 2015 года содержит 267 строк ассемблерного кода, а шейдер из DLC «Кровь и вино» — уже 385 строк.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nБолее того, они получают множество входных данных, что не очень способствует реверс-инжинирингу полного (и читаемого!) кода на HLSL.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nПоэтому я решил показать из этих шейдеров только часть трюков. Если я найду что-то новое, то дополню пост.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nРазличия между версией 2015 года и DLC (2016 год) сильно заметны. В том, числе в них входят различия в вычислении звёзд и их мерцания, разный подход к рендерингу Солнца… Шейдер \u003Ci\u003E«Крови и вина»\u003C\u002Fi\u003E даже вычисляет ночью Млечный путь.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nЯ начну с основ, а потом расскажу о глупых трюках.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Ch3\u003EОсновы\u003C\u002Fh3\u003E\u003Cbr\u002F\u003E\r\nКак и в большинстве современных игр, в Witcher 3 для моделирования неба используется skydome. Посмотрите на полусферу, которую использовали для этого в Witcher 3 (2015). Примечание: в данном случае ограничивающий параллелепипед этого меша находится в интервале от [0,0,0] до [1,1,1] (Z — это ось, направленная вверх) и имеет плавно распределённые UV. Позже мы их используем.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cdiv style=\"text-align:center;\"\u003E\u003Cimg src=\"https:\u002F\u002F1.bp.blogspot.com\u002F-nibxaoZQU2Q\u002FXI1ryQ_R5pI\u002FAAAAAAAABVs\u002FncEn1cudCrQczYP4s8ovg7wM2pzORXx7gCLcBGAs\u002Fs1600\u002Fskybox_mesh_input.JPG\"\u002F\u003E\u003C\u002Fdiv\u003E\u003Cbr\u002F\u003E\r\nИдея в основе skydome схожа с идеей \u003Ca href=\"https:\u002F\u002Fen.wikipedia.org\u002Fwiki\u002FSkybox_(video_games)\"\u003Eскайбокса\u003C\u002Fa\u003E (единственная разница заключается в используемом меше). На этапе вершинного шейдера мы преобразуем skydome относительно наблюдателя (обычно в соответствии с позицией камеры), что создаёт иллюзию того, что небо и в самом деле находится очень далеко — мы никогда до него не доберёмся.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nЕсли вы читали предыдущие части этой серии статей, то знаете, что в «Ведьмаке 3» используется обратная глубина, то есть дальняя плоскость имеет значение 0.0f, а ближняя — 1.0f. Чтобы вывод skydome целиком выполнялся на дальней плоскости, в параметрах окна обзора мы задаём \u003Ci\u003EMinDepth\u003C\u002Fi\u003E то же значение, что и \u003Ci\u003EMaxDepth\u003C\u002Fi\u003E:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cdiv style=\"text-align:center;\"\u003E\u003Cimg src=\"https:\u002F\u002F3.bp.blogspot.com\u002F-xrQqWzpY-k4\u002FXI4rRQsgpzI\u002FAAAAAAAABWY\u002FGkV8mhSb5AQ8Z-FKaWl_zaKtIO9nbe1BgCLcBGAs\u002Fs1600\u002Fviewport.JPG\"\u002F\u003E\u003C\u002Fdiv\u003E\u003Cbr\u002F\u003E\r\nЧтобы узнать, как поля \u003Ci\u003EMinDepth\u003C\u002Fi\u003E и \u003Ci\u003EMaxDepth\u003C\u002Fi\u003E используются во время преобразования окна обзора, нажмите \u003Ca href=\"https:\u002F\u002Fdocs.microsoft.com\u002Fen-us\u002Fwindows\u002Fdesktop\u002Fdirect3d11\u002Fd3d10-graphics-programming-guide-rasterizer-stage-getting-started\"\u003Eсюда\u003C\u002Fa\u003E (docs.microsoft.com).\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Ch3\u003EВершинный шейдер\u003C\u002Fh3\u003E\u003Cbr\u002F\u003E\r\nДавайте начнём с вершинного шейдера. В Witcher 3 (2015 год) ассемблерный код шейдера имеет следующий вид:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"cpp\"\u003E vs_5_0  \n    dcl_globalFlags refactoringAllowed  \n    dcl_constantbuffer cb1[4], immediateIndexed  \n    dcl_constantbuffer cb2[6], immediateIndexed  \n    dcl_input v0.xyz  \n    dcl_input v1.xy  \n    dcl_output o0.xy  \n    dcl_output o1.xyz  \n    dcl_output_siv o2.xyzw, position  \n    dcl_temps 2  \n   0: mov o0.xy, v1.xyxx  \n   1: mad r0.xyz, v0.xyzx, cb2[4].xyzx, cb2[5].xyzx  \n   2: mov r0.w, l(1.000000)  \n   3: dp4 o1.x, r0.xyzw, cb2[0].xyzw  \n   4: dp4 o1.y, r0.xyzw, cb2[1].xyzw  \n   5: dp4 o1.z, r0.xyzw, cb2[2].xyzw  \n   6: mul r1.xyzw, cb1[0].yyyy, cb2[1].xyzw  \n   7: mad r1.xyzw, cb2[0].xyzw, cb1[0].xxxx, r1.xyzw  \n   8: mad r1.xyzw, cb2[2].xyzw, cb1[0].zzzz, r1.xyzw  \n   9: mad r1.xyzw, cb1[0].wwww, l(0.000000, 0.000000, 0.000000, 1.000000), r1.xyzw  \n  10: dp4 o2.x, r0.xyzw, r1.xyzw  \n  11: mul r1.xyzw, cb1[1].yyyy, cb2[1].xyzw  \n  12: mad r1.xyzw, cb2[0].xyzw, cb1[1].xxxx, r1.xyzw  \n  13: mad r1.xyzw, cb2[2].xyzw, cb1[1].zzzz, r1.xyzw  \n  14: mad r1.xyzw, cb1[1].wwww, l(0.000000, 0.000000, 0.000000, 1.000000), r1.xyzw  \n  15: dp4 o2.y, r0.xyzw, r1.xyzw  \n  16: mul r1.xyzw, cb1[2].yyyy, cb2[1].xyzw  \n  17: mad r1.xyzw, cb2[0].xyzw, cb1[2].xxxx, r1.xyzw  \n  18: mad r1.xyzw, cb2[2].xyzw, cb1[2].zzzz, r1.xyzw  \n  19: mad r1.xyzw, cb1[2].wwww, l(0.000000, 0.000000, 0.000000, 1.000000), r1.xyzw  \n  20: dp4 o2.z, r0.xyzw, r1.xyzw  \n  21: mul r1.xyzw, cb1[3].yyyy, cb2[1].xyzw  \n  22: mad r1.xyzw, cb2[0].xyzw, cb1[3].xxxx, r1.xyzw  \n  23: mad r1.xyzw, cb2[2].xyzw, cb1[3].zzzz, r1.xyzw  \n  24: mad r1.xyzw, cb1[3].wwww, l(0.000000, 0.000000, 0.000000, 1.000000), r1.xyzw  \n  25: dp4 o2.w, r0.xyzw, r1.xyzw  \n  26: ret\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nВ данном случае вершинный шейдер передаёт на выход только texcoords и позицию в мировом пространстве. В \u003Ci\u003E«Крови и вине»\u003C\u002Fi\u003E он также выводит нормализованный вектор нормали. Я буду рассматривать версию 2015 года, потому что она проще.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nПосмотрите на буфер констант, обозначенный как \u003Cb\u003Ecb2\u003C\u002Fb\u003E:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cdiv style=\"text-align:center;\"\u003E\u003Cimg src=\"https:\u002F\u002F4.bp.blogspot.com\u002F-29-t0eW2ktI\u002FXI4kGUssDOI\u002FAAAAAAAABWA\u002FYOdBgVjrdPsXA_5LBq5NSuxyU96989PCACLcBGAs\u002Fs1600\u002Fvs_cbuffer_2.JPG\"\u002F\u003E\u003C\u002Fdiv\u003E\u003Cbr\u002F\u003E\r\nЗдесь у нас есть матрица мира (однородное масштабирование на 100 и перенос относительно позиции камеры). Ничего сложного. cb2_v4 и cb2_v5 — это коэффициенты масштаба\u002Fотклонения, используемые для преобразования позиций вершин из интервала [0-1] в интервал [-1;1]. Но здесь эти коэффициенты «сжимают» ось Z (направленную вверх).\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cdiv style=\"text-align:center;\"\u003E\u003Cimg src=\"https:\u002F\u002F2.bp.blogspot.com\u002F-nrd37spltMs\u002FXI1ryfEGe0I\u002FAAAAAAAABV0\u002FdPa03Clb8jwY6dNj69x6coxckHA8K1fYQCPcBGAYYCw\u002Fs1600\u002Fskybox_mesh_out_Zsqueezed.JPG\"\u002F\u003E\u003C\u002Fdiv\u003E\u003Cbr\u002F\u003E\r\nВ предыдущих частях серии у нас были похожие вершинные шейдеры. Общий алгоритм заключается в передаче texcoords дальше, затем вычисляется \u003Ci\u003EPosition\u003C\u002Fi\u003E с учётом коэффициентов масштаба\u002Fотклонения, затем вычисляется \u003Ci\u003EPositionW\u003C\u002Fi\u003E в мировом пространстве, потом рассчитывается окончательная позиция пространства отсечения перемножением матриц \u003Ci\u003EmatWorld\u003C\u002Fi\u003E и \u003Ci\u003EmatViewProj\u003C\u002Fi\u003E -\u003E используется их произведение для умножения на \u003Ci\u003EPosition\u003C\u002Fi\u003E, чтобы получить окончательную SV_Position.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nПоэтому HLSL этого вершинного шейдера должен быть примерно таким:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"cpp\"\u003E struct InputStruct {  \n      float3 param0 : POSITION;  \n      float2 param1 : TEXCOORD;  \n      float3 param2 : NORMAL;  \n      float4 param3 : TANGENT;  \n };  \n   \n struct OutputStruct {  \n      float2 param0 : TEXCOORD0;  \n      float3 param1 : TEXCOORD1;  \n      float4 param2 : SV_Position;  \n };  \n   \n OutputStruct EditedShaderVS(in InputStruct IN)  \n {  \n      OutputStruct OUT = (OutputStruct)0;  \n        \n      \u002F\u002F Simple texcoords passing  \n      OUT.param0 = IN.param1;  \n        \n        \n      \u002F\u002F * Manually construct world and viewProj martices from float4s:  \n      row_major matrix matWorld = matrix(cb2_v0, cb2_v1, cb2_v2, float4(0,0,0,1) );  \n      matrix matViewProj = matrix(cb1_v0, cb1_v1, cb1_v2, cb1_v3);  \n   \n      \u002F\u002F * Some optional fun with worldMatrix  \n      \u002F\u002F a) Scale  \n      \u002F\u002FmatWorld._11 = matWorld._22 = matWorld._33 = 0.225f;  \n   \n      \u002F\u002F b) Translate  \n      \u002F\u002F X Y Z  \n      \u002F\u002FmatWorld._14 = 520.0997;  \n      \u002F\u002FmatWorld._24 = 74.4226;  \n      \u002F\u002FmatWorld._34 = 113.9;  \n   \n      \u002F\u002F Local space - note the scale+bias here!  \n      \u002F\u002Ffloat3 meshScale = float3(2.0, 2.0, 2.0);  \n      \u002F\u002Ffloat3 meshBias = float3(-1.0, -1.0, -0.4);  \n      float3 meshScale = cb2_v4.xyz;  \n      float3 meshBias = cb2_v5.xyz;  \n   \n      float3 Position = IN.param0 * meshScale + meshBias;  \n        \n      \u002F\u002F World space  \n      float4 PositionW = mul(float4(Position, 1.0), transpose(matWorld) );  \n      OUT.param1 = PositionW.xyz;  \n   \n      \u002F\u002F Clip space - original approach from The Witcher 3  \n      matrix matWorldViewProj = mul(matViewProj, matWorld);  \n      OUT.param2 = mul( float4(Position, 1.0), transpose(matWorldViewProj) );  \n        \n      return OUT;  \n }\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nСравнение моего шейдера (слева) и оригинального (справа):\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cdiv style=\"text-align:center;\"\u003E\u003Cimg src=\"https:\u002F\u002F1.bp.blogspot.com\u002F-BtypYno8Gb8\u002FXI4kGe5LPxI\u002FAAAAAAAABWQ\u002FoQcHYAohVgoWj61Bm03txhgmf5B0tD_SACEwYBhgL\u002Fs1600\u002Fvs_comparison.JPG\"\u002F\u003E\u003C\u002Fdiv\u003E\u003Cbr\u002F\u003E\r\nОтличным свойством \u003Ca href=\"https:\u002F\u002Frenderdoc.org\u002F\"\u003ERenderDoc\u003C\u002Fa\u003E является то, что он позволяет нам выполнить инъекцию собственного шейдера вместо оригинального, и эти изменения повлияют на конвейер до самого конца кадра. Как видите из кода HLSL, я предоставил несколько вариантов изменения масштаба и преобразования конечной геометрии. Можете поэкспериментировать с ними и получить очень забавные результаты:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cdiv style=\"text-align:center;\"\u003E\u003Cimg src=\"https:\u002F\u002F4.bp.blogspot.com\u002F-WUFYJBXaW18\u002FXI4kGlz1xhI\u002FAAAAAAAABWQ\u002FU0_Ng2YwIOU7pMMR9M6KSDMHfQS33zCcwCEwYBhgL\u002Fs1600\u002Ftw3_2015_distorted.jpg\" data-src=\"https:\u002F\u002F4.bp.blogspot.com\u002F-WUFYJBXaW18\u002FXI4kGlz1xhI\u002FAAAAAAAABWQ\u002FU0_Ng2YwIOU7pMMR9M6KSDMHfQS33zCcwCEwYBhgL\u002Fs1600\u002Ftw3_2015_distorted.jpg\" data-blurred=\"true\"\u002F\u003E\u003C\u002Fdiv\u003E\u003Cbr\u002F\u003E\r\n\u003Ch4\u003EОптимизация вершинного шейдера\u003C\u002Fh4\u003E\u003Cbr\u002F\u003E\r\nВы заметили проблему оригинального вершинного шейдера? Повершинное перемножение матрицы на матрицу совершенно избыточно! Я обнаружил это по крайней мере в нескольких вершинных шейдерах (например, в шейдере \u003Ca href=\"https:\u002F\u002Fastralcode.blogspot.com\u002F2019\u002F01\u002Freverse-engineering-rendering-of.html\"\u003Eзанавес дождя в отдалении\u003C\u002Fa\u003E). Мы можем оптимизировать его, сразу же умножив \u003Ci\u003EPositionW\u003C\u002Fi\u003E на \u003Ci\u003EmatViewProj\u003C\u002Fi\u003E!\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nИтак, мы можем заменить такой код на HLSL:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"cpp\"\u003E      \u002F\u002F Clip space - original approach from The Witcher 3  \n      matrix matWorldViewProj = mul(matViewProj, matWorld);  \n      OUT.param2 = mul( float4(Position, 1.0), transpose(matWorldViewProj) );\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nследующим:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"cpp\"\u003E      \u002F\u002F Clip space - optimized version  \n      OUT.param2 = mul( matViewProj, PositionW );\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nОптимизированная версия даёт нам следующий ассемблерный код:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"cpp\"\u003E    vs_5_0  \n    dcl_globalFlags refactoringAllowed  \n    dcl_constantbuffer CB1[4], immediateIndexed  \n    dcl_constantbuffer CB2[6], immediateIndexed  \n    dcl_input v0.xyz  \n    dcl_input v1.xy  \n    dcl_output o0.xy  \n    dcl_output o1.xyz  \n    dcl_output_siv o2.xyzw, position  \n    dcl_temps 2  \n   0: mov o0.xy, v1.xyxx  \n   1: mad r0.xyz, v0.xyzx, cb2[4].xyzx, cb2[5].xyzx  \n   2: mov r0.w, l(1.000000)  \n   3: dp4 r1.x, r0.xyzw, cb2[0].xyzw  \n   4: dp4 r1.y, r0.xyzw, cb2[1].xyzw  \n   5: dp4 r1.z, r0.xyzw, cb2[2].xyzw  \n   6: mov o1.xyz, r1.xyzx  \n   7: mov r1.w, l(1.000000)  \n   8: dp4 o2.x, cb1[0].xyzw, r1.xyzw  \n   9: dp4 o2.y, cb1[1].xyzw, r1.xyzw  \n  10: dp4 o2.z, cb1[2].xyzw, r1.xyzw  \n  11: dp4 o2.w, cb1[3].xyzw, r1.xyzw  \n  12: ret\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nКак видите, мы уменьшили количество инструкций с 26 до 12 — довольно значительное изменение. Я не знаю, насколько широко распространена эта проблема в игре, но ради бога, CD Projekt Red, может, выпустите патч? :)\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nИ я не шучу. Можете вставить мой оптимизированный шейдер вместо оригинального RenderDoc и вы увидите, что эта оптимизация визуально ни на что не влияет. Честно говоря, я не понимаю, зачем CD Projekt Red решила выполнять повершинное умножение матрицы на матрицу…\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Ch3\u003EСолнце\u003C\u002Fh3\u003E\u003Cbr\u002F\u003E\r\nВ «Ведьмаке 3» (2015 год) вычисление атмосферного рассеяния и Солнца состоит из двух отдельных вызовов отрисовки:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cdiv style=\"text-align:center;\"\u003E\u003Cimg src=\"https:\u002F\u002F2.bp.blogspot.com\u002F-LYlU8tIn_T4\u002FXI1M7ZkimYI\u002FAAAAAAAABVI\u002FCIcniH-PoLkZ6sO6FRkwGSaP6f2T75D_gCEwYBhgL\u002Fs1600\u002F01_tw3_2015_before_sun.jpg\" data-src=\"https:\u002F\u002F2.bp.blogspot.com\u002F-LYlU8tIn_T4\u002FXI1M7ZkimYI\u002FAAAAAAAABVI\u002FCIcniH-PoLkZ6sO6FRkwGSaP6f2T75D_gCEwYBhgL\u002Fs1600\u002F01_tw3_2015_before_sun.jpg\" data-blurred=\"true\"\u002F\u003E\u003C\u002Fdiv\u003E\u003Cbr\u002F\u003E\r\n\u003Ci\u003EWitcher 3 (2015) — до\u003C\u002Fi\u003E\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cdiv style=\"text-align:center;\"\u003E\u003Cimg src=\"https:\u002F\u002F3.bp.blogspot.com\u002F-Osp-nrn3wqc\u002FXI1M7T7YF0I\u002FAAAAAAAABVE\u002FnaXCBqa20WwwADMb2SJn-iri72mueIu9gCEwYBhgL\u002Fs1600\u002F02_tw3_2015_after_sky.jpg\" data-src=\"https:\u002F\u002F3.bp.blogspot.com\u002F-Osp-nrn3wqc\u002FXI1M7T7YF0I\u002FAAAAAAAABVE\u002FnaXCBqa20WwwADMb2SJn-iri72mueIu9gCEwYBhgL\u002Fs1600\u002F02_tw3_2015_after_sky.jpg\" data-blurred=\"true\"\u002F\u003E\u003C\u002Fdiv\u003E\u003Cbr\u002F\u003E\r\n\u003Ci\u003EWitcher 3 (2015) — с небом\u003C\u002Fi\u003E\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cdiv style=\"text-align:center;\"\u003E\u003Cimg src=\"https:\u002F\u002F2.bp.blogspot.com\u002F-n3IIQ36moI4\u002FXI1M7MEwDbI\u002FAAAAAAAABVA\u002F_UBKawZqvd0vZrjs2D4Byyi8yeKAt7-nACEwYBhgL\u002Fs1600\u002F03_tw3_2015_final.jpg\" data-src=\"https:\u002F\u002F2.bp.blogspot.com\u002F-n3IIQ36moI4\u002FXI1M7MEwDbI\u002FAAAAAAAABVA\u002F_UBKawZqvd0vZrjs2D4Byyi8yeKAt7-nACEwYBhgL\u002Fs1600\u002F03_tw3_2015_final.jpg\" data-blurred=\"true\"\u002F\u003E\u003C\u002Fdiv\u003E\u003Cbr\u002F\u003E\r\n\u003Ci\u003EWitcher 3 (2015) — с небом + Солнце\u003C\u002Fi\u003E\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nРендеринг Солнца в версии 2015 года очень похож на \u003Ca href=\"https:\u002F\u002Fastralcode.blogspot.com\u002F2018\u002F12\u002Freverse-engineering-rendering-of_22.html\"\u003Eрендеринг Луны\u003C\u002Fa\u003E с точки зрения геометрии и состояний смешивания\u002Fглубин.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nС другой стороны, в \u003Ci\u003E«Крови и вине»\u003C\u002Fi\u003E небо с Солнцем рендерятся за один проход:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cdiv style=\"text-align:center;\"\u003E\u003Cimg src=\"https:\u002F\u002F2.bp.blogspot.com\u002F-Bwkb24XajSc\u002FXI1M8KSosvI\u002FAAAAAAAABVM\u002FmMWzW-pHQKk3n9yPVMCQv2g4vOqBE2ldwCEwYBhgL\u002Fs1600\u002F04_tw3_2016_before.jpg\" data-src=\"https:\u002F\u002F2.bp.blogspot.com\u002F-Bwkb24XajSc\u002FXI1M8KSosvI\u002FAAAAAAAABVM\u002FmMWzW-pHQKk3n9yPVMCQv2g4vOqBE2ldwCEwYBhgL\u002Fs1600\u002F04_tw3_2016_before.jpg\" data-blurred=\"true\"\u002F\u003E\u003C\u002Fdiv\u003E\u003Cbr\u002F\u003E\r\n\u003Ci\u003EВедьмак 3: Кровь и вино (2016 год) — до неба\u003C\u002Fi\u003E\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cdiv style=\"text-align:center;\"\u003E\u003Cimg src=\"https:\u002F\u002F1.bp.blogspot.com\u002F-hf4uFG5dlDU\u002FXI1M8a-ShtI\u002FAAAAAAAABVQ\u002FVp81FC3nW9wrpxv7Gk8ihzmjzQo9EqChgCEwYBhgL\u002Fs1600\u002F05_tw3_2016_after.jpg\" data-src=\"https:\u002F\u002F1.bp.blogspot.com\u002F-hf4uFG5dlDU\u002FXI1M8a-ShtI\u002FAAAAAAAABVQ\u002FVp81FC3nW9wrpxv7Gk8ihzmjzQo9EqChgCEwYBhgL\u002Fs1600\u002F05_tw3_2016_after.jpg\" data-blurred=\"true\"\u002F\u003E\u003C\u002Fdiv\u003E\u003Cbr\u002F\u003E\r\n\u003Ci\u003EВедьмак 3: Кровь и вино (2016 год) — с небом и Солнцем\u003C\u002Fi\u003E\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nКак бы вы не рендерили Солнце, на каком-то этапе вам всё равно понадобится (нормализованное) направление солнечного света. Наиболее логичный способ получить этот вектор — использовать \u003Ca href=\"https:\u002F\u002Fen.wikipedia.org\u002Fwiki\u002FSpherical_coordinate_system\"\u003Eсферические координаты\u003C\u002Fa\u003E. По сути, нам нужно всего два значения, обозначающие два угла (в радианах!): \u003Ci\u003Eфи\u003C\u002Fi\u003E и \u003Ci\u003Eтета\u003C\u002Fi\u003E. Получив их, можно допустить, что \u003Ci\u003Er = 1\u003C\u002Fi\u003E, таким образом сократив его. Тогда для декартовых координат с направленной вверх осью Y можно написать следующий код на HLSL:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"cpp\"\u003E float3 vSunDir;  \n vSunDir.x = sin(fTheta)*cos(fPhi);  \n vSunDir.y = sin(fTheta)*sin(fPhi);  \n vSunDir.z = cos(fTheta);  \n vSunDir = normalize(vSunDir);\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nОбычно направление солнечного света вычисляется в приложении, а затем передаётся в буфер констант для дальнейшего использования.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nПолучив направление солнечного света, мы можем углубиться в ассемблерный код пиксельного шейдера \u003Ci\u003E«Крови и вина»\u003C\u002Fi\u003E…\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"cpp\"\u003E  ...   \n  100: add r1.xyw, -r0.xyxz, cb12[0].xyxz  \n  101: dp3 r2.x, r1.xywx, r1.xywx  \n  102: rsq r2.x, r2.x  \n  103: mul r1.xyw, r1.xyxw, r2.xxxx  \n  104: mov_sat r2.xy, cb12[205].yxyy  \n  105: dp3 r2.z, -r1.xywx, -r1.xywx  \n  106: rsq r2.z, r2.z  \n  107: mul r1.xyw, -r1.xyxw, r2.zzzz  \n  ...\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nИтак, во-первых, \u003Ci\u003Ecb12[0].xyz\u003C\u002Fi\u003E — это позиция камеры, а в \u003Ci\u003Er0.xyz\u003C\u002Fi\u003E мы храним позицию вершины (это выходные данные из вершинного шейдера). Следовательно, строка 100 вычисляет вектор \u003Ci\u003EworldToCamera\u003C\u002Fi\u003E. Но взгляните на строки 105-107. Мы можем записать их как \u003Ci\u003Enormalize( -worldToCamera)\u003C\u002Fi\u003E, то есть мы вычисляем нормализованный вектор \u003Ci\u003EcameraToWorld\u003C\u002Fi\u003E.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"cpp\"\u003E  120: dp3_sat r1.x, cb12[203].yzwy, r1.xywx\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nЗатем мы вычисляем скалярное произведение векторов \u003Ci\u003EcameraToWorld\u003C\u002Fi\u003E и \u003Ci\u003EsunDirection\u003C\u002Fi\u003E! Помните, что они должны быть нормализованными. Также мы насыщаем это полное выражение, чтобы ограничить его интервалом [0-1].\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nОтлично! Это скалярное произведение хранится в r1.x. Давайте посмотрим, где оно применяется дальше…\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"cpp\"\u003E  152: log r1.x, r1.x  \n  153: mul r1.x, r1.x, cb12[203].x  \n  154: exp r1.x, r1.x  \n  155: mul r1.x, r2.y, r1.x\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nТроица «log, mul, exp» — это возведение в степень. Как видите, мы возводим наш косинус (скалярное произведение нормализованных векторов) в какую-то степень. Вы можете спросить зачем. Таким образом мы можем создать градиент, имитирующий Солнце. (И строка 155 влияет на непрозрачность этого градиента, чтобы мы, например, обнулить его, чтобы полностью скрыть Солнце). Вот несколько примеров:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cdiv style=\"text-align:center;\"\u003E\u003Cimg src=\"https:\u002F\u002F3.bp.blogspot.com\u002F-SBtWnWFtGIU\u002FXI4x9eNJdHI\u002FAAAAAAAABWo\u002F9P6tTb3yeq0XGs9mSlKOMdP6HdSJyPaJQCLcBGAs\u002Fs1600\u002Fgradient_exp_56.jpg\" data-src=\"https:\u002F\u002F3.bp.blogspot.com\u002F-SBtWnWFtGIU\u002FXI4x9eNJdHI\u002FAAAAAAAABWo\u002F9P6tTb3yeq0XGs9mSlKOMdP6HdSJyPaJQCLcBGAs\u002Fs1600\u002Fgradient_exp_56.jpg\" data-blurred=\"true\"\u002F\u003E\u003C\u002Fdiv\u003E\u003Cbr\u002F\u003E\r\n\u003Ci\u003Eexponent = 54\u003C\u002Fi\u003E\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cdiv style=\"text-align:center;\"\u003E\u003Cimg src=\"https:\u002F\u002F2.bp.blogspot.com\u002F-wPtE8u4rCvI\u002FXI4x9QWxYVI\u002FAAAAAAAABWk\u002FviArrp8YV7QmrITb2LhPIM-nlUqTXfeDACLcBGAs\u002Fs1600\u002Fgradient_exp_2400.jpg\" data-src=\"https:\u002F\u002F2.bp.blogspot.com\u002F-wPtE8u4rCvI\u002FXI4x9QWxYVI\u002FAAAAAAAABWk\u002FviArrp8YV7QmrITb2LhPIM-nlUqTXfeDACLcBGAs\u002Fs1600\u002Fgradient_exp_2400.jpg\" data-blurred=\"true\"\u002F\u003E\u003C\u002Fdiv\u003E\u003Cbr\u002F\u003E\r\n\u003Ci\u003Eexponent = 2400\u003C\u002Fi\u003E\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nИмея этот градиент, мы используем его для выполнения интерполяции между \u003Ci\u003EskyColor\u003C\u002Fi\u003E и \u003Ci\u003EsunColor\u003C\u002Fi\u003E! Чтобы избежать появления артефактов, нужно насытить значение в строке 120.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nСтоит заметить, что этот трюк можно использовать для имитации \u003Ca href=\"https:\u002F\u002Fen.wikipedia.org\u002Fwiki\u002FCorona_(optical_phenomenon)\"\u003Eвенцов\u003C\u002Fa\u003E Луны (при низких значениях exponent). Для этого нам понадобится вектор \u003Ci\u003EmoonDirection\u003C\u002Fi\u003E, который легко можно вычислить с помощью сферических координат.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nГотовый код на HLSL может походить на следующий фрагмент:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"cpp\"\u003E float3 vCamToWorld = normalize( PosW – CameraPos );  \n   \n float cosTheta = saturate( dot(vSunDir, vCamToWorld) );  \n float sunGradient = pow( cosTheta, sunExponent );  \n   \n float3 color = lerp( skyColor, sunColor, sunGradient );\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003Ch3\u003EДвижение звёзд\u003C\u002Fh3\u003E\u003Cbr\u002F\u003E\r\nЕсли сделать таймлапс чистого ночного неба Witcher 3, то можно заметить, что звёзды не статичны — они немного движутся по небу! Я заметил это почти случайно и захотел узнать, как это реализовано.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nДавайте начнём с того факта, что звёзды в Witcher 3 представлены как кубическая карта размером 1024x1024x6. Если подумать, то можно понять, что это очень удобное решение, которое позволяет с лёгкостью привязывать направления для сэмплирования кубической карты.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nДавайте рассмотрим следующий ассемблерный код:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"cpp\"\u003E  159: add r1.xyz, -v1.xyzx, cb1[8].xyzx  \n  160: dp3 r0.w, r1.xyzx, r1.xyzx  \n  161: rsq r0.w, r0.w  \n  162: mul r1.xyz, r0.wwww, r1.xyzx  \n  163: mul r2.xyz, cb12[204].zwyz, l(0.000000, 0.000000, 1.000000, 0.000000)  \n  164: mad r2.xyz, cb12[204].yzwy, l(0.000000, 1.000000, 0.000000, 0.000000), -r2.xyzx  \n  165: mul r4.xyz, r2.xyzx, cb12[204].zwyz  \n  166: mad r4.xyz, r2.zxyz, cb12[204].wyzw, -r4.xyzx  \n  167: dp3 r4.x, r1.xyzx, r4.xyzx  \n  168: dp2 r4.y, r1.xyxx, r2.yzyy  \n  169: dp3 r4.z, r1.xyzx, cb12[204].yzwy  \n  170: dp3 r0.w, r4.xyzx, r4.xyzx  \n  171: rsq r0.w, r0.w  \n  172: mul r2.xyz, r0.wwww, r4.xyzx  \n  173: sample_indexable(texturecube)(float,float,float,float) r4.xyz, r2.xyzx, t0.xyzw, s0\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nЧтобы вычислить конечный вектор сэмплирования (строка 173), мы начинаем с вычисления нормализованного вектора \u003Ci\u003EworldToCamera\u003C\u002Fi\u003E (строки 159-162).\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nЗатем мы вычисляем два векторных произведения (163-164, 165-166) с \u003Ci\u003EmoonDirection\u003C\u002Fi\u003E, а позже рассчитываем три скалярных произведения, чтобы получить конечный вектор сэмплирования. Код на HLSL:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"cpp\"\u003E float3 vWorldToCamera = normalize( g_CameraPos.xyz - Input.PositionW.xyz );  \n float3 vMoonDirection = cb12_v204.yzw;  \n   \n float3 vStarsSamplingDir = cross( vMoonDirection, float3(0, 0, 1) );  \n float3 vStarsSamplingDir2 = cross( vStarsSamplingDir, vMoonDirection );  \n   \n float dirX = dot( vWorldToCamera, vStarsSamplingDir2 );  \n float dirY = dot( vWorldToCamera, vStarsSamplingDir );  \n float dirZ = dot( vWorldToCamera, vMoonDirection);  \n float3 dirXYZ = normalize( float3(dirX, dirY, dirZ) );  \n   \n float3 starsColor = texNightStars.Sample( samplerAnisoWrap, dirXYZ ).rgb;\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nПримечание для себя: это очень хорошо продуманный код, и мне стоит исследовать его подробнее.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nПримечание для читателей: если вы знаете больше об этой операции, то расскажите мне!\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Ch3\u003EМерцающие звёзды\u003C\u002Fh3\u003E\u003Cbr\u002F\u003E\r\nЕщё один интересный трюк, который бы я хотел исследовать подробнее — это мерцание звёзд. Например, если вы будете бродить в окрестностях Новиграда при ясной погоде, то заметите, что звёзды мерцают.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nМне было любопытно, как это реализовано. Оказалось, что разница между версией 2015 года и \u003Ci\u003E«Кровью и вином»\u003C\u002Fi\u003E довольно велика. Для простоты я буду рассматривать версию 2015 года.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nИтак, мы начинаем сразу после сэмплирования \u003Ci\u003EstarsColor\u003C\u002Fi\u003E из предыдущего раздела:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"cpp\"\u003E  174: mul r0.w, v0.x, l(100.000000)  \n  175: round_ni r1.w, r0.w  \n  176: mad r2.w, v0.y, l(50.000000), cb0[0].x  \n  177: round_ni r4.w, r2.w  \n  178: bfrev r4.w, r4.w  \n  179: iadd r5.x, r1.w, r4.w  \n  180: ishr r5.y, r5.x, l(13)  \n  181: xor r5.x, r5.x, r5.y  \n  182: imul null, r5.y, r5.x, r5.x  \n  183: imad r5.y, r5.y, l(0x0000ec4d), l(0.0000000000000000000000000000000000001)  \n  184: imad r5.x, r5.x, r5.y, l(146956042240.000000)  \n  185: and r5.x, r5.x, l(0x7fffffff)  \n  186: itof r5.x, r5.x  \n  187: mad r5.y, v0.x, l(100.000000), l(-1.000000)  \n  188: round_ni r5.y, r5.y  \n  189: iadd r4.w, r4.w, r5.y  \n  190: ishr r5.z, r4.w, l(13)  \n  191: xor r4.w, r4.w, r5.z  \n  192: imul null, r5.z, r4.w, r4.w  \n  193: imad r5.z, r5.z, l(0x0000ec4d), l(0.0000000000000000000000000000000000001)  \n  194: imad r4.w, r4.w, r5.z, l(146956042240.000000)  \n  195: and r4.w, r4.w, l(0x7fffffff)  \n  196: itof r4.w, r4.w  \n  197: add r5.z, r2.w, l(-1.000000)  \n  198: round_ni r5.z, r5.z  \n  199: bfrev r5.z, r5.z  \n  200: iadd r1.w, r1.w, r5.z  \n  201: ishr r5.w, r1.w, l(13)  \n  202: xor r1.w, r1.w, r5.w  \n  203: imul null, r5.w, r1.w, r1.w  \n  204: imad r5.w, r5.w, l(0x0000ec4d), l(0.0000000000000000000000000000000000001)  \n  205: imad r1.w, r1.w, r5.w, l(146956042240.000000)  \n  206: and r1.w, r1.w, l(0x7fffffff)  \n  207: itof r1.w, r1.w  \n  208: mul r1.w, r1.w, l(0.000000001)  \n  209: iadd r5.y, r5.z, r5.y  \n  210: ishr r5.z, r5.y, l(13)  \n  211: xor r5.y, r5.y, r5.z  \n  212: imul null, r5.z, r5.y, r5.y  \n  213: imad r5.z, r5.z, l(0x0000ec4d), l(0.0000000000000000000000000000000000001)  \n  214: imad r5.y, r5.y, r5.z, l(146956042240.000000)  \n  215: and r5.y, r5.y, l(0x7fffffff)  \n  216: itof r5.y, r5.y  \n  217: frc r0.w, r0.w  \n  218: add r0.w, -r0.w, l(1.000000)  \n  219: mul r5.z, r0.w, r0.w  \n  220: mul r0.w, r0.w, r5.z  \n  221: mul r5.xz, r5.xxzx, l(0.000000001, 0.000000, 3.000000, 0.000000)  \n  222: mad r0.w, r0.w, l(-2.000000), r5.z  \n  223: frc r2.w, r2.w  \n  224: add r2.w, -r2.w, l(1.000000)  \n  225: mul r5.z, r2.w, r2.w  \n  226: mul r2.w, r2.w, r5.z  \n  227: mul r5.z, r5.z, l(3.000000)  \n  228: mad r2.w, r2.w, l(-2.000000), r5.z  \n  229: mad r4.w, r4.w, l(0.000000001), -r5.x  \n  230: mad r4.w, r0.w, r4.w, r5.x  \n  231: mad r5.x, r5.y, l(0.000000001), -r1.w  \n  232: mad r0.w, r0.w, r5.x, r1.w  \n  233: add r0.w, -r4.w, r0.w  \n  234: mad r0.w, r2.w, r0.w, r4.w  \n  235: mad r2.xyz, r0.wwww, l(0.000500, 0.000500, 0.000500, 0.000000), r2.xyzx  \n  236: sample_indexable(texturecube)(float,float,float,float) r2.xyz, r2.xyzx, t0.xyzw, s0  \n  237: log r4.xyz, r4.xyzx  \n  238: mul r4.xyz, r4.xyzx, l(2.200000, 2.200000, 2.200000, 0.000000)  \n  239: exp r4.xyz, r4.xyzx  \n  240: log r2.xyz, r2.xyzx  \n  241: mul r2.xyz, r2.xyzx, l(2.200000, 2.200000, 2.200000, 0.000000)  \n  242: exp r2.xyz, r2.xyzx  \n  243: mul r2.xyz, r2.xyzx, r4.xyzx\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E \u003Cbr\u002F\u003E\r\nХм. Давайте взглянем в конец этого достаточно длинного ассемблерного кода.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nПосле сэмплирования \u003Ci\u003EstarsColor\u003C\u002Fi\u003E в строке 173 мы вычисляем какое-то значение \u003Ci\u003Eoffset\u003C\u002Fi\u003E. Это \u003Ci\u003Eoffset\u003C\u002Fi\u003E используется для искажения первого направления сэмплирования (r2.xyz, строка 235), а затем снова сэмплируем кубическую карту звёзд, выполняем гамма-коррекцию этих двух значений (237-242) и перемножаем их (243).\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nПросто, не правда ли? Ну, не совсем. Давайте немного подумаем об этом \u003Ci\u003Eoffset\u003C\u002Fi\u003E. Это значение должно быть разным на протяжении всего skydome — одинаково мерцающие звёзды выглядели бы очень нереалистично.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nЧтобы \u003Ci\u003Eoffset\u003C\u002Fi\u003E было как можно более разнообразным, мы воспользуемся тем, что UV растянуты на skydome (v0.xy) и применим прошедшее время, хранящееся в буфере констант (cb[0].x).\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nЕсли вам незнакомы эти пугающие ishr\u002Fxor\u002Fand, то в части про эффект молний прочитайте об целочисленном шуме.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nКак видите, целочисленный шум вызывается здесь четыре раза, но он отличается от того, который используется для молний. Чтобы сделать результаты ещё более случайными, входящее целое число для шума является суммой (\u003Ci\u003Eiadd\u003C\u002Fi\u003E) и с ним выполняется инвертирование битов (внутренняя функция \u003Ca href=\"https:\u002F\u002Fdocs.microsoft.com\u002Fen-us\u002Fwindows\u002Fdesktop\u002Fdirect3dhlsl\u002Freversebits\"\u003Ereversebits\u003C\u002Fa\u003E; инструкция \u003Ca href=\"https:\u002F\u002Fdocs.microsoft.com\u002Fen-us\u002Fwindows\u002Fdesktop\u002Fdirect3dhlsl\u002Fbfrev---sm5---asm-\"\u003Ebfrev\u003C\u002Fa\u003E).\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nТак, а теперь помедленнее. Давайте начнём с самого начала.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nУ нас есть 4 «итерации» целочисленного шума. Я проанализировал ассемблерный код, вычисления всех 4 итераций выглядят так:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"cpp\"\u003E int getInt( float x )\n {\n     return asint( floor(x) );\n }\n \n int getReverseInt( float x )\n {\n     return reversebits( getInt(x) );\n }\n\n \u002F\u002F * Inputs - UV and elapsed time in seconds  \n float2 starsUV;  \n starsUV.x = 100.0 * Input.TextureUV.x;       \n starsUV.y = 50.0  * Input.TextureUV.y + g_fTime;  \n             \n \u002F\u002F * Iteration 1  \n int iStars1_A = getReverseInt( starsUV.y );\n int iStars1_B = getInt( starsUV.x );            \n   \n float fStarsNoise1 = integerNoise( iStars1_A + iStars1_B );  \n             \n   \n \u002F\u002F * Iteration 2  \n int iStars2_A = getReverseInt( starsUV.y );  \n int iStars2_B = getInt( starsUV.x - 1.0 ); \n   \n float fStarsNoise2 = integerNoise( iStars2_A + iStars2_B );  \n        \n   \n \u002F\u002F * Iteration 3  \n int iStars3_A = getReverseInt( starsUV.y - 1.0 );\n int iStars3_B = getInt( starsUV.x );\n   \n float fStarsNoise3 = integerNoise( iStars3_A + iStars3_B );  \n             \n   \n \u002F\u002F * Iteration 4  \n int iStars4_A = getReverseInt( starsUV.y - 1.0 ); \n int iStars4_B = getInt( starsUV.x - 1.0 ); \n   \n float fStarsNoise4 = integerNoise( iStars4_A + iStars4_B );\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nКонечные выходные данные всех 4 итераций (чтобы найти их, проследите за инструкциями \u003Ci\u003Eitof\u003C\u002Fi\u003E):\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nИтерация 1 — r5.x,\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nИтерация 2 — r4.w,\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nИтерация 3 — r1.w,\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nИтерация 4 — r5.y\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nПосле последней \u003Ci\u003Eitof\u003C\u002Fi\u003E (строка 216) мы имеем:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"cpp\"\u003E  217: frc r0.w, r0.w   \n  218: add r0.w, -r0.w, l(1.000000)   \n  219: mul r5.z, r0.w, r0.w   \n  220: mul r0.w, r0.w, r5.z   \n  221: mul r5.xz, r5.xxzx, l(0.000000001, 0.000000, 3.000000, 0.000000)   \n  222: mad r0.w, r0.w, l(-2.000000), r5.z   \n  223: frc r2.w, r2.w   \n  224: add r2.w, -r2.w, l(1.000000)   \n  225: mul r5.z, r2.w, r2.w   \n  226: mul r2.w, r2.w, r5.z   \n  227: mul r5.z, r5.z, l(3.000000)   \n  228: mad r2.w, r2.w, l(-2.000000), r5.z\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nЭти строки вычисляют значения S-образной кривой для весов на основании дробной части UV, как и в случае с молниями. Итак:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"cpp\"\u003E  float s_curve( float x )   \n  {   \n    float x2 = x * x;   \n    float x3 = x2 * x;   \n      \n    \u002F\u002F -2x^3 + 3x^2   \n    return -2.0*x3 + 3.0*x2;   \n  }  \n   \n ...  \n \n \u002F\u002F lines 217-222\n float weightX = 1.0 - frac( starsUV.x );  \n weightX = s_curve( weightX );  \n   \n \u002F\u002F lines 223-228\n float weightY = 1.0 - frac( starsUV.y );  \n weightY = s_curve( weightY );\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nКак и можно ожидать, эти коэффициенты используются для плавной интерполяции шума и генерации окончательного смещения для координат сэмплирования:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"cpp\"\u003E  229: mad r4.w, r4.w, l(0.000000001), -r5.x   \n  230: mad r4.w, r0.w, r4.w, r5.x   \n  float noise0 = lerp( fStarsNoise1, fStarsNoise2, weightX );  \n   \n  231: mad r5.x, r5.y, l(0.000000001), -r1.w   \n  232: mad r0.w, r0.w, r5.x, r1.w   \n  float noise1 = lerp( fStarsNoise3, fStarsNoise4, weightX );  \n   \n  233: add r0.w, -r4.w, r0.w   \n  234: mad r0.w, r2.w, r0.w, r4.w   \n  float offset = lerp( noise0, noise1, weightY );            \n   \n  235: mad r2.xyz, r0.wwww, l(0.000500, 0.000500, 0.000500, 0.000000), r2.xyzx   \n  236: sample_indexable(texturecube)(float,float,float,float) r2.xyz, r2.xyzx, t0.xyzw, s0   \n  float3 starsPerturbedDir = dirXYZ + offset * 0.0005;  \n    \n  float3 starsColorDisturbed = texNightStars.Sample( samplerAnisoWrap, starsPerturbedDir ).rgb;\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nВот небольшая визуализация вычисленного \u003Ci\u003Eoffset\u003C\u002Fi\u003E:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cdiv class=\"oembed\"\u003E\u003Cdiv\u003E\u003Cdiv style=\"left: 0; width: 100%; height: 0; position: relative; padding-bottom: 56.2493%;\"\u003E\u003Cdiv class=\"tm-iframe_temp\" data-src=\"https:\u002F\u002Fwww.youtube.com\u002Fembed\u002FSAI-cLJFpfg?rel=0&amp;showinfo=1&amp;hl=en-US\" data-style=\"border: 0; top: 0; left: 0; width: 100%; height: 100%; position: absolute;\" id=\"\" width=\"\"\u003E\u003C\u002Fdiv\u003E\u003C\u002Fdiv\u003E\u003C\u002Fdiv\u003E\u003C\u002Fdiv\u003E\u003Cbr\u002F\u003E\r\nПосле вычисления \u003Ci\u003EstarsColorDisturbed\u003C\u002Fi\u003E самая сложная часть завершена. Ура!\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nСледующий этап — выполнение гамма-коррекции и для \u003Ci\u003EstarsColor\u003C\u002Fi\u003E, и для \u003Ci\u003EstarsColorDisturbed\u003C\u002Fi\u003E, после чего они перемножаются:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"cpp\"\u003E  starsColor = pow( starsColor, 2.2 );  \n  starsColorDisturbed = pow( starsColorDisturbed, 2.2 );  \n   \n  float3 starsFinal = starsColor * starsColorDisturbed;\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E \u003Cbr\u002F\u003E\r\n\u003Ch4\u003EЗвёзды — финальные штрихи\u003C\u002Fh4\u003E\u003Cbr\u002F\u003E\r\nУ нас есть \u003Ci\u003EstarsFinal \u003C\u002Fi\u003Ein r1.xyz. В конце обработки звёзд происходит следующее:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"cpp\"\u003E  256: log r1.xyz, r1.xyzx  \n  257: mul r1.xyz, r1.xyzx, l(2.500000, 2.500000, 2.500000, 0.000000)  \n  258: exp r1.xyz, r1.xyzx  \n  259: min r1.xyz, r1.xyzx, l(1.000000, 1.000000, 1.000000, 0.000000)  \n  260: add r0.w, -cb0[9].w, l(1.000000)  \n  261: mul r1.xyz, r0.wwww, r1.xyzx  \n  262: mul r1.xyz, r1.xyzx, l(10.000000, 10.000000, 10.000000, 0.000000)\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nЭто гораздо проще по сравнению с мерцающими и движущимися звёздами.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nИтак, мы начинаем с возведения \u003Ci\u003EstarsFinal\u003C\u002Fi\u003E в степень 2.5 — это позволяет нам контролировать плотность звёзд. Довольно умно. Затем мы делаем так, чтобы максимальный цвет звёзд был равен float3(1, 1, 1).\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\ncb0[9].w используется для управления общей видимостью звёзд. Поэтому можно ожидать, что в дневное время это значение равно 1.0 (что даёт умножение на ноль), а ночью — 0.0.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nВ конце мы увеличиваем видимость звёзд на 10. И на этом всё!\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Ch2\u003EЧасть 3. Ведьмачье чутьё (объекты и карта яркости)\u003C\u002Fh2\u003E\u003Cbr\u002F\u003E\r\nПочти все описанные ранее эффекты и техники на самом деле не были связаны с Witcher 3. Такие вещи, как тональная коррекция, виньетирование или вычисление средней яркости присутствуют практически в каждой современной игре. Даже эффект опьянения распространён довольно широко.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nИменно поэтому я решил внимательнее присмотреться к механикам рендеринга «ведьмачьего чутья». Геральт — ведьмак, а потому его чувства гораздо острее, чем у обычного человека. Следовательно, он может видеть и слышать больше, чем другие люди, что сильно помогает ему в расследованиях. Механика ведьмачьего чутья позволяет игроку визуализировать такие следы.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nВот демонстрация эффекта:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cdiv class=\"oembed\"\u003E\u003Cdiv\u003E\u003Cdiv style=\"left: 0; width: 100%; height: 0; position: relative; padding-bottom: 56.2493%;\"\u003E\u003Cdiv class=\"tm-iframe_temp\" data-src=\"https:\u002F\u002Fwww.youtube.com\u002Fembed\u002F794z0wbcI6U?rel=0&amp;showinfo=1&amp;hl=en-US\" data-style=\"border: 0; top: 0; left: 0; width: 100%; height: 100%; position: absolute;\" id=\"\" width=\"\"\u003E\u003C\u002Fdiv\u003E\u003C\u002Fdiv\u003E\u003C\u002Fdiv\u003E\u003C\u002Fdiv\u003E\u003Cbr\u002F\u003E\r\nИ ещё одна, с освещением получше:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cdiv class=\"oembed\"\u003E\u003Cdiv\u003E\u003Cdiv style=\"left: 0; width: 100%; height: 0; position: relative; padding-bottom: 56.2493%;\"\u003E\u003Cdiv class=\"tm-iframe_temp\" data-src=\"https:\u002F\u002Fwww.youtube.com\u002Fembed\u002FReB6IrOb3ic?rel=0&amp;showinfo=1&amp;hl=en-US\" data-style=\"border: 0; top: 0; left: 0; width: 100%; height: 100%; position: absolute;\" id=\"\" width=\"\"\u003E\u003C\u002Fdiv\u003E\u003C\u002Fdiv\u003E\u003C\u002Fdiv\u003E\u003C\u002Fdiv\u003E\u003Cbr\u002F\u003E\r\nКак видите, есть два типа объектов: те, с которыми Геральт может взаимодействовать (жёлтый контур) и следы, связанные с расследованием (красный контур). После того, как Геральт исследует красный след, он может превратиться в жёлтый (первое видео). Заметьте, что весь экран становится серее и добавляется эффект «рыбьего глаза (второе видео).\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nЭтот эффект довольно сложен, поэтому я решил разделить его исследование на три части.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nВ первой я расскажу о выборе объектов, во второй — о генерации контура, а в третьей — о финальном объединении всего этого в одно целое.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Ch3\u003EВыбор объектов\u003C\u002Fh3\u003E\u003Cbr\u002F\u003E\r\nКак я и говорил, существует два типа объектов, и нам нужно их различать. В Witcher 3 это реализовано с помощью стенсил-буфера. При генерации мешей GBuffer, которые должны быть помечены как „следы“ (красные), они рендерятся со stencil = 8. Меши, помеченные жёлтым цветом как „интересные“ объекты, рендерятся со stencil = 4.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nНапример, следующие две текстуры показывают пример кадра с видимым ведьмачьим чутьём и соответствующий стенсил-буфер:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cdiv style=\"text-align:center;\"\u003E\u003Cimg src=\"https:\u002F\u002F1.bp.blogspot.com\u002F-oQKKd9lbcLQ\u002FXKihDzw4ZuI\u002FAAAAAAAABbo\u002FeL4YOcpG3cEHsOLYBg-Gg-XqoO-bUq_VACPcBGAYYCw\u002Fs1600\u002Fbefore.jpg\" data-src=\"https:\u002F\u002F1.bp.blogspot.com\u002F-oQKKd9lbcLQ\u002FXKihDzw4ZuI\u002FAAAAAAAABbo\u002FeL4YOcpG3cEHsOLYBg-Gg-XqoO-bUq_VACPcBGAYYCw\u002Fs1600\u002Fbefore.jpg\" data-blurred=\"true\"\u002F\u003E\u003C\u002Fdiv\u003E\u003Cbr\u002F\u003E\r\n\u003Cdiv style=\"text-align:center;\"\u003E\u003Cimg src=\"https:\u002F\u002F3.bp.blogspot.com\u002F-AOosFwY75Ro\u002FXKYJB5udsvI\u002FAAAAAAAABYM\u002Fo4gon6rPw8wWawHMC0-VLYqzOMeN8MGfgCLcBGAs\u002Fs1600\u002F02_stencil.jpg\" data-src=\"https:\u002F\u002F3.bp.blogspot.com\u002F-AOosFwY75Ro\u002FXKYJB5udsvI\u002FAAAAAAAABYM\u002Fo4gon6rPw8wWawHMC0-VLYqzOMeN8MGfgCLcBGAs\u002Fs1600\u002F02_stencil.jpg\" data-blurred=\"true\"\u002F\u003E\u003C\u002Fdiv\u003E\u003Cbr\u002F\u003E\r\n\u003Ch4\u003EВкратце о стенсил-буфере\u003C\u002Fh4\u003E\u003Cbr\u002F\u003E\r\nСтенсил-буфер довольно часто используется в играх для пометки мешей. Определённым категориям мешей назначается одинаковый ID.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nИдея заключается в том, чтобы использовать функцию \u003Ci\u003EAlways\u003C\u002Fi\u003E с оператором \u003Ci\u003EReplace\u003C\u002Fi\u003E, если стенсил-тест оказался успешным, и с оператором \u003Ci\u003EKeep\u003C\u002Fi\u003E во всех остальных случаях.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nВот как это реализуется с помощью D3D11:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"cpp\"\u003E D3D11_DEPTH_STENCIL_DESC depthstencilState;  \n \u002F\u002F Set depth parameters....  \n   \n \u002F\u002F Enable stencil  \n depthstencilState.StencilEnable = TRUE;  \n   \n \u002F\u002F Read &amp; write all bits  \n depthstencilState.StencilReadMask = 0xFF;  \n depthstencilState.StencilWriteMask = 0xFF;  \n   \n \u002F\u002F Stencil operator for front face  \n depthstencilState.FrontFace.StencilFunc = D3D11_COMPARISON_ALWAYS;  \n depthstencilState.FrontFace.StencilDepthFailOp = D3D11_STENCIL_OP_KEEP;  \n depthstencilState.FrontFace.StencilFailOp = D3D11_STENCIL_OP_KEEP;  \n depthstencilState.FrontFace.StencilPassOp = D3D11_STENCIL_OP_REPLACE;  \n   \n \u002F\u002F Stencil operator for back face.  \n depthstencilState.BackFace.StencilFunc = D3D11_COMPARISON_ALWAYS;  \n depthstencilState.BackFace.StencilDepthFailOp = D3D11_STENCIL_OP_KEEP;  \n depthstencilState.BackFace.StencilFailOp = D3D11_STENCIL_OP_KEEP;  \n depthstencilState.BackFace.StencilPassOp = D3D11_STENCIL_OP_REPLACE;  \n   \n pDevice-\u003ECreateDepthStencilState( &amp;depthstencilState, &amp;m_pDS_AssignValue );\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nЗначение стенсила, которое нужно записать в буфер, передаётся как \u003Ci\u003EStencilRef\u003C\u002Fi\u003E в вызове API:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"cpp\"\u003E \u002F\u002F from now on set stencil buffer values to 8  \n pDevCon-\u003EOMSetDepthStencilState( m_pDS_AssignValue, 8 );  \n ...  \n pDevCon-\u003EDrawIndexed( ... );\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003Ch4\u003EЯркость рендеринга\u003C\u002Fh4\u003E\u003Cbr\u002F\u003E\r\nВ этом проходе с точки зрения реализации есть одна полноэкранная текстура в формате R11G11B10_FLOAT, в которую интересные объекты и следы сохраняются в каналы R и G.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nЗачем это нужно нам с точки зрения яркости? Оказывается, что чутьё Геральта имеет ограниченный радиус, поэтому объекты получают контуры, только когда игрок находится достаточно близко к ним.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nПосмотрите на этот аспект в действии:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cdiv class=\"oembed\"\u003E\u003Cdiv\u003E\u003Cdiv style=\"left: 0; width: 100%; height: 0; position: relative; padding-bottom: 56.2493%;\"\u003E\u003Cdiv class=\"tm-iframe_temp\" data-src=\"https:\u002F\u002Fwww.youtube.com\u002Fembed\u002FXbs-ZRJ7v1w?rel=0&amp;showinfo=1&amp;hl=en-US\" data-style=\"border: 0; top: 0; left: 0; width: 100%; height: 100%; position: absolute;\" id=\"\" width=\"\"\u003E\u003C\u002Fdiv\u003E\u003C\u002Fdiv\u003E\u003C\u002Fdiv\u003E\u003C\u002Fdiv\u003E\u003Cbr\u002F\u003E\r\n\u003Cdiv style=\"text-align:center;\"\u003E\u003Cimg src=\"https:\u002F\u002F4.bp.blogspot.com\u002F-yUB1rKs9M40\u002FXKYJCPmhZ1I\u002FAAAAAAAABYU\u002FPyxObK2KCsoV7DkIfWk_w1HaJHydhGFIQCEwYBhgL\u002Fs1600\u002F01_tex.jpg\" data-src=\"https:\u002F\u002F4.bp.blogspot.com\u002F-yUB1rKs9M40\u002FXKYJCPmhZ1I\u002FAAAAAAAABYU\u002FPyxObK2KCsoV7DkIfWk_w1HaJHydhGFIQCEwYBhgL\u002Fs1600\u002F01_tex.jpg\" data-blurred=\"true\"\u002F\u003E\u003C\u002Fdiv\u003E\u003Cbr\u002F\u003E\r\nМы начинаем с очистки текстуры яркости, заливая её чёрным цветом.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nЗатем выполняются два полноэкранных вызова отрисовки: первый для „следова“, второй — для интересных объектов:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cdiv style=\"text-align:center;\"\u003E\u003Cimg src=\"https:\u002F\u002F1.bp.blogspot.com\u002F-6loAAWznr9M\u002FXKYfSvZPYEI\u002FAAAAAAAABYk\u002FP7W-zj7mUCkZee1DF02fzpoqgPWfaSgNQCLcBGAs\u002Fs1600\u002F03_calss.JPG\"\u002F\u003E\u003C\u002Fdiv\u003E\u003Cbr\u002F\u003E\r\nПервый вызов отрисовки выполняется для следов — зелёный канал:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cdiv style=\"text-align:center;\"\u003E\u003Cimg src=\"https:\u002F\u002F4.bp.blogspot.com\u002F-9Es1Q69_1SM\u002FXKYfSqAV5_I\u002FAAAAAAAABYg\u002FZO9WpSCerzoDPRD50VOthnPw_5vd7eATgCEwYBhgL\u002Fs1600\u002F04_traces1.jpg\" data-src=\"https:\u002F\u002F4.bp.blogspot.com\u002F-9Es1Q69_1SM\u002FXKYfSqAV5_I\u002FAAAAAAAABYg\u002FZO9WpSCerzoDPRD50VOthnPw_5vd7eATgCEwYBhgL\u002Fs1600\u002F04_traces1.jpg\" data-blurred=\"true\"\u002F\u003E\u003C\u002Fdiv\u003E\u003Cbr\u002F\u003E\r\nВторой вызов выполняется для интересных объектов — красный канал:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cdiv style=\"text-align:center;\"\u003E\u003Cimg src=\"https:\u002F\u002F1.bp.blogspot.com\u002F-CTI51-PHhs4\u002FXKYfS1Bpg_I\u002FAAAAAAAABY8\u002F0ePZBCxKi7YULIPu1l4T-uXopU2bzwI6wCEwYBhgL\u002Fs1600\u002F05_interesting.jpg\" data-src=\"https:\u002F\u002F1.bp.blogspot.com\u002F-CTI51-PHhs4\u002FXKYfS1Bpg_I\u002FAAAAAAAABY8\u002F0ePZBCxKi7YULIPu1l4T-uXopU2bzwI6wCEwYBhgL\u002Fs1600\u002F05_interesting.jpg\" data-blurred=\"true\"\u002F\u003E\u003C\u002Fdiv\u003E\u003Cbr\u002F\u003E\r\nНу ладно, но как нам определить, какие пиксели нужно учитывать? Придётся воспользоваться стенсил-буфером!\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nПри каждом из этих вызовов выполняется стенсил-тест, и принимаются только те пиксели, которые были ранее помечены как „8“ (первый вызов отрисовки) или „4“.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nВизуализация стенсил-теста для следов:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cdiv style=\"text-align:center;\"\u003E\u003Cimg src=\"https:\u002F\u002F3.bp.blogspot.com\u002F-Of3CW0wayus\u002FXKYfSX76AOI\u002FAAAAAAAABY0\u002F_ZKvXiHQdj0Gf9bf4BSvznwKG0ZrwxK8gCEwYBhgL\u002Fs1600\u002F04_traces1_stenciltest.JPG\"\u002F\u003E\u003C\u002Fdiv\u003E\u003Cbr\u002F\u003E\r\n… и для интересных объектов:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cdiv style=\"text-align:center;\"\u003E\u003Cimg src=\"https:\u002F\u002F4.bp.blogspot.com\u002F-2N_SzHITO5M\u002FXKYfTLF3E-I\u002FAAAAAAAABZA\u002FnA6s23G3JGQrz3wY_Rf9DKO8BsMpMUs9wCEwYBhgL\u002Fs1600\u002F06_interesting_stencil.JPG\"\u002F\u003E\u003C\u002Fdiv\u003E\u003Cbr\u002F\u003E\r\nКак в этом случае выполняется тест? Об основах стенсил-тестирования можно узнать в хорошем \u003Ca href=\"http:\u002F\u002Fwww.asawicki.info\u002Fnews_1654_stencil_test_explained_using_code.html\"\u003Eпосте\u003C\u002Fa\u003E. В общем виде формула стенсил-теста имеет следующий вид:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"cpp\"\u003E if (StencilRef &amp; StencilReadMask OP StencilValue &amp; StencilReadMask)  \n   accept pixel  \n else  \n   discard pixel\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nгде:\u003Cbr\u002F\u003E\r\n\u003Ci\u003EStencilRef\u003C\u002Fi\u003E — значение, передаваемое вызовом API,\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Ci\u003EStencilReadMask\u003C\u002Fi\u003E — маска, используемая для чтения значения стенсила (учтите, что она присутствует и на левой, и на правой части),\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Ci\u003EOP\u003C\u002Fi\u003E — оператор сравнения, задаётся через API,\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Ci\u003EStencilValue\u003C\u002Fi\u003E — значение стенсил-буфера в текущем обрабатываемом пикселе.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nВажно понимать, что для вычисления операндов мы используем двоичные AND.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nПознакомившись с основами, давайте посмотрим, как эти параметры используются в данных вызовах отрисовки:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cdiv style=\"text-align:center;\"\u003E\u003Cimg src=\"https:\u002F\u002F2.bp.blogspot.com\u002F-IKI0ksekBRQ\u002FXKYjUwlcuRI\u002FAAAAAAAABZM\u002FyH9sPWaoNwUoXSXRwCurljKCi4UAwCcMgCLcBGAs\u002Fs1600\u002F08_settings_traces.JPG\"\u002F\u003E\u003C\u002Fdiv\u003E\u003Cbr\u002F\u003E\r\n\u003Ci\u003EСостояние стенсила для следов\u003C\u002Fi\u003E\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cdiv style=\"text-align:center;\"\u003E\u003Cimg src=\"https:\u002F\u002F4.bp.blogspot.com\u002F-vs_30dlApMc\u002FXKYjU3fQtNI\u002FAAAAAAAABZI\u002FML-CG4E-L2kdr2FlPvhGrg7gu125bscFwCLcBGAs\u002Fs1600\u002F09_settings_interesting.JPG\"\u002F\u003E\u003C\u002Fdiv\u003E\u003Cbr\u002F\u003E\r\n\u003Ci\u003EСостояние стенсила для интересных объектов\u003C\u002Fi\u003E\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nХа! Как мы видим, единственное отличие заключается в ReadMask. Давайте проверим это! Подставим эти значения в уравнение стенсил-теста:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"cpp\"\u003E Let StencilReadMask = 0x08 and StencilRef = 0:  \n   \n For a pixel with stencil = 8:  \n 0 &amp; 0x08 &lt; 8 &amp; 0x08  \n 0 &lt; 8\n TRUE  \n   \n For a pixel with stencil = 4:  \n 0 &amp; 0x08 &lt; 4 &amp; 0x08  \n 0 &lt; 0  \n FALSE\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nУмно. Как видите, в этом случае мы сравниваем не значение стенсила, а проверяем задан ли определённый бит стенсил-буфера. Каждый пиксель стенсил-буфера имеет формат uint8, поэтому интервал значений составляет [0-255].\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nПримечание: все вызовы \u003Ci\u003EDrawIndexed(36)\u003C\u002Fi\u003E связаны с рендерингом отпечатков ног как следов, поэтому в этом конкретном кадре карта яркости имеет следующий окончательный вид:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cdiv style=\"text-align:center;\"\u003E\u003Cimg src=\"https:\u002F\u002F3.bp.blogspot.com\u002F-BDtw1sdtDJU\u002FXKYfTAGCenI\u002FAAAAAAAABY4\u002FmLUu8NxQ-MUtxB71zgYEKtb9yTsWiKNkgCEwYBhgL\u002Fs1600\u002F07_final.jpg\" data-src=\"https:\u002F\u002F3.bp.blogspot.com\u002F-BDtw1sdtDJU\u002FXKYfTAGCenI\u002FAAAAAAAABY4\u002FmLUu8NxQ-MUtxB71zgYEKtb9yTsWiKNkgCEwYBhgL\u002Fs1600\u002F07_final.jpg\" data-blurred=\"true\"\u002F\u003E\u003C\u002Fdiv\u003E\u003Cbr\u002F\u003E\r\nНо перед стенсил-тестом есть пиксельный шейдер. И 28738, и 28748 используют одинаковый пиксельный шейдер:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"cpp\"\u003E ps_5_0  \n    dcl_globalFlags refactoringAllowed  \n    dcl_constantbuffer cb0[2], immediateIndexed  \n    dcl_constantbuffer cb3[8], immediateIndexed  \n    dcl_constantbuffer cb12[214], immediateIndexed  \n    dcl_sampler s15, mode_default  \n    dcl_resource_texture2d (float,float,float,float) t15  \n    dcl_input_ps_siv v0.xy, position  \n    dcl_output o0.xyzw  \n    dcl_output o1.xyzw  \n    dcl_output o2.xyzw  \n    dcl_output o3.xyzw  \n    dcl_temps 2  \n   0: mul r0.xy, v0.xyxx, cb0[1].zwzz  \n   1: sample_indexable(texture2d)(float,float,float,float) r0.x, r0.xyxx, t15.xyzw, s15  \n   2: mul r1.xyzw, v0.yyyy, cb12[211].xyzw  \n   3: mad r1.xyzw, cb12[210].xyzw, v0.xxxx, r1.xyzw  \n   4: mad r0.xyzw, cb12[212].xyzw, r0.xxxx, r1.xyzw  \n   5: add r0.xyzw, r0.xyzw, cb12[213].xyzw  \n   6: div r0.xyz, r0.xyzx, r0.wwww  \n   7: add r0.xyz, r0.xyzx, -cb3[7].xyzx  \n   8: dp3 r0.x, r0.xyzx, r0.xyzx  \n   9: sqrt r0.x, r0.x  \n  10: mul r0.y, r0.x, l(0.120000)  \n  11: log r1.x, abs(cb3[6].y)  \n  12: mul r1.xy, r1.xxxx, l(2.800000, 0.800000, 0.000000, 0.000000)  \n  13: exp r1.xy, r1.xyxx  \n  14: mad r0.zw, r1.xxxy, l(0.000000, 0.000000, 120.000000, 120.000000), l(0.000000, 0.000000, 1.000000, 1.000000)  \n  15: lt r1.x, l(0.030000), cb3[6].y  \n  16: movc r0.xy, r1.xxxx, r0.yzyy, r0.xwxx  \n  17: div r0.x, r0.x, r0.y  \n  18: log r0.x, r0.x  \n  19: mul r0.x, r0.x, l(1.600000)  \n  20: exp r0.x, r0.x  \n  21: add r0.x, -r0.x, l(1.000000)  \n  22: max r0.x, r0.x, l(0)  \n  23: mul o0.xyz, r0.xxxx, cb3[0].xyzx  \n  24: mov o0.w, cb3[0].w  \n  25: mov o1.xyzw, cb3[1].xyzw  \n  26: mov o2.xyzw, cb3[2].xyzw  \n  27: mov o3.xyzw, cb3[3].xyzw  \n  28: ret\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nЭтот пиксельный шейдер выполняет запись только в один render target, поэтому строки 24-27 избыточны.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nПервое, что здесь происходит — сэмплирование глубины (точечным сэмплером с ограничением значений), строка 1. Это значение используется для воссоздания позиции в мире умножением на специальную матрицу с последующим перспективным делением (строки 2-6).\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nВзяв позицию Геральта (cb3[7].xyz — учтите, что это \u003Ci\u003Eне\u003C\u002Fi\u003E позиция камеры!), мы вычисляем расстояние от Геральта до этой конкретной точки (строки 7-9).\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nВ этом шейдере важны следующие входные данные:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n — cb3[0].rgb — цвет вывода. Он может иметь формат float3(0, 1, 0) (следы) или float3(1, 0, 0) (интересные объекты),\u003Cbr\u002F\u003E\r\n — cb3[6].y — коэффициент масштабирования расстояния. Непосредственно влияет на радиус и яркость финальных выходных данных.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nПозже у нас идут довольно хитрые формулы для вычисления яркости в зависимости от расстояния между Геральтом и объектом. Могу предположить, что все коэффициенты подобраны экспериментально.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nФинальными выходными данными являются \u003Ci\u003Ecolor\u003C\u002Fi\u003E*\u003Ci\u003Eintensity\u003C\u002Fi\u003E.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nКод на HLSL будет выглядеть примерно так:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"cpp\"\u003E struct FSInput  \n {  \n      float4 param0 : SV_Position;  \n };  \n   \n struct FSOutput  \n {  \n      float4 param0 : SV_Target0;  \n      float4 param1 : SV_Target1;  \n      float4 param2 : SV_Target2;  \n      float4 param3 : SV_Target3;  \n };  \n   \n float3 getWorldPos( float2 screenPos, float depth )  \n {  \n   float4 worldPos = float4(screenPos, depth, 1.0);  \n   worldPos = mul( worldPos, screenToWorld );  \n     \n   return worldPos.xyz \u002F worldPos.w;  \n }  \n   \n FSOutput EditedShaderPS(in FSInput IN)  \n {  \n   \u002F\u002F * Inputs    \n   \u002F\u002F Directly affects radius of the effect  \n   float distanceScaling = cb3_v6.y;  \n     \n   \u002F\u002F Color of output at the end  \n   float3 color = cb3_v0.rgb;  \n        \n\n   \u002F\u002F Sample depth  \n   float2 uv = IN.param0.xy * cb0_v1.zw;  \n   float depth = texture15.Sample( sampler15, uv ).x;  \n     \n   \u002F\u002F Reconstruct world position  \n   float3 worldPos = getWorldPos( IN.param0.xy, depth );  \n   \n   \u002F\u002F Calculate distance from Geralt to world position of particular object  \n   float dist_geraltToWorld = length( worldPos - cb3_v7.xyz );  \n     \n   \u002F\u002F Calculate two squeezing params  \n   float t0 = 1.0 + 120*pow( abs(distanceScaling), 2.8 );  \n   float t1 = 1.0 + 120*pow( abs(distanceScaling), 0.8 );  \n     \n   \u002F\u002F Determine nominator and denominator  \n   float2 params;  \n   params = (distanceScaling \u003E 0.03) ? float2(dist_geraltToWorld * 0.12, t0) : float2(dist_geraltToWorld, t1);  \n     \n   \u002F\u002F Distance Geralt &lt;-\u003E Object  \n   float nominator = params.x;   \n     \n   \u002F\u002F Hiding factor  \n   float denominator = params.y;  \n     \n   \u002F\u002F Raise to power of 1.6  \n   float param = pow( params.x \u002F params.y, 1.6 );  \n     \n   \u002F\u002F Calculate final intensity  \n   float intensity = max(0.0, 1.0 - param );   \n     \n     \n   \u002F\u002F * Final outputs.  \n   \u002F\u002F *  \n   \u002F\u002F * This PS outputs only one color, the rest  \n   \u002F\u002F * is redundant. I just added this to keep 1-1 ratio with  \n   \u002F\u002F * original assembly.  \n   FSOutput OUT = (FSOutput)0;  \n   OUT.param0.xyz = color * intensity;  \n     \n   \u002F\u002F == redundant ==  \n   OUT.param0.w = cb3_v0.w;  \n   OUT.param1 = cb3_v1;  \n   OUT.param2 = cb3_v2;  \n   OUT.param3 = cb3_v3;  \n   \u002F\u002F ===============  \n   \n   return OUT;  \n }\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E \u003Cbr\u002F\u003E\r\nНебольшое сравнение оригинального (слева) и моего (справа) ассемблерного кода шейдера.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cdiv style=\"text-align:center;\"\u003E\u003Cimg src=\"https:\u002F\u002F3.bp.blogspot.com\u002F-ZC1xPT4vpYU\u002FXKaEOeOLXYI\u002FAAAAAAAABZc\u002FboAqQidXEv0ee4O5alCSpLIoNI52v_qWwCLcBGAs\u002Fs1600\u002F10_comparison.JPG\"\u002F\u003E\u003C\u002Fdiv\u003E\u003Cbr\u002F\u003E\r\nЭто был первый этап эффекта \u003Ci\u003Eведьмачьего чутья\u003C\u002Fi\u003E. На самом деле, он самый простой.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Ch2\u003EЧасть 4. Ведьмачье чутьё (карта контуров)\u003C\u002Fh2\u003E\u003Cbr\u002F\u003E\r\nЕщё раз взглянем на исследуемую нами сцену:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cdiv style=\"text-align:center;\"\u003E\u003Cimg src=\"https:\u002F\u002F1.bp.blogspot.com\u002F-oQKKd9lbcLQ\u002FXKihDzw4ZuI\u002FAAAAAAAABbo\u002FeL4YOcpG3cEHsOLYBg-Gg-XqoO-bUq_VACPcBGAYYCw\u002Fs1600\u002Fbefore.jpg\" data-src=\"https:\u002F\u002F1.bp.blogspot.com\u002F-oQKKd9lbcLQ\u002FXKihDzw4ZuI\u002FAAAAAAAABbo\u002FeL4YOcpG3cEHsOLYBg-Gg-XqoO-bUq_VACPcBGAYYCw\u002Fs1600\u002Fbefore.jpg\" data-blurred=\"true\"\u002F\u003E\u003C\u002Fdiv\u003E\u003Cbr\u002F\u003E\r\nВ первой части разбора эффекта ведьмачьего чутья я показал, как генерируется „карта яркости“.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nУ нас есть одна полноэкранная текстура формата R11G11B10_FLOAT, которая может выглядеть вот так:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cdiv style=\"text-align:center;\"\u003E\u003Cimg src=\"https:\u002F\u002F3.bp.blogspot.com\u002F-BDtw1sdtDJU\u002FXKYfTAGCenI\u002FAAAAAAAABY4\u002Fin1Mfyn1cz0JnmtQ2dfrtoh0z_l3DPiQACPcBGAYYCw\u002Fs1600\u002F07_final.jpg\" data-src=\"https:\u002F\u002F3.bp.blogspot.com\u002F-BDtw1sdtDJU\u002FXKYfTAGCenI\u002FAAAAAAAABY4\u002Fin1Mfyn1cz0JnmtQ2dfrtoh0z_l3DPiQACPcBGAYYCw\u002Fs1600\u002F07_final.jpg\" data-blurred=\"true\"\u002F\u003E\u003C\u002Fdiv\u003E\u003Cbr\u002F\u003E\r\nЗелёный канал обозначает „следы“, красный — интересные объекты, с которыми может взаимодействовать Геральт.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nПолучив эту текстуру, мы можем переходить к следующему этапу — я назвал его „карта контуров“.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cdiv style=\"text-align:center;\"\u003E\u003Cimg src=\"https:\u002F\u002F4.bp.blogspot.com\u002F--Ad03VW1EUI\u002FXKccbbi4d4I\u002FAAAAAAAABZo\u002FG3YbdjI7b-UbL-AslYxbPUKd_w1FSdI1ACLcBGAs\u002Fs1600\u002F01_outline.jpg\" data-src=\"https:\u002F\u002F4.bp.blogspot.com\u002F--Ad03VW1EUI\u002FXKccbbi4d4I\u002FAAAAAAAABZo\u002FG3YbdjI7b-UbL-AslYxbPUKd_w1FSdI1ACLcBGAs\u002Fs1600\u002F01_outline.jpg\" data-blurred=\"true\"\u002F\u003E\u003C\u002Fdiv\u003E\u003Cbr\u002F\u003E\r\nЭто немного странная текстура формата 512x512 R16G16_FLOAT. Здесь важно то, что она реализована в стиле „пинг-понг“. Карта контуров из предыдущего кадра является входящими данными (наряду с картой яркости) для генерации новой карты контуров в текущем кадре.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nБуферы „пинг-понга“ можно реализовать множеством способов, но лично мне больше всего нравится следующий (псевдокод):\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"cpp\"\u003E \u002F\u002F Declarations  \n Texture2D m_texOutlineMap[2];  \n uint m_outlineIndex = 0;  \n   \n \u002F\u002F Rendering  \n void Render()  \n {  \n   pDevCon-\u003ESetInputTexture( m_texOutlineMap[m_outlineIndex] );  \n   pDevCon-\u003ESetOutputTexture( m_texOutlineMap[!m_outlineIndex] );  \n   ...  \n   pDevCon-\u003EDraw(...);  \n   \n   \u002F\u002F after draw  \n   m_outlineIndex = !m_outlineIndex;  \n }\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nТакой подход, при котором на входе всегда \u003Ci\u003E[m_outlineIndex]\u003C\u002Fi\u003E, а на выходе всегда \u003Ci\u003E[!m_outlineIndex]\u003C\u002Fi\u003E, обеспечивает гибкость в отношении использования дальнейших постэффектов.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nДавайте взглянем на пиксельный шейдер:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"cpp\"\u003E ps_5_0  \n    dcl_globalFlags refactoringAllowed  \n    dcl_constantbuffer cb3[1], immediateIndexed  \n    dcl_sampler s0, mode_default  \n    dcl_sampler s1, mode_default  \n    dcl_resource_texture2d (float,float,float,float) t0  \n    dcl_resource_texture2d (float,float,float,float) t1  \n    dcl_input_ps linear v2.xy  \n    dcl_output o0.xyzw  \n    dcl_temps 4  \n   0: add r0.xyzw, v2.xyxy, v2.xyxy  \n   1: round_ni r1.xy, r0.zwzz  \n   2: frc r0.xyzw, r0.xyzw  \n   3: add r1.zw, r1.xxxy, l(0.000000, 0.000000, -1.000000, -1.000000)  \n   4: dp2 r1.z, r1.zwzz, r1.zwzz  \n   5: add r1.z, -r1.z, l(1.000000)  \n   6: max r2.w, r1.z, l(0)  \n   7: dp2 r1.z, r1.xyxx, r1.xyxx  \n   8: add r3.xyzw, r1.xyxy, l(-1.000000, -0.000000, -0.000000, -1.000000)  \n   9: add r1.x, -r1.z, l(1.000000)  \n  10: max r2.x, r1.x, l(0)  \n  11: dp2 r1.x, r3.xyxx, r3.xyxx  \n  12: dp2 r1.y, r3.zwzz, r3.zwzz  \n  13: add r1.xy, -r1.xyxx, l(1.000000, 1.000000, 0.000000, 0.000000)  \n  14: max r2.yz, r1.xxyx, l(0, 0, 0, 0)  \n  15: sample_indexable(texture2d)(float,float,float,float) r1.xyzw, r0.zwzz, t1.xyzw, s1  \n  16: dp4 r1.x, r1.xyzw, r2.xyzw  \n  17: add r2.xyzw, r0.zwzw, l(0.003906, 0.000000, -0.003906, 0.000000)  \n  18: add r0.xyzw, r0.xyzw, l(0.000000, 0.003906, 0.000000, -0.003906)  \n  19: sample_indexable(texture2d)(float,float,float,float) r1.yz, r2.xyxx, t1.zxyw, s1  \n  20: sample_indexable(texture2d)(float,float,float,float) r2.xy, r2.zwzz, t1.xyzw, s1  \n  21: add r1.yz, r1.yyzy, -r2.xxyx  \n  22: sample_indexable(texture2d)(float,float,float,float) r0.xy, r0.xyxx, t1.xyzw, s1  \n  23: sample_indexable(texture2d)(float,float,float,float) r0.zw, r0.zwzz, t1.zwxy, s1  \n  24: add r0.xy, -r0.zwzz, r0.xyxx  \n  25: max r0.xy, abs(r0.xyxx), abs(r1.yzyy)  \n  26: min r0.xy, r0.xyxx, l(1.000000, 1.000000, 0.000000, 0.000000)  \n  27: mul r0.xy, r0.xyxx, r1.xxxx  \n  28: sample_indexable(texture2d)(float,float,float,float) r0.zw, v2.xyxx, t0.zwxy, s0  \n  29: mad r0.w, r1.x, l(0.150000), r0.w  \n  30: mad r0.x, r0.x, l(0.350000), r0.w  \n  31: mad r0.x, r0.y, l(0.350000), r0.x  \n  32: mul r0.yw, cb3[0].zzzw, l(0.000000, 300.000000, 0.000000, 300.000000)  \n  33: mad r0.yw, v2.xxxy, l(0.000000, 150.000000, 0.000000, 150.000000), r0.yyyw  \n  34: ftoi r0.yw, r0.yyyw  \n  35: bfrev r0.w, r0.w  \n  36: iadd r0.y, r0.w, r0.y  \n  37: ishr r0.w, r0.y, l(13)  \n  38: xor r0.y, r0.y, r0.w  \n  39: imul null, r0.w, r0.y, r0.y  \n  40: imad r0.w, r0.w, l(0x0000ec4d), l(0.0000000000000000000000000000000000001)  \n  41: imad r0.y, r0.y, r0.w, l(146956042240.000000)  \n  42: and r0.y, r0.y, l(0x7fffffff)  \n  43: itof r0.y, r0.y  \n  44: mad r0.y, r0.y, l(0.000000001), l(0.650000)  \n  45: add_sat r1.xyzw, v2.xyxy, l(0.001953, 0.000000, -0.001953, 0.000000)  \n  46: sample_indexable(texture2d)(float,float,float,float) r0.w, r1.xyxx, t0.yzwx, s0  \n  47: sample_indexable(texture2d)(float,float,float,float) r1.x, r1.zwzz, t0.xyzw, s0  \n  48: add r0.w, r0.w, r1.x  \n  49: add_sat r1.xyzw, v2.xyxy, l(0.000000, 0.001953, 0.000000, -0.001953)  \n  50: sample_indexable(texture2d)(float,float,float,float) r1.x, r1.xyxx, t0.xyzw, s0  \n  51: sample_indexable(texture2d)(float,float,float,float) r1.y, r1.zwzz, t0.yxzw, s0  \n  52: add r0.w, r0.w, r1.x  \n  53: add r0.w, r1.y, r0.w  \n  54: mad r0.w, r0.w, l(0.250000), -r0.z  \n  55: mul r0.w, r0.y, r0.w  \n  56: mul r0.y, r0.y, r0.z  \n  57: mad r0.x, r0.w, l(0.900000), r0.x  \n  58: mad r0.y, r0.y, l(-0.240000), r0.x  \n  59: add r0.x, r0.y, r0.z  \n  60: mov_sat r0.z, cb3[0].x  \n  61: log r0.z, r0.z  \n  62: mul r0.z, r0.z, l(100.000000)  \n  63: exp r0.z, r0.z  \n  64: mad r0.z, r0.z, l(0.160000), l(0.700000)  \n  65: mul o0.xy, r0.zzzz, r0.xyxx  \n  66: mov o0.zw, l(0, 0, 0, 0)  \n  67: ret\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nКак видите, выходная карта контуров разделена на четыре равных квадрата, и это первое, что нам нужно изучить:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"cpp\"\u003E   0: add r0.xyzw, v2.xyxy, v2.xyxy  \n   1: round_ni r1.xy, r0.zwzz  \n   2: frc r0.xyzw, r0.xyzw  \n   3: add r1.zw, r1.xxxy, l(0.000000, 0.000000, -1.000000, -1.000000)  \n   4: dp2 r1.z, r1.zwzz, r1.zwzz  \n   5: add r1.z, -r1.z, l(1.000000)  \n   6: max r2.w, r1.z, l(0)  \n   7: dp2 r1.z, r1.xyxx, r1.xyxx  \n   8: add r3.xyzw, r1.xyxy, l(-1.000000, -0.000000, -0.000000, -1.000000)  \n   9: add r1.x, -r1.z, l(1.000000)  \n  10: max r2.x, r1.x, l(0)  \n  11: dp2 r1.x, r3.xyxx, r3.xyxx  \n  12: dp2 r1.y, r3.zwzz, r3.zwzz  \n  13: add r1.xy, -r1.xyxx, l(1.000000, 1.000000, 0.000000, 0.000000)  \n  14: max r2.yz, r1.xxyx, l(0, 0, 0, 0)\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E \u003Cbr\u002F\u003E\r\nМы начинаем с вычисления floor( TextureUV * 2.0 ), что даёт нам следующее:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cdiv style=\"text-align:center;\"\u003E\u003Cimg src=\"https:\u002F\u002F3.bp.blogspot.com\u002F-AumnXjrV4_Q\u002FXKdtEZvU0LI\u002FAAAAAAAABZ0\u002FQ9BkxBG_Vgki5lAsIBIqk4X8_zWELDdLACLcBGAs\u002Fs1600\u002F02_floor.JPG\"\u002F\u003E\u003C\u002Fdiv\u003E\u003Cbr\u002F\u003E\r\nДля определения отдельных квадратов используется небольшая функция:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"cpp\"\u003E float getParams(float2 uv)  \n {  \n      float d = dot(uv, uv);  \n      d = 1.0 - d;  \n      d = max( d, 0.0 );  \n   \n      return d;  \n }\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nЗаметьте, что функция возвращает 1.0 при входных данных float2(0.0, 0.0).\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nЭтот случай возникает в левом верхнем углу. Чтобы получить ту же ситуацию в верхнем правом углу, нужно вычесть из округлённых texcoords float2(1, 0), для зелёного квадрата вычесть float2(0, 1), а для жёлтого — float2(1.0, 1.0).\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nИтак:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"cpp\"\u003E   float2 flooredTextureUV = floor( 2.0 * TextureUV );  \n   ...\n     \n   float2 uv1 = flooredTextureUV;  \n   float2 uv2 = flooredTextureUV + float2(-1.0, -0.0);   \n   float2 uv3 = flooredTextureUV + float2( -0.0, -1.0);  \n   float2 uv4 = flooredTextureUV + float2(-1.0, -1.0);  \n   \n   float4 mask;  \n   mask.x = getParams( uv1 );  \n   mask.y = getParams( uv2 );  \n   mask.z = getParams( uv3 );  \n   mask.w = getParams( uv4 );\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nКаждый из компонентов \u003Ci\u003Emask\u003C\u002Fi\u003E равен или нулю, или единице, и ответственен за один квадрат текстуры. Например, \u003Ci\u003Emask.r\u003C\u002Fi\u003E и \u003Ci\u003Emask.w\u003C\u002Fi\u003E:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cdiv style=\"text-align:center;\"\u003E\u003Cimg src=\"https:\u002F\u002F2.bp.blogspot.com\u002F-HRLzcI0uREI\u002FXKd7WhdtqyI\u002FAAAAAAAABaA\u002F6MImHMFdD2kinZuF1J_2hNY3CoA5T6A6QCLcBGAs\u002Fs1600\u002F03_corner_r.jpg\" data-src=\"https:\u002F\u002F2.bp.blogspot.com\u002F-HRLzcI0uREI\u002FXKd7WhdtqyI\u002FAAAAAAAABaA\u002F6MImHMFdD2kinZuF1J_2hNY3CoA5T6A6QCLcBGAs\u002Fs1600\u002F03_corner_r.jpg\" data-blurred=\"true\"\u002F\u003E\u003C\u002Fdiv\u003E\u003Cbr\u002F\u003E\r\n\u003Ci\u003Emask.r\u003C\u002Fi\u003E\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cdiv style=\"text-align:center;\"\u003E\u003Cimg src=\"https:\u002F\u002F1.bp.blogspot.com\u002F-6bKah1ywVgE\u002FXKd7WkXIdfI\u002FAAAAAAAABaE\u002FMKIpXgMKxeobwGd8GvTNbDbrbGd4Vhm-wCLcBGAs\u002Fs1600\u002F03_corner_w.jpg\" data-src=\"https:\u002F\u002F1.bp.blogspot.com\u002F-6bKah1ywVgE\u002FXKd7WkXIdfI\u002FAAAAAAAABaE\u002FMKIpXgMKxeobwGd8GvTNbDbrbGd4Vhm-wCLcBGAs\u002Fs1600\u002F03_corner_w.jpg\" data-blurred=\"true\"\u002F\u003E\u003C\u002Fdiv\u003E\u003Cbr\u002F\u003E\r\n\u003Ci\u003Emask.w\u003C\u002Fi\u003E\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nМы получили \u003Ci\u003Emask\u003C\u002Fi\u003E, давайте двигаться дальше. Строка 15 сэмплирует карту яркости. Учтите, что текстура яркости имеет формат R11G11B10_FLOAT, хотя мы сэмплируем все компоненты rgba. В этой ситуации подразумевается, что .a равно 1.0f.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nИспользуемые для этой операции Texcoords можно вычислить как \u003Ci\u003Efrac( TextureUV * 2.0 )\u003C\u002Fi\u003E. Поэтому результат этой операции может, например, выглядеть вот так:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cdiv style=\"text-align:center;\"\u003E\u003Cimg src=\"https:\u002F\u002F1.bp.blogspot.com\u002F-R7j7zzHxho0\u002FXKd8gBy4VkI\u002FAAAAAAAABaQ\u002FDNScCWS6xjEEiZl44GXq01sofkDtNuAewCLcBGAs\u002Fs1600\u002F04_intensity_sampled.jpg\" data-src=\"https:\u002F\u002F1.bp.blogspot.com\u002F-R7j7zzHxho0\u002FXKd8gBy4VkI\u002FAAAAAAAABaQ\u002FDNScCWS6xjEEiZl44GXq01sofkDtNuAewCLcBGAs\u002Fs1600\u002F04_intensity_sampled.jpg\" data-blurred=\"true\"\u002F\u003E\u003C\u002Fdiv\u003E\u003Cbr\u002F\u003E\r\nВидите сходство?\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nСледующий этап очень умён — выполняется четырёхкомпонентное скалярное произведение (dp4):\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"cpp\"\u003E  16: dp4 r1.x, r1.xyzw, r2.xyzw\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nТаким образом в верхнем левом углу остаётся только красный канал (то есть только интересные объекты), в верхнем правом — только зелёный канал (только следы), а в нижнем правом — всё (потому что компоненту яркости .w косвенно присвоено значение 1.0). Великолепная идея. Результат скалярного произведения выглядит так:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cdiv style=\"text-align:center;\"\u003E\u003Cimg src=\"https:\u002F\u002F2.bp.blogspot.com\u002F-U4T8Yv-zmyM\u002FXKd-CnMc5KI\u002FAAAAAAAABac\u002FTfqE6j1Mcc4Qg7Bu2ksvejXoL86jyJxDwCLcBGAs\u002Fs1600\u002F05_dot_mask_intensity.jpg\" data-src=\"https:\u002F\u002F2.bp.blogspot.com\u002F-U4T8Yv-zmyM\u002FXKd-CnMc5KI\u002FAAAAAAAABac\u002FTfqE6j1Mcc4Qg7Bu2ksvejXoL86jyJxDwCLcBGAs\u002Fs1600\u002F05_dot_mask_intensity.jpg\" data-blurred=\"true\"\u002F\u003E\u003C\u002Fdiv\u003E\u003Cbr\u002F\u003E\r\nПолучив этот \u003Ci\u003EmasterFilter\u003C\u002Fi\u003E, мы готовы к определению контуров объектов. Это не так сложно, как может показаться. Алгоритм очень похож на применённый при получении резкости — нам нужно получить максимальную абсолютную разность значений.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nВот что происходит: мы сэмплируем четыре тексела рядом с текущим обрабатываемым текселом (важно: в этом случае размер тексела равен 1.0\u002F256.0!) и вычисляем максимальные абсолютные разности для красного и зелёного каналов:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"cpp\"\u003E   float fTexel = 1.0 \u002F 256;  \n     \n   float2 sampling1 = TextureUV + float2( fTexel, 0 );  \n   float2 sampling2 = TextureUV + float2( -fTexel, 0 );  \n   float2 sampling3 = TextureUV + float2( 0, fTexel );  \n   float2 sampling4 = TextureUV + float2( 0, -fTexel );  \n     \n   float2 intensity_x0 = texIntensityMap.Sample( sampler1, sampling1 ).xy;  \n   float2 intensity_x1 = texIntensityMap.Sample( sampler1, sampling2 ).xy;  \n   float2 intensity_diff_x = intensity_x0 - intensity_x1;  \n     \n   float2 intensity_y0 = texIntensityMap.Sample( sampler1, sampling3 ).xy;  \n   float2 intensity_y1 = texIntensityMap.Sample( sampler1, sampling4 ).xy;  \n   float2 intensity_diff_y = intensity_y0 - intensity_y1;  \n     \n   float2 maxAbsDifference = max( abs(intensity_diff_x), abs(intensity_diff_y) );  \n   maxAbsDifference = saturate(maxAbsDifference);\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nТеперь если мы перемножим \u003Ci\u003Efilter\u003C\u002Fi\u003E на \u003Ci\u003EmaxAbsDifference\u003C\u002Fi\u003E…\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cdiv style=\"text-align:center;\"\u003E\u003Cimg src=\"https:\u002F\u002F2.bp.blogspot.com\u002F-1TsHGaxWlb0\u002FXKeCooV84wI\u002FAAAAAAAABao\u002FlHyhFRkxnTcaQXxXQgwREHm_cldGhPhFwCLcBGAs\u002Fs1600\u002F06_outlines.jpg\" data-src=\"https:\u002F\u002F2.bp.blogspot.com\u002F-1TsHGaxWlb0\u002FXKeCooV84wI\u002FAAAAAAAABao\u002FlHyhFRkxnTcaQXxXQgwREHm_cldGhPhFwCLcBGAs\u002Fs1600\u002F06_outlines.jpg\" data-blurred=\"true\"\u002F\u003E\u003C\u002Fdiv\u003E\u003Cbr\u002F\u003E\r\nОчень просто и эффективно.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nПолучив контуры, мы сэмплируем карту контуров из предыдущего кадра.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nЗатем, чтобы получить „призрачный“ эффект, мы берём часть параметров, вычисленных на текущем проходе, и значения из карты контуров.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nПоздоровайтесь с нашим старым другом — целочисленным шумом. Он присутствует и здесь. Параметры анимации (cb3[0].zw) берутся из буфера констант и со временем изменяются.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"cpp\"\u003E   float2 outlines = masterFilter * maxAbsDifference;  \n     \n   \u002F\u002F Sample outline map  \n   float2 outlineMap = texOutlineMap.Sample( samplerLinearWrap, uv ).xy;  \n     \n   \u002F\u002F I guess it's related with ghosting   \n   float paramOutline = masterFilter*0.15 + outlineMap.y;  \n   paramOutline += 0.35 * outlines.r;  \n   paramOutline += 0.35 * outlines.g;  \n     \n   \u002F\u002F input for integer noise  \n   float2 noiseWeights = cb3_v0.zw;\n   float2 noiseInputs = 150.0*uv + 300.0*noiseWeights;  \n   int2 iNoiseInputs = (int2) noiseInputs;  \n     \n   float noise0 = clamp( integerNoise( iNoiseInputs.x + reversebits(iNoiseInputs.y) ), -1, 1 ) + 0.65; \u002F\u002F r0.y\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nПримечание: если вы захотите реализовать ведьмачье чутьё самостоятельно, то рекомендую ограничить целочисленный шум интервалом [-1;1] (как и сказано на его веб-сайте). В оригинальном шейдере TW3 ограничения не было, но без него я получал ужасные артефакты и вся карта контуров была нестабильной.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nЗатем мы сэмплируем карту контуров тем же способом, что и карту яркости ранее (на этот раз тексел имеет размер 1.0\u002F512.0), и вычисляем среднее значение компонента .x:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"cpp\"\u003E  \u002F\u002F sampling of outline map  \n   fTexel = 1.0 \u002F 512.0;  \n     \n   sampling1 = saturate( uv + float2( fTexel, 0 ) );  \n   sampling2 = saturate( uv + float2( -fTexel, 0 ) );  \n   sampling3 = saturate( uv + float2( 0, fTexel ) );  \n   sampling4 = saturate( uv + float2( 0, -fTexel ) );  \n     \n   float outline_x0 = texOutlineMap.Sample( sampler0, sampling1 ).x;  \n   float outline_x1 = texOutlineMap.Sample( sampler0, sampling2 ).x;  \n   float outline_y0 = texOutlineMap.Sample( sampler0, sampling3 ).x;  \n   float outline_y1 = texOutlineMap.Sample( sampler0, sampling4 ).x;  \n   float averageOutline = (outline_x0+outline_x1+outline_y0+outline_y1) \u002F 4.0;\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nЗатем, судя по ассемблерному коду, вычисляется разность между средним и значением этого конкретного пикселя, после чего выполняется искажение целочисленным шумом:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"cpp\"\u003E   \u002F\u002F perturb with noise  \n   float frameOutlineDifference = averageOutline - outlineMap.x;  \n   frameOutlineDifference *= noise0;\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nСледующим шагом будет искажение значения из „старой“ карты контуров с помощью шума — это основная линия, придающая выходной текстуре ощущение блочности.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nДальше идут другие вычисления, после чего, в самом конце, вычисляется „затухание“.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"cpp\"\u003E   \u002F\u002F the main place with gives blocky look of texture  \n   float newNoise = outlineMap.x * noise0;  \n     \n   float newOutline = frameOutlineDifference * 0.9 + paramOutline;  \n   newOutline -= 0.24*newNoise;  \n     \n   \u002F\u002F 59: add r0.x, r0.y, r0.z  \n   float2 finalOutline = float2( outlineMap.x + newOutline, newOutline);  \n     \n   \u002F\u002F * calculate damping  \n   float dampingParam = saturate( cb3_v0.x );  \n   dampingParam = pow( dampingParam, 100 );    \n     \n   float damping = 0.7 + 0.16*dampingParam;  \n   \n   \n   \u002F\u002F * final multiplication  \n   float2 finalColor = finalOutline * damping;  \n   return float4(finalColor, 0, 0);\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nВот небольшое видео, демонстрирующее в действии карту контуров:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cdiv class=\"oembed\"\u003E\u003Cdiv\u003E\u003Cdiv style=\"left: 0; width: 100%; height: 0; position: relative; padding-bottom: 56.2493%;\"\u003E\u003Cdiv class=\"tm-iframe_temp\" data-src=\"https:\u002F\u002Fwww.youtube.com\u002Fembed\u002FvSscLz2RYsQ?rel=0&amp;showinfo=1&amp;hl=en-US\" data-style=\"border: 0; top: 0; left: 0; width: 100%; height: 100%; position: absolute;\" id=\"\" width=\"\"\u003E\u003C\u002Fdiv\u003E\u003C\u002Fdiv\u003E\u003C\u002Fdiv\u003E\u003C\u002Fdiv\u003E\u003Cbr\u002F\u003E\r\nЕсли вам интересен полный пиксельный шейдер, то он выложен \u003Ca href=\"https:\u002F\u002Fpastebin.com\u002FJPv7AyXK\"\u003Eздесь\u003C\u002Fa\u003E. Шейдер совместим с RenderDoc.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nИнтересно (и, если честно, слегка раздражает) то, что несмотря на идентичность ассемблерного кода с оригинальным шейдером из Witcher 3, окончательный внешний вид карты контуров в RenderDoc меняется!\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nПримечание: в последнем проходе (см. следующую часть) вы увидите, что используется только канал .r карты контуров. Зачем же тогда нам нужен канал .g? Думаю, что это какой-то буфер „пинг-понга“ в одной текстуре — заметьте, что .r содержит канал .g + какое-то новое значение.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Ch2\u003EЧасть 5: Ведьмачье чутьё (»рыбий глаз\" и окончательный результат)\u003C\u002Fh2\u003E\u003Cbr\u002F\u003E\r\nВкратце перечислим, что у нас уже есть: в первой части, посвящённой ведьмачьему чутью, сгенерирована полноэкранная карта яркости, сообщающая насколько заметен должен быть эффект в зависимости от расстояния. Во второй части я подробнее исследовал карту контуров, отвечающую за контуры и анимацию готового эффекта.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nМы подошли к последнему этапу. Всё это нужно объединить! Последний проход — это полноэкранный четырёхугольник. Входные данные: буфер цветов, карта контуров и карта яркости.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nДо:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cdiv style=\"text-align:center;\"\u003E\u003Cimg src=\"https:\u002F\u002F1.bp.blogspot.com\u002F-oQKKd9lbcLQ\u002FXKihDzw4ZuI\u002FAAAAAAAABbM\u002FDmJUkV9PA4w5m0gf06MrS2t_vt5eQV5dQCEwYBhgL\u002Fs1600\u002Fbefore.jpg\" data-src=\"https:\u002F\u002F1.bp.blogspot.com\u002F-oQKKd9lbcLQ\u002FXKihDzw4ZuI\u002FAAAAAAAABbM\u002FDmJUkV9PA4w5m0gf06MrS2t_vt5eQV5dQCEwYBhgL\u002Fs1600\u002Fbefore.jpg\" data-blurred=\"true\"\u002F\u003E\u003C\u002Fdiv\u003E\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nПосле:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cdiv style=\"text-align:center;\"\u003E\u003Cimg src=\"https:\u002F\u002F3.bp.blogspot.com\u002F-got60f2XK9Y\u002FXKihDpXA0cI\u002FAAAAAAAABbE\u002F6pgzzBB36Ck-RsuRS_lNHv0pmvzSJjywACEwYBhgL\u002Fs1600\u002Fafter.jpg\" data-src=\"https:\u002F\u002F3.bp.blogspot.com\u002F-got60f2XK9Y\u002FXKihDpXA0cI\u002FAAAAAAAABbE\u002F6pgzzBB36Ck-RsuRS_lNHv0pmvzSJjywACEwYBhgL\u002Fs1600\u002Fafter.jpg\" data-blurred=\"true\"\u002F\u003E\u003C\u002Fdiv\u003E\u003Cbr\u002F\u003E\r\nЕщё раз покажу видео с применённым эффектом:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cdiv class=\"oembed\"\u003E\u003Cdiv\u003E\u003Cdiv style=\"left: 0; width: 100%; height: 0; position: relative; padding-bottom: 56.2493%;\"\u003E\u003Cdiv class=\"tm-iframe_temp\" data-src=\"https:\u002F\u002Fwww.youtube.com\u002Fembed\u002FReB6IrOb3ic?rel=0&amp;showinfo=1&amp;hl=en-US\" data-style=\"border: 0; top: 0; left: 0; width: 100%; height: 100%; position: absolute;\" id=\"\" width=\"\"\u003E\u003C\u002Fdiv\u003E\u003C\u002Fdiv\u003E\u003C\u002Fdiv\u003E\u003C\u002Fdiv\u003E\u003Cbr\u002F\u003E\r\nКак видите, кроме наложения контуров на объекты, которые может увидеть или услышать Геральт, ко всему экрану применяется эффект «рыбьего глаза», и весь экран (особенно углы) становится сероватым, чтобы передать ощущение реального охотника за чудовищами.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nПолный ассемблерный код пиксельного шейдера:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"cpp\"\u003E ps_5_0  \n    dcl_globalFlags refactoringAllowed  \n    dcl_constantbuffer cb0[3], immediateIndexed  \n    dcl_constantbuffer cb3[7], immediateIndexed  \n    dcl_sampler s0, mode_default  \n    dcl_sampler s2, mode_default  \n    dcl_resource_texture2d (float,float,float,float) t0  \n    dcl_resource_texture2d (float,float,float,float) t2  \n    dcl_resource_texture2d (float,float,float,float) t3  \n    dcl_input_ps_siv v0.xy, position  \n    dcl_output o0.xyzw  \n    dcl_temps 7  \n   0: div r0.xy, v0.xyxx, cb0[2].xyxx  \n   1: mad r0.zw, r0.xxxy, l(0.000000, 0.000000, 2.000000, 2.000000), l(0.000000, 0.000000, -1.000000, -1.000000)  \n   2: mov r1.yz, abs(r0.zzwz)  \n   3: div r0.z, cb0[2].x, cb0[2].y  \n   4: mul r1.x, r0.z, r1.y  \n   5: add r0.zw, r1.xxxz, -cb3[2].xxxy  \n   6: mul_sat r0.zw, r0.zzzw, l(0.000000, 0.000000, 0.555556, 0.555556)  \n   7: log r0.zw, r0.zzzw  \n   8: mul r0.zw, r0.zzzw, l(0.000000, 0.000000, 2.500000, 2.500000)  \n   9: exp r0.zw, r0.zzzw  \n  10: dp2 r0.z, r0.zwzz, r0.zwzz  \n  11: sqrt r0.z, r0.z  \n  12: min r0.z, r0.z, l(1.000000)  \n  13: add r0.z, -r0.z, l(1.000000)  \n  14: mov_sat r0.w, cb3[6].x  \n  15: add_sat r1.xy, -r0.xyxx, l(0.030000, 0.030000, 0.000000, 0.000000)  \n  16: add r1.x, r1.y, r1.x  \n  17: add_sat r0.xy, r0.xyxx, l(-0.970000, -0.970000, 0.000000, 0.000000)  \n  18: add r0.x, r0.x, r1.x  \n  19: add r0.x, r0.y, r0.x  \n  20: mul r0.x, r0.x, l(20.000000)  \n  21: min r0.x, r0.x, l(1.000000)  \n  22: add r1.xy, v0.xyxx, v0.xyxx  \n  23: div r1.xy, r1.xyxx, cb0[2].xyxx  \n  24: add r1.xy, r1.xyxx, l(-1.000000, -1.000000, 0.000000, 0.000000)  \n  25: dp2 r0.y, r1.xyxx, r1.xyxx  \n  26: mul r1.xy, r0.yyyy, r1.xyxx  \n  27: mul r0.y, r0.w, l(0.100000)  \n  28: mul r1.xy, r0.yyyy, r1.xyxx  \n  29: max r1.xy, r1.xyxx, l(-0.400000, -0.400000, 0.000000, 0.000000)  \n  30: min r1.xy, r1.xyxx, l(0.400000, 0.400000, 0.000000, 0.000000)  \n  31: mul r1.xy, r1.xyxx, cb3[1].xxxx  \n  32: mul r1.zw, r1.xxxy, cb0[2].zzzw  \n  33: mad r1.zw, v0.xxxy, cb0[1].zzzw, -r1.zzzw  \n  34: sample_indexable(texture2d)(float,float,float,float) r2.xyz, r1.zwzz, t0.xyzw, s0  \n  35: mul r3.xy, r1.zwzz, l(0.500000, 0.500000, 0.000000, 0.000000)  \n  36: sample_indexable(texture2d)(float,float,float,float) r0.y, r3.xyxx, t2.yxzw, s2  \n  37: mad r3.xy, r1.zwzz, l(0.500000, 0.500000, 0.000000, 0.000000), l(0.500000, 0.000000, 0.000000, 0.000000)  \n  38: sample_indexable(texture2d)(float,float,float,float) r2.w, r3.xyxx, t2.yzwx, s2  \n  39: mul r2.w, r2.w, l(0.125000)  \n  40: mul r3.x, cb0[0].x, l(0.100000)  \n  41: add r0.x, -r0.x, l(1.000000)  \n  42: mul r0.xy, r0.xyxx, l(0.030000, 0.125000, 0.000000, 0.000000)  \n  43: mov r3.yzw, l(0, 0, 0, 0)  \n  44: mov r4.x, r0.y  \n  45: mov r4.y, r2.w  \n  46: mov r4.z, l(0)  \n  47: loop  \n  48:  ige r4.w, r4.z, l(8)  \n  49:  breakc_nz r4.w  \n  50:  itof r4.w, r4.z  \n  51:  mad r4.w, r4.w, l(0.785375), -r3.x  \n  52:  sincos r5.x, r6.x, r4.w  \n  53:  mov r6.y, r5.x  \n  54:  mul r5.xy, r0.xxxx, r6.xyxx  \n  55:  mad r5.zw, r5.xxxy, l(0.000000, 0.000000, 0.125000, 0.125000), r1.zzzw  \n  56:  mul r6.xy, r5.zwzz, l(0.500000, 0.500000, 0.000000, 0.000000)  \n  57:  sample_indexable(texture2d)(float,float,float,float) r4.w, r6.xyxx, t2.yzwx, s2  \n  58:  mad r4.x, r4.w, l(0.125000), r4.x  \n  59:  mad r5.zw, r5.zzzw, l(0.000000, 0.000000, 0.500000, 0.500000), l(0.000000, 0.000000, 0.500000, 0.000000)  \n  60:  sample_indexable(texture2d)(float,float,float,float) r4.w, r5.zwzz, t2.yzwx, s2  \n  61:  mad r4.y, r4.w, l(0.125000), r4.y  \n  62:  mad r5.xy, r5.xyxx, r1.xyxx, r1.zwzz  \n  63:  sample_indexable(texture2d)(float,float,float,float) r5.xyz, r5.xyxx, t0.xyzw, s0  \n  64:  mad r3.yzw, r5.xxyz, l(0.000000, 0.125000, 0.125000, 0.125000), r3.yyzw  \n  65:  iadd r4.z, r4.z, l(1)  \n  66: endloop  \n  67: sample_indexable(texture2d)(float,float,float,float) r0.xy, r1.zwzz, t3.xyzw, s0  \n  68: mad_sat r0.xy, -r0.xyxx, l(0.800000, 0.750000, 0.000000, 0.000000), r4.xyxx  \n  69: dp3 r1.x, r3.yzwy, l(0.300000, 0.300000, 0.300000, 0.000000)  \n  70: add r1.yzw, -r1.xxxx, r3.yyzw  \n  71: mad r1.xyz, r0.zzzz, r1.yzwy, r1.xxxx  \n  72: mad r1.xyz, r1.xyzx, l(0.600000, 0.600000, 0.600000, 0.000000), -r2.xyzx  \n  73: mad r1.xyz, r0.wwww, r1.xyzx, r2.xyzx  \n  74: mul r0.yzw, r0.yyyy, cb3[4].xxyz  \n  75: mul r2.xyz, r0.xxxx, cb3[5].xyzx  \n  76: mad r0.xyz, r0.yzwy, l(1.200000, 1.200000, 1.200000, 0.000000), r2.xyzx  \n  77: mov_sat r2.xyz, r0.xyzx  \n  78: dp3_sat r0.x, r0.xyzx, l(1.000000, 1.000000, 1.000000, 0.000000)  \n  79: add r0.yzw, -r1.xxyz, r2.xxyz  \n  80: mad o0.xyz, r0.xxxx, r0.yzwy, r1.xyzx  \n  81: mov o0.w, l(1.000000)  \n  82: ret\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E \u003Cbr\u002F\u003E\r\n82 строки — значит, нам предстоит много работы!\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nДля начала взглянем на входящие данные:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"cpp\"\u003E   \u002F\u002F *** Inputs       \n     \n   \u002F\u002F * Zoom amount, always 1  \n   float zoomAmount = cb3_v1.x;  \n     \n   \u002F\u002F Another value which affect fisheye effect  \n   \u002F\u002F but always set to float2(1.0, 1.0).  \n   float2 amount = cb0_v2.zw;  \n     \n   \u002F\u002F Elapsed time in seconds  \n   float time = cb0_v0.x;  \n     \n   \u002F\u002F Colors of witcher senses  \n   float3 colorInteresting = cb3_v5.rgb;  \n   float3 colorTraces = cb3_v4.rgb;  \n     \n   \u002F\u002F Was always set to float2(0.0, 0.0).  \n   \u002F\u002F Setting this to higher values  \n   \u002F\u002F makes \"grey corners\" effect weaker.  \n   float2 offset = cb3_v2.xy;  \n     \n   \u002F\u002F Dimensions of fullscreen  \n   float2 texSize = cb0_v2.xy;  \n   float2 invTexSize = cb0_v1.zw;  \n   \n   \u002F\u002F Main value which causes fisheye effect [0-1]  \n   const float fisheyeAmount = saturate( cb3_v6.x );\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nОсновное значение, ответственное за величину эффекта — это \u003Ci\u003EfisheyeAmount\u003C\u002Fi\u003E. Думаю, оно постепенно повышается с 0.0 до 1.0, когда Геральт начинает использовать своё чутьё. Остальные значения почти не меняются, но я подозреваю, что некоторые из них отличались бы, если бы пользователь отключил в опциях эффект fisheye (я это не проверял).\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nПервое, что здесь происходит — шейдер вычисляет маску, отвечающую за серые углы:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"cpp\"\u003E   0: div r0.xy, v0.xyxx, cb0[2].xyxx   \n   1: mad r0.zw, r0.xxxy, l(0.000000, 0.000000, 2.000000, 2.000000), l(0.000000, 0.000000, -1.000000, -1.000000)   \n   2: mov r1.yz, abs(r0.zzwz)   \n   3: div r0.z, cb0[2].x, cb0[2].y   \n   4: mul r1.x, r0.z, r1.y   \n   5: add r0.zw, r1.xxxz, -cb3[2].xxxy   \n   6: mul_sat r0.zw, r0.zzzw, l(0.000000, 0.000000, 0.555556, 0.555556)   \n   7: log r0.zw, r0.zzzw   \n   8: mul r0.zw, r0.zzzw, l(0.000000, 0.000000, 2.500000, 2.500000)   \n   9: exp r0.zw, r0.zzzw   \n  10: dp2 r0.z, r0.zwzz, r0.zwzz   \n  11: sqrt r0.z, r0.z   \n  12: min r0.z, r0.z, l(1.000000)   \n  13: add r0.z, -r0.z, l(1.000000)\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nНа HLSL мы можем записать это следующим образом:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"cpp\"\u003E   \u002F\u002F Main uv  \n   float2 uv = PosH.xy \u002F texSize;  \n     \n   \u002F\u002F Scale at first from [0-1] to [-1;1], then calculate abs  \n   float2 uv3 = abs( uv * 2.0 - 1.0);   \n        \n   \u002F\u002F Aspect ratio  \n   float aspectRatio = texSize.x \u002F texSize.y;  \n        \n   \u002F\u002F * Mask used to make corners grey  \n   float mask_gray_corners;  \n   {  \n     float2 newUv = float2( uv3.x * aspectRatio, uv3.y ) - offset;  \n     newUv = saturate( newUv \u002F 1.8 );  \n     newUv = pow(newUv, 2.5);  \n       \n     mask_gray_corners = 1-min(1.0, length(newUv) );  \n   }\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nСначала вычисляется интервал [-1; 1] UV и их абсолютные значения. Затем имеет место хитрое «сжимание». Готовая маска выглядит следующим образом:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cdiv style=\"text-align:center;\"\u003E\u003Cimg src=\"\u002Fimg\u002Fimage-loader.svg\" data-src=\"https:\u002F\u002F1.bp.blogspot.com\u002F-zsp6VceueIQ\u002FXKihEhtGrPI\u002FAAAAAAAABbw\u002F0RDidmwTWgkOlwtJp20uKByz8ZRK8tRJACEwYBhgL\u002Fs1600\u002Fmask_gray_corners.png\"\u002F\u003E\u003C\u002Fdiv\u003E\u003Cbr\u002F\u003E\r\nПозже я вернусь к этой маске.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nСейчас я намеренно пропущу несколько строк кода и внимательнее изучу код, отвечающий за эффект «зума».\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"cpp\"\u003E  22: add r1.xy, v0.xyxx, v0.xyxx   \n  23: div r1.xy, r1.xyxx, cb0[2].xyxx   \n  24: add r1.xy, r1.xyxx, l(-1.000000, -1.000000, 0.000000, 0.000000)   \n  25: dp2 r0.y, r1.xyxx, r1.xyxx   \n  26: mul r1.xy, r0.yyyy, r1.xyxx   \n  27: mul r0.y, r0.w, l(0.100000)   \n  28: mul r1.xy, r0.yyyy, r1.xyxx   \n  29: max r1.xy, r1.xyxx, l(-0.400000, -0.400000, 0.000000, 0.000000)   \n  30: min r1.xy, r1.xyxx, l(0.400000, 0.400000, 0.000000, 0.000000)   \n  31: mul r1.xy, r1.xyxx, cb3[1].xxxx   \n  32: mul r1.zw, r1.xxxy, cb0[2].zzzw   \n  33: mad r1.zw, v0.xxxy, cb0[1].zzzw, -r1.zzzw\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nСначала вычисляются «удвоенные» координаты текстур и выполняется вычитание float2(1, 1):\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"cpp\"\u003E   float2 uv4 = 2 * PosH.xy;  \n   uv4 \u002F= cb0_v2.xy;  \n   uv4 -= float2(1.0, 1.0);\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E \u003Cbr\u002F\u003E\r\nТакие texcoord можно визуализировать так:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cdiv style=\"text-align:center;\"\u003E\u003Cimg src=\"https:\u002F\u002F2.bp.blogspot.com\u002F-DMQhZp1uF8M\u002FXKihFJTxhgI\u002FAAAAAAAABb4\u002FbcFforMSspcZm57vi4aApZ16pdOr-yMeACEwYBhgL\u002Fs1600\u002Fzoom_uvs.jpg\" data-src=\"https:\u002F\u002F2.bp.blogspot.com\u002F-DMQhZp1uF8M\u002FXKihFJTxhgI\u002FAAAAAAAABb4\u002FbcFforMSspcZm57vi4aApZ16pdOr-yMeACEwYBhgL\u002Fs1600\u002Fzoom_uvs.jpg\" data-blurred=\"true\"\u002F\u003E\u003C\u002Fdiv\u003E\u003Cbr\u002F\u003E\r\nЗатем вычисляется скалярное произведение \u003Ci\u003Edot(uv4, uv4)\u003C\u002Fi\u003E, что даёт нам маску:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cdiv style=\"text-align:center;\"\u003E\u003Cimg src=\"\u002Fimg\u002Fimage-loader.svg\" data-src=\"https:\u002F\u002F1.bp.blogspot.com\u002F-imbPBINnWFs\u002FXKihE2YDmxI\u002FAAAAAAAABb4\u002FVzLi_7GdAhk19jJgqSGr-cZyoN-tE8F9ACEwYBhgL\u002Fs1600\u002Fmask_zoom_01.png\"\u002F\u003E\u003C\u002Fdiv\u003E\u003Cbr\u002F\u003E\r\nкоторая используется для умножения на вышеупомянутые texcoords:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cdiv style=\"text-align:center;\"\u003E\u003Cimg src=\"https:\u002F\u002F4.bp.blogspot.com\u002F-491z4gHKJpg\u002FXKihFbmLJrI\u002FAAAAAAAABb0\u002Fe9-ldof2uUoYEh9xDGp9UgurkbkhmxVQwCEwYBhgL\u002Fs1600\u002Fzoom_uvs_distorted.jpg\" data-src=\"https:\u002F\u002F4.bp.blogspot.com\u002F-491z4gHKJpg\u002FXKihFbmLJrI\u002FAAAAAAAABb0\u002Fe9-ldof2uUoYEh9xDGp9UgurkbkhmxVQwCEwYBhgL\u002Fs1600\u002Fzoom_uvs_distorted.jpg\" data-blurred=\"true\"\u002F\u003E\u003C\u002Fdiv\u003E\u003Cbr\u002F\u003E\r\nВажно: в верхнем левом углу (чёрные пиксели) значения отрицательны. Они отображаются чёрным (0.0) из-за ограниченной точности формата R11G11B10_FLOAT. У него нет знакового бита, поэтому в нём нельзя хранить отрицательные значения.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nЗатем вычисляется коэффициент затухания (как я говорил выше, \u003Ci\u003EfisheyeAmount\u003C\u002Fi\u003E изменяется от 0.0 до 1.0).\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"cpp\"\u003E   float attenuation = fisheyeAmount * 0.1;  \n   uv4 *= attenuation;\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nЗатем выполняется ограничение (max\u002Fmin) и одно умножение.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nТаким образом вычисляется смещение. Для вычисления конечных uv, которые будут использоваться для сэмплирования текстуры цвета, мы просто выполняем вычитание:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Ci\u003Efloat2 colorUV = mainUv — offset;\u003C\u002Fi\u003E\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nВыполняя сэмплирование входной текстуры цвета \u003Ci\u003EcolorUV\u003C\u002Fi\u003E, мы получаем рядом с углами искажённое изображение:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cdiv style=\"text-align:center;\"\u003E\u003Cimg src=\"https:\u002F\u002F3.bp.blogspot.com\u002F-Q7IHQiilwWM\u002FXKiqbPOjzkI\u002FAAAAAAAABcQ\u002FVkI6vTYGKpY72jCqLxl7Hepwhd7WS1t-wCLcBGAs\u002Fs1600\u002Fmain_color_distorted.jpg\" data-src=\"https:\u002F\u002F3.bp.blogspot.com\u002F-Q7IHQiilwWM\u002FXKiqbPOjzkI\u002FAAAAAAAABcQ\u002FVkI6vTYGKpY72jCqLxl7Hepwhd7WS1t-wCLcBGAs\u002Fs1600\u002Fmain_color_distorted.jpg\" data-blurred=\"true\"\u002F\u003E\u003C\u002Fdiv\u003E\u003Cbr\u002F\u003E\r\n\u003Ch4\u003EКонтуры\u003C\u002Fh4\u003E\u003Cbr\u002F\u003E\r\nСледующий этап — сэмплирование карты контуров для нахождения контуров. Это довольно просто, сначала мы находим texcoords для сэмплирования контуров интересных объектов, а затем то же самое делаем для следов:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"cpp\"\u003E   \u002F\u002F * Sample outline map  \n        \n   \u002F\u002F interesting objects (upper left square)  \n   float2 outlineUV = colorUV * 0.5;  \n   float outlineInteresting = texture2.Sample( sampler2, outlineUV ).x; \u002F\u002F r0.y  \n        \n   \u002F\u002F traces (upper right square)  \n   outlineUV = colorUV * 0.5 + float2(0.5, 0.0);  \n   float outlineTraces = texture2.Sample( sampler2, outlineUV ).x; \u002F\u002F r2.w  \n        \n   outlineInteresting \u002F= 8.0; \u002F\u002F r4.x  \n   outlineTraces \u002F= 8.0; \u002F\u002F r4.y\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E \u003Cbr\u002F\u003E\r\n\u003Cdiv style=\"text-align:center;\"\u003E\u003Cimg src=\"https:\u002F\u002F2.bp.blogspot.com\u002F-De_y5_2IXYc\u002FXKir4f3kEMI\u002FAAAAAAAABcc\u002FXLghv1K0mU4JcCrE49EQqOykU5FWDCVgACLcBGAs\u002Fs1600\u002Foutline_int.jpg\" data-src=\"https:\u002F\u002F2.bp.blogspot.com\u002F-De_y5_2IXYc\u002FXKir4f3kEMI\u002FAAAAAAAABcc\u002FXLghv1K0mU4JcCrE49EQqOykU5FWDCVgACLcBGAs\u002Fs1600\u002Foutline_int.jpg\" data-blurred=\"true\"\u002F\u003E\u003C\u002Fdiv\u003E\u003Cbr\u002F\u003E\r\n\u003Ci\u003EИнтересные объекты из карты контуров\u003C\u002Fi\u003E\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cdiv style=\"text-align:center;\"\u003E\u003Cimg src=\"https:\u002F\u002F1.bp.blogspot.com\u002F-6sMY4ZZweSg\u002FXKir4Z7PszI\u002FAAAAAAAABcg\u002FJaqmwG_vxEUpKtPuoXBuR8KAoSfbuNiIQCLcBGAs\u002Fs1600\u002Foutline_traces.jpg\" data-src=\"https:\u002F\u002F1.bp.blogspot.com\u002F-6sMY4ZZweSg\u002FXKir4Z7PszI\u002FAAAAAAAABcg\u002FJaqmwG_vxEUpKtPuoXBuR8KAoSfbuNiIQCLcBGAs\u002Fs1600\u002Foutline_traces.jpg\" data-blurred=\"true\"\u002F\u003E\u003C\u002Fdiv\u003E\u003Cbr\u002F\u003E\r\n\u003Ci\u003EСледы из карты контуров\u003C\u002Fi\u003E\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nСтоит заметить, что мы сэмплируем из карты контуров только канал .x и учитываем только верхние квадраты.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Ch4\u003EДвижение\u003C\u002Fh4\u003E\u003Cbr\u002F\u003E\r\nДля реализации движения следов используется почти такой же трюк, как и в эффекте опьянения. Добавляется круг единичного размера и мы сэмплируем 8 раз карту контуров для интересных объектов и следов, а также текстуру цвета.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nЗаметьте, что мы только разделили найденные контуры на 8.0.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nТак как мы находимся в пространстве текстурных координат [0-1]\u003Csup\u003E2\u003C\u002Fsup\u003E, то наличие круга радиусом 1 для обведения отдельного пикселя создаст неприемлемые артефакты:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cdiv style=\"text-align:center;\"\u003E\u003Cimg src=\"https:\u002F\u002F2.bp.blogspot.com\u002F-eL-p8_u_5XE\u002FXKiuJg9MnRI\u002FAAAAAAAABcw\u002FtJYST-efWZQEgXrAefUfyQxmGkND2cHsgCLcBGAs\u002Fs1600\u002Funit_circle_artifacts.jpg\" data-src=\"https:\u002F\u002F2.bp.blogspot.com\u002F-eL-p8_u_5XE\u002FXKiuJg9MnRI\u002FAAAAAAAABcw\u002FtJYST-efWZQEgXrAefUfyQxmGkND2cHsgCLcBGAs\u002Fs1600\u002Funit_circle_artifacts.jpg\" data-blurred=\"true\"\u002F\u003E\u003C\u002Fdiv\u003E\u003Cbr\u002F\u003E\r\nПоэтому прежде чем двигаться дальше, давайте узнаем, как вычисляется этот радиус. Для этого нам нужно вернуться к пропущенным строкам 15-21. Небольшая проблем с вычислением этого радиуса заключается в том, что его вычисление разбросано по шейдеру (возможно, из-за оптимизаций шейдера компилятором). Поэтому вот первая часть (15-21) и вторая (41-42):\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"cpp\"\u003E  15: add_sat r1.xy, -r0.xyxx, l(0.030000, 0.030000, 0.000000, 0.000000)  \n  16: add r1.x, r1.y, r1.x  \n  17: add_sat r0.xy, r0.xyxx, l(-0.970000, -0.970000, 0.000000, 0.000000)  \n  18: add r0.x, r0.x, r1.x  \n  19: add r0.x, r0.y, r0.x  \n  20: mul r0.x, r0.x, l(20.000000)  \n  21: min r0.x, r0.x, l(1.000000)  \n  ...  \n  41: add r0.x, -r0.x, l(1.000000)  \n  42: mul r0.xy, r0.xyxx, l(0.030000, 0.125000, 0.000000, 0.000000)\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E \u003Cbr\u002F\u003E\r\nКак видите, мы рассматриваем только текселы из [0.00 — 0.03] рядом с каждой поверхностью, суммируем их значения, умножаем 20 и насыщаем. Вот как они выглядят после строк 15-21:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cdiv style=\"text-align:center;\"\u003E\u003Cimg src=\"https:\u002F\u002F1.bp.blogspot.com\u002F-RBdcn9rnpzY\u002FXKiwsuUmQqI\u002FAAAAAAAABdA\u002FRLRIrkVlgRcI5LblVV58650kc24DNZ_AQCLcBGAs\u002Fs1600\u002Fcircle_radius_mask_first_stage.jpg\" data-src=\"https:\u002F\u002F1.bp.blogspot.com\u002F-RBdcn9rnpzY\u002FXKiwsuUmQqI\u002FAAAAAAAABdA\u002FRLRIrkVlgRcI5LblVV58650kc24DNZ_AQCLcBGAs\u002Fs1600\u002Fcircle_radius_mask_first_stage.jpg\" data-blurred=\"true\"\u002F\u003E\u003C\u002Fdiv\u003E\u003Cbr\u002F\u003E\r\nА вот как после строки 41:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cdiv style=\"text-align:center;\"\u003E\u003Cimg src=\"https:\u002F\u002F2.bp.blogspot.com\u002F-DLYvL198NPU\u002FXKiwsjKHfTI\u002FAAAAAAAABc8\u002F7wg3o2FRIg00zaE_jwdTSUpBQRdkI3JyQCEwYBhgL\u002Fs1600\u002Fcircle_radius_mask.jpg\" data-src=\"https:\u002F\u002F2.bp.blogspot.com\u002F-DLYvL198NPU\u002FXKiwsjKHfTI\u002FAAAAAAAABc8\u002F7wg3o2FRIg00zaE_jwdTSUpBQRdkI3JyQCEwYBhgL\u002Fs1600\u002Fcircle_radius_mask.jpg\" data-blurred=\"true\"\u002F\u003E\u003C\u002Fdiv\u003E\u003Cbr\u002F\u003E\r\nВ строке 42 мы умножаем это на 0.03, это значение является радиусом круга для всего экрана. Как видите, ближе к краям экрана радиус становится меньше.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nТеперь мы можем посмотреть на ассемблерный код, отвечающий за движение:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"cpp\"\u003E  40: mul r3.x, cb0[0].x, l(0.100000)  \n  41: add r0.x, -r0.x, l(1.000000)  \n  42: mul r0.xy, r0.xyxx, l(0.030000, 0.125000, 0.000000, 0.000000)  \n  43: mov r3.yzw, l(0, 0, 0, 0)  \n  44: mov r4.x, r0.y  \n  45: mov r4.y, r2.w  \n  46: mov r4.z, l(0)  \n  47: loop  \n  48:  ige r4.w, r4.z, l(8)  \n  49:  breakc_nz r4.w  \n  50:  itof r4.w, r4.z  \n  51:  mad r4.w, r4.w, l(0.785375), -r3.x  \n  52:  sincos r5.x, r6.x, r4.w  \n  53:  mov r6.y, r5.x  \n  54:  mul r5.xy, r0.xxxx, r6.xyxx  \n  55:  mad r5.zw, r5.xxxy, l(0.000000, 0.000000, 0.125000, 0.125000), r1.zzzw  \n  56:  mul r6.xy, r5.zwzz, l(0.500000, 0.500000, 0.000000, 0.000000)  \n  57:  sample_indexable(texture2d)(float,float,float,float) r4.w, r6.xyxx, t2.yzwx, s2  \n  58:  mad r4.x, r4.w, l(0.125000), r4.x  \n  59:  mad r5.zw, r5.zzzw, l(0.000000, 0.000000, 0.500000, 0.500000), l(0.000000, 0.000000, 0.500000, 0.000000)  \n  60:  sample_indexable(texture2d)(float,float,float,float) r4.w, r5.zwzz, t2.yzwx, s2  \n  61:  mad r4.y, r4.w, l(0.125000), r4.y  \n  62:  mad r5.xy, r5.xyxx, r1.xyxx, r1.zwzz  \n  63:  sample_indexable(texture2d)(float,float,float,float) r5.xyz, r5.xyxx, t0.xyzw, s0  \n  64:  mad r3.yzw, r5.xxyz, l(0.000000, 0.125000, 0.125000, 0.125000), r3.yyzw  \n  65:  iadd r4.z, r4.z, l(1)  \n  66: endloop\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nДавайте остановимся здесь на минуту. В строке 40 мы получаем временной коэффициент — просто \u003Ci\u003EelapsedTime * 0.1\u003C\u002Fi\u003E. В строке 43 у нас буфер для текстуры цвета, получаемой внутри цикла.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Ci\u003Er0.x\u003C\u002Fi\u003E (строки 41-42) — это, как мы теперь знаем, радиус круга. \u003Ci\u003Er4.x\u003C\u002Fi\u003E (строка 44) — это контур интересных объектов, \u003Ci\u003Er4.y\u003C\u002Fi\u003E (строка 45) — контур следов (ранее разделённый на 8!), а \u003Ci\u003Er4.z\u003C\u002Fi\u003E (строка 46) — счётчик цикла.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nКак можно ожидать, цикл имеет 8 итераций. Мы начинаем с вычисления угла в радианах \u003Ci\u003Ei * PI_4\u003C\u002Fi\u003E, что даёт нам 2*PI — полный круг. Угол со временем искажается.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nС помощью sincos мы определяем точку сэмплирования (единичный круг) и изменяем радиус с помощью умножения (строка 54).\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nПосле этого мы обходим пиксель по кругу и сэмплируем контуры и цвет. После цикла мы получим средние значения (благодаря делению на 8) контуров и цвета.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"cpp\"\u003E   float timeParam = time * 0.1;  \n     \n   \u002F\u002F adjust circle radius  \n   circle_radius = 1.0 - circle_radius;  \n   circle_radius *= 0.03;  \n        \n   float3 color_circle_main = float3(0.0, 0.0, 0.0);  \n        \n   [loop]  \n   for (int i=0; 8 \u003E i; i++)  \n   {  \n      \u002F\u002F full 2*PI = 360 angles cycle  \n      const float angleRadians = (float) i * PI_4 - timeParam;  \n             \n      \u002F\u002F unit circle  \n      float2 unitCircle;  \n      sincos(angleRadians, unitCircle.y, unitCircle.x); \u002F\u002F unitCircle.x = cos, unitCircle.y = sin  \n             \n      \u002F\u002F adjust radius  \n      unitCircle *= circle_radius;  \n             \n      \u002F\u002F * base texcoords (circle) - note we also scale radius here by 8  \n      \u002F\u002F * probably because of dimensions of outline map.  \n      \u002F\u002F line 55  \n      float2 uv_outline_base = colorUV + unitCircle \u002F 8.0;  \n                       \n      \u002F\u002F * interesting objects (circle)  \n      float2 uv_outline_interesting_circle = uv_outline_base * 0.5;  \n      float outline_interesting_circle = texture2.Sample( sampler2, uv_outline_interesting_circle ).x;  \n      outlineInteresting += outline_interesting_circle \u002F 8.0;  \n             \n      \u002F\u002F * traces (circle)  \n      float2 uv_outline_traces_circle = uv_outline_base * 0.5 + float2(0.5, 0.0);  \n      float outline_traces_circle = texture2.Sample( sampler2, uv_outline_traces_circle ).x;  \n      outlineTraces += outline_traces_circle \u002F 8.0;\n\n      \u002F\u002F * sample color texture (zooming effect) with perturbation\n      float2 uv_color_circle = colorUV + unitCircle * offsetUV;  \n      float3 color_circle = texture0.Sample( sampler0, uv_color_circle ).rgb;\n      color_circle_main += color_circle \u002F 8.0;  \n   }\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E \u003Cbr\u002F\u003E\r\nСэмплирование цвета выполнятся почти так же, но к базовому \u003Ci\u003EcolorUV\u003C\u002Fi\u003E мы прибавляем смещение, умноженное на «единичный» круг.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Ch4\u003EЯркости\u003C\u002Fh4\u003E\u003Cbr\u002F\u003E\r\nПосле цикла мы сэмплируем карту яркости и изменяем финальные значения яркости (потому что карта яркости ничего не знает о контурах):\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"cpp\"\u003E  67: sample_indexable(texture2d)(float,float,float,float) r0.xy, r1.zwzz, t3.xyzw, s0  \n  68: mad_sat r0.xy, -r0.xyxx, l(0.800000, 0.750000, 0.000000, 0.000000), r4.xyxx\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nКод на HLSL:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"cpp\"\u003E   \u002F\u002F * Sample intensity map  \n   float2 intensityMap = texture3.Sample( sampler0, colorUV ).xy;  \n     \n   float intensityInteresting = intensityMap.r;  \n   float intensityTraces = intensityMap.g;  \n        \n   \u002F\u002F * Adjust outlines  \n   float mainOutlineInteresting = saturate( outlineInteresting - 0.8*intensityInteresting );  \n   float mainOutlineTraces = saturate( outlineTraces - 0.75*intensityTraces );\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003Ch4\u003EСерые углы и финальное объединение всего\u003C\u002Fh4\u003E\u003Cbr\u002F\u003E\r\nСерый цвет ближе к углам вычисляется с помощью скалярного произведения (ассемблерная строка 69):\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"cpp\"\u003E   \u002F\u002F * Greyish color  \n   float3 color_greyish = dot( color_circle_main, float3(0.3, 0.3, 0.3) ).xxx;\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003Cdiv style=\"text-align:center;\"\u003E\u003Cimg src=\"https:\u002F\u002F4.bp.blogspot.com\u002F-QFIZ2TIMcgs\u002FXKi6RJPXHNI\u002FAAAAAAAABdU\u002FvKYC9Js0C0klw3Sdn0oVL6GPMgrceAAwwCLcBGAs\u002Fs1600\u002Fcolor_greyish.jpg\" data-src=\"https:\u002F\u002F4.bp.blogspot.com\u002F-QFIZ2TIMcgs\u002FXKi6RJPXHNI\u002FAAAAAAAABdU\u002FvKYC9Js0C0klw3Sdn0oVL6GPMgrceAAwwCLcBGAs\u002Fs1600\u002Fcolor_greyish.jpg\" data-blurred=\"true\"\u002F\u003E\u003C\u002Fdiv\u003E\u003Cbr\u002F\u003E\r\nЗатем идут две интерполяции. Первая комбинирует серый цвет с «цветом в круге» при помощи описанной мной первой маски, поэтому углы становятся серыми. Кроме того, существует коэффициент 0.6, снижающий насыщенность финального изображения:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cdiv style=\"text-align:center;\"\u003E\u003Cimg src=\"https:\u002F\u002F2.bp.blogspot.com\u002F-Rk_oXpawOzI\u002FXKi6Qw1nnXI\u002FAAAAAAAABdQ\u002F2wvoCzvp70QSNBCiXHKaYV09uoC9vSYJgCEwYBhgL\u002Fs1600\u002Fcolor_intermediate_01.jpg\" data-src=\"https:\u002F\u002F2.bp.blogspot.com\u002F-Rk_oXpawOzI\u002FXKi6Qw1nnXI\u002FAAAAAAAABdQ\u002F2wvoCzvp70QSNBCiXHKaYV09uoC9vSYJgCEwYBhgL\u002Fs1600\u002Fcolor_intermediate_01.jpg\" data-blurred=\"true\"\u002F\u003E\u003C\u002Fdiv\u003E\u003Cbr\u002F\u003E\r\nВторая сочетает первый цвет с приведённым выше, используя \u003Ci\u003EfisheyeAmount\u003C\u002Fi\u003E. Это означает, что экран становится постепенно темнее (благодаря умножению на 0.6) и серее по углам! Гениально.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nHLSL:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"cpp\"\u003E   \u002F\u002F * Determine main color.  \n   \u002F\u002F (1) At first, combine \"circled\" color with gray one.  \n   \u002F\u002F Now we have have greyish corners here.  \n   float3 mainColor = lerp( color_greyish, color_circle_main, mask_gray_corners ) * 0.6;  \n     \n   \u002F\u002F (2) Then mix \"regular\" color with the above.  \n   \u002F\u002F Please note this operation makes corners gradually gray (because fisheyeAmount rises from 0 to 1)\n   \u002F\u002F and gradually darker (because of 0.6 multiplier).  \n   mainColor = lerp( color, mainColor, fisheyeAmount );\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nТеперь мы можем перейти к добавлению контуров объектов.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nЦвета (красный и жёлтый) берутся из буфера констант.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"cpp\"\u003E   \u002F\u002F * Determine color of witcher senses  \n   float3 senses_traces = mainOutlineTraces * colorTraces;  \n   float3 senses_interesting = mainOutlineInteresting * colorInteresting;  \n   float3 senses_total = 1.2 * senses_traces + senses_interesting;\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003Cdiv style=\"text-align:center;\"\u003E\u003Cimg src=\"https:\u002F\u002F4.bp.blogspot.com\u002F-B_58cEaYn5E\u002FXKi9BrppHBI\u002FAAAAAAAABd4\u002Fhc_1bDKaXDg2Amb6ETOVIYZWaQtOsKGyACLcBGAs\u002Fs1600\u002Fwitcher_senses_total.jpg\" data-src=\"https:\u002F\u002F4.bp.blogspot.com\u002F-B_58cEaYn5E\u002FXKi9BrppHBI\u002FAAAAAAAABd4\u002Fhc_1bDKaXDg2Amb6ETOVIYZWaQtOsKGyACLcBGAs\u002Fs1600\u002Fwitcher_senses_total.jpg\" data-blurred=\"true\"\u002F\u003E\u003C\u002Fdiv\u003E\u003Cbr\u002F\u003E\r\nФух! Мы почти у финишной черты!\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nУ нас есть окончательный цвет, есть цвет ведьмачьего чутья… осталось их каким-то образом скомбинировать!\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nИ для этого не подойдёт простое сложение. Сначала мы вычисляем скалярное произведение:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"cpp\"\u003E  78: dp3_sat r0.x, r0.xyzx, l(1.000000, 1.000000, 1.000000, 0.000000)  \n   \n  float dot_senses_total = saturate( dot(senses_total, float3(1.0, 1.0, 1.0) ) );\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nкоторое выглядит вот так:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cdiv style=\"text-align:center;\"\u003E\u003Cimg src=\"https:\u002F\u002F2.bp.blogspot.com\u002F-tb2YvHJCfJk\u002FXKi9BhGVs_I\u002FAAAAAAAABd8\u002Fq6PL_3yIS5sWBXcPpDDDKUkIopteYjmgQCEwYBhgL\u002Fs1600\u002Fwitcher_senses_dot.jpg\" data-src=\"https:\u002F\u002F2.bp.blogspot.com\u002F-tb2YvHJCfJk\u002FXKi9BhGVs_I\u002FAAAAAAAABd8\u002Fq6PL_3yIS5sWBXcPpDDDKUkIopteYjmgQCEwYBhgL\u002Fs1600\u002Fwitcher_senses_dot.jpg\" data-blurred=\"true\"\u002F\u003E\u003C\u002Fdiv\u003E\u003Cbr\u002F\u003E\r\nИ эти значения в самом конце используются для интерполяции между цветом и (насыщенным) ведьмачьим чутьём:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"cpp\"\u003E  76: mad r0.xyz, r0.yzwy, l(1.200000, 1.200000, 1.200000, 0.000000), r2.xyzx  \n  77: mov_sat r2.xyz, r0.xyzx  \n  78: dp3_sat r0.x, r0.xyzx, l(1.000000, 1.000000, 1.000000, 0.000000)  \n  79: add r0.yzw, -r1.xxyz, r2.xxyz  \n  80: mad o0.xyz, r0.xxxx, r0.yzwy, r1.xyzx  \n  81: mov o0.w, l(1.000000)  \n  82: ret  \n   \n   float3 senses_total = 1.2 * senses_traces + senses_interesting;   \n     \n   \u002F\u002F * Final combining  \n   float3 senses_total_sat = saturate(senses_total);  \n   float dot_senses_total = saturate( dot(senses_total, float3(1.0, 1.0, 1.0) ) );  \n        \n   float3 finalColor = lerp( mainColor, senses_total_sat, dot_senses_total );  \n   return float4( finalColor, 1.0 );\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E \u003Cbr\u002F\u003E\r\n\u003Cdiv style=\"text-align:center;\"\u003E\u003Cimg src=\"https:\u002F\u002F4.bp.blogspot.com\u002F-got60f2XK9Y\u002FXKihDpXA0cI\u002FAAAAAAAABbw\u002F36hozFGj4XszEAa6uD4cZKbowexKxyPYQCEwYBhgL\u002Fs1600\u002Fafter.jpg\" data-src=\"https:\u002F\u002F4.bp.blogspot.com\u002F-got60f2XK9Y\u002FXKihDpXA0cI\u002FAAAAAAAABbw\u002F36hozFGj4XszEAa6uD4cZKbowexKxyPYQCEwYBhgL\u002Fs1600\u002Fafter.jpg\" data-blurred=\"true\"\u002F\u003E\u003C\u002Fdiv\u003E\u003Cbr\u002F\u003E\r\nИ на этом всё.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nПолный шейдер выложен \u003Ca href=\"https:\u002F\u002Fpastebin.com\u002FzwFtbhQU\"\u003Eздесь\u003C\u002Fa\u003E.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nСравнение моего (слева) и оригинального (справа) шейдеров:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cdiv style=\"text-align:center;\"\u003E\u003Cimg src=\"https:\u002F\u002F1.bp.blogspot.com\u002F-6vXTjktgkww\u002FXKi-HvZhYxI\u002FAAAAAAAABeE\u002FWf4xgoxRoRwo8duWmLidw4BP_5ALZPgtgCLcBGAs\u002Fs1600\u002Fcomparison.JPG\"\u002F\u003E\u003C\u002Fdiv\u003E\u003Cbr\u002F\u003E\r\nНадеюсь, вам понравилась эта статья! В механиках «ведьмачьего чутья» есть множество блестящих идей, а готовый результат очень правдоподобен.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n[Предыдущие части анализа: \u003Ca href=\"https:\u002F\u002Fhabr.com\u002Fru\u002Fpost\u002F422573\u002F\"\u003Eпервая\u003C\u002Fa\u003E и \u003Ca href=\"https:\u002F\u002Fhabr.com\u002Fru\u002Fpost\u002F437100\u002F\"\u003Eвторая\u003C\u002Fa\u003E.]\u003C\u002Fdiv\u003E","tags":[{"titleHtml":"рендеринг"},{"titleHtml":"конвейер рендеринга"},{"titleHtml":"шейдеры"},{"titleHtml":"пиксельный шейдер"},{"titleHtml":"renderdoc"},{"titleHtml":"witcher 3"},{"titleHtml":"ведьмак 3"},{"titleHtml":"hlsl"},{"titleHtml":"directx"}],"metadata":{"stylesUrls":[],"scriptUrls":[],"shareImageUrl":"https:\u002F\u002Fhabr.com\u002Fshare\u002Fpublication\u002F450332\u002F2a23dc9145a5e6f0c233f01cf73a2d4d\u002F","shareImageWidth":1200,"shareImageHeight":630,"vkShareImageUrl":"https:\u002F\u002Fhabr.com\u002Fshare\u002Fpublication\u002F450332\u002F2a23dc9145a5e6f0c233f01cf73a2d4d\u002F?format=vk","schemaJsonLd":"{\"@context\":\"http:\\\u002F\\\u002Fschema.org\",\"@type\":\"Article\",\"mainEntityOfPage\":{\"@type\":\"WebPage\",\"@id\":\"https:\\\u002F\\\u002Fhabr.com\\\u002Fru\\\u002Fpost\\\u002F450332\\\u002F\"},\"headline\":\"Как реализован рендеринг «Ведьмака 3»: молнии, ведьмачье чутьё и другие эффекты\",\"datePublished\":\"2019-05-03T15:58:39+03:00\",\"dateModified\":\"2019-05-25T11:01:33+03:00\",\"author\":{\"@type\":\"Person\",\"name\":\"PatientZero\"},\"publisher\":{\"@type\":\"Organization\",\"name\":\"Habr\",\"logo\":{\"@type\":\"ImageObject\",\"url\":\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fwebt\\\u002Fa_\\\u002Flk\\\u002F9m\\\u002Fa_lk9mjkccjox-zccjrpfolmkmq.png\"}},\"description\":\"Часть 1. Молнии В этой части мы рассмотрим процесс рендеринга молний в Witcher 3: Wild Hunt.  Рендеринг молний выполняется немного позже эффекта занавес дождя,...\",\"url\":\"https:\\\u002F\\\u002Fhabr.com\\\u002Fru\\\u002Fpost\\\u002F450332\\\u002F#post-content-body\",\"about\":[\"h_3d_graphics\",\"h_gamedev\",\"h_reverse-engineering\",\"h_game_design\",\"f_develop\",\"f_design\"],\"image\":[\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fpost_images\\\u002Fabf\\\u002Fce7\\\u002F1c4\\\u002Fabfce71c4469b6dcd077723d498c1685.jpg\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fpost_images\\\u002F4ba\\\u002F7e1\\\u002Ff20\\\u002F4ba7e1f2075dc128baf8b717eeb3ce92.jpg\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fpost_images\\\u002F3dd\\\u002F37a\\\u002Fe59\\\u002F3dd37ae5986de4621766f4fc64525906.jpg\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fpost_images\\\u002F5b7\\\u002F23c\\\u002F3dc\\\u002F5b723c3dc1f934c0f6c14903e2a260cf.jpg\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fpost_images\\\u002F6f1\\\u002Fdca\\\u002Fddb\\\u002F6f1dcaddbdcd0f6e3c957cd8d2a1121b.jpg\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fpost_images\\\u002F609\\\u002F289\\\u002Fc37\\\u002F609289c37cea41590ffcb94beebae7e5.jpg\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fpost_images\\\u002F56a\\\u002Fd36\\\u002F09c\\\u002F56ad3609c6bbe28990bc8894b163c50d.jpg\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fpost_images\\\u002F71b\\\u002Fe90\\\u002Fb04\\\u002F71be90b04a538e953b4a0ee0d4ce2912.jpg\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fpost_images\\\u002F15a\\\u002F5d0\\\u002F48e\\\u002F15a5d048e4fcf9b12c51cad50d7bfc3e.png\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fpost_images\\\u002F25c\\\u002F708\\\u002Fe50\\\u002F25c708e503f4528c313c557abb080222.jpg\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fpost_images\\\u002F3cf\\\u002F49a\\\u002F34d\\\u002F3cf49a34dead2ff2e6f2542487edbf65.jpg\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fpost_images\\\u002F2d7\\\u002F34f\\\u002F931\\\u002F2d734f931c687dde42e3bb549a695764.jpg\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fpost_images\\\u002F360\\\u002F38d\\\u002Ffc6\\\u002F36038dfc67c29ef2934d96314ed46aff.jpg\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fpost_images\\\u002F7e9\\\u002F774\\\u002F4c2\\\u002F7e97744c28b0997b0b11049bee26fa7b.jpg\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fpost_images\\\u002Ffd9\\\u002Fed7\\\u002Fde2\\\u002Ffd9ed7de275ba36551e7751e1d351b8c.jpg\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fpost_images\\\u002F0a5\\\u002F350\\\u002Fe14\\\u002F0a5350e14231505c0ff1bd5cbf384e15.jpg\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fpost_images\\\u002F649\\\u002F9df\\\u002F02c\\\u002F6499df02c248c9bab14a597b6b111d6d.jpg\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fpost_images\\\u002Ffe6\\\u002F4ee\\\u002F77c\\\u002Ffe64ee77c1923920bc01de149ddb60e7.jpg\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fpost_images\\\u002F64d\\\u002F9e5\\\u002F416\\\u002F64d9e541622b33d646b887db01c7c1a2.jpg\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fpost_images\\\u002F184\\\u002F7dd\\\u002Fdaa\\\u002F1847dddaa38e0876bc829a2d5747c9ce.jpg\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fpost_images\\\u002F7fa\\\u002Faff\\\u002F002\\\u002F7faaff002cc6d328d663c582c74a3628.jpg\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fpost_images\\\u002F674\\\u002F662\\\u002F658\\\u002F6746626580dbe0d943c27bcda10f8a9d.jpg\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fpost_images\\\u002Fb0a\\\u002Fa4e\\\u002Ffca\\\u002Fb0aa4efcae350fe8423e3bc8a1463d78.jpg\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fpost_images\\\u002F2a6\\\u002F7ed\\\u002F667\\\u002F2a67ed667870cd52dcf0da4f366975b6.jpg\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fpost_images\\\u002Fac7\\\u002Fa84\\\u002Fa9c\\\u002Fac7a84a9c8aa25c1685a2a5f83f7447f.jpg\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fpost_images\\\u002F6f1\\\u002F073\\\u002Ff03\\\u002F6f1073f03172250a5b4c052ebfdfd832.jpg\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fpost_images\\\u002F077\\\u002Fc17\\\u002F138\\\u002F077c1713805b1f95625c05fb11643c53.jpg\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fpost_images\\\u002F14f\\\u002F7df\\\u002F63e\\\u002F14f7df63e4e1760304e4a2c6279953d1.jpg\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fpost_images\\\u002F6db\\\u002F379\\\u002Fadd\\\u002F6db379add4ffc7f54a047f79b608d67f.jpg\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fpost_images\\\u002Fa60\\\u002F227\\\u002Fb57\\\u002Fa60227b575f307ad5a251aa817a49963.jpg\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fpost_images\\\u002F014\\\u002F6eb\\\u002F5f4\\\u002F0146eb5f4da50018f5d28b4453e2424c.jpg\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fpost_images\\\u002F164\\\u002F373\\\u002Fd2c\\\u002F164373d2c3421c708e40dc9cb26eb7c9.jpg\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fpost_images\\\u002F1e5\\\u002F3c0\\\u002Fae3\\\u002F1e53c0ae3680bebe785e64739c4ece43.jpg\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fpost_images\\\u002F917\\\u002Ff0d\\\u002Fd04\\\u002F917f0dd0490ef8faa829ede007838906.jpg\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fpost_images\\\u002F68c\\\u002F07d\\\u002F1d6\\\u002F68c07d1d6fd99f81cb0b3b63c9927a53.jpg\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fpost_images\\\u002F1bf\\\u002F428\\\u002F855\\\u002F1bf4288554d1cef31c2607a4ca73c2bb.jpg\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fpost_images\\\u002Fe25\\\u002F7b3\\\u002Fe14\\\u002Fe257b3e14ac5b8a1f2b65525333924c5.jpg\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fpost_images\\\u002F559\\\u002Fe1c\\\u002F242\\\u002F559e1c242221886f5c0100fa66837c31.jpg\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fpost_images\\\u002Fbb5\\\u002F108\\\u002Fa24\\\u002Fbb5108a241181f23a66c7f3803d33cea.jpg\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fpost_images\\\u002F955\\\u002F071\\\u002Fc05\\\u002F955071c057420f3c4b083ed174046189.jpg\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fpost_images\\\u002F37c\\\u002F488\\\u002F3ab\\\u002F37c4883ab098cd1bc4ef2d22187f7d16.jpg\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fpost_images\\\u002Fdcb\\\u002F332\\\u002F626\\\u002Fdcb332626d34f07ecf1bd85928b7d1dc.jpg\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fpost_images\\\u002Fba9\\\u002F320\\\u002F0d4\\\u002Fba93200d4f20e0a5bc361e96994b525b.png\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fpost_images\\\u002F70a\\\u002F0b0\\\u002Fdfe\\\u002F70a0b0dfeb9ca86eb86f137ac96c9811.jpg\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fpost_images\\\u002F1f0\\\u002Fb6c\\\u002F0a9\\\u002F1f0b6c0a97ed9ad17a6bc17f3ebcf6c6.png\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fpost_images\\\u002Fe34\\\u002F27e\\\u002F5f2\\\u002Fe3427e5f2a925c8a78f77d81c5840da4.jpg\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fpost_images\\\u002Fbbc\\\u002F4f4\\\u002F967\\\u002Fbbc4f4967c3bf008bf3692af3eb54d69.jpg\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fpost_images\\\u002Fa08\\\u002F746\\\u002F0a3\\\u002Fa087460a37b1b88733e1fef632a566db.jpg\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fpost_images\\\u002F0c6\\\u002Fedc\\\u002F995\\\u002F0c6edc995e2f6cb4c6aeec6701c30ba3.jpg\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fpost_images\\\u002F3e3\\\u002F8f1\\\u002Fde3\\\u002F3e38f1de3016256205a5aa9199bb3a0d.jpg\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fpost_images\\\u002F5b2\\\u002F080\\\u002F809\\\u002F5b20808099b641be7510714ffd45a737.jpg\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fpost_images\\\u002Ffa8\\\u002F51d\\\u002F853\\\u002Ffa851d8539027d54d2874472d5952448.jpg\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fpost_images\\\u002Fb55\\\u002F9a1\\\u002Fe0f\\\u002Fb559a1e0f3ae66041cdf3f9f48ba4b06.jpg\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fpost_images\\\u002Fc6a\\\u002F389\\\u002F202\\\u002Fc6a38920286de2fe269224a6b26ebd77.jpg\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fpost_images\\\u002F9ca\\\u002F4ea\\\u002F52d\\\u002F9ca4ea52df8a22889828414ee2bfde05.jpg\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fpost_images\\\u002F2ae\\\u002F357\\\u002F099\\\u002F2ae357099e5bfe5185d16103f87a6b69.jpg\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fpost_images\\\u002F433\\\u002F5be\\\u002F2e4\\\u002F4335be2e49bd901916567734cc0485a5.jpg\"]}","metaDescription":"Часть 1. Молнии\r\nВ этой части мы рассмотрим процесс рендеринга молний в Witcher 3: Wild Hunt.\r\n\r\nРендеринг молний выполняется немного позже эффекта занавес дождя, но всё равно происходит в проходе...","mainImageUrl":null,"amp":false},"polls":[],"commentsEnabled":true,"rulesRemindEnabled":false,"votesEnabled":true,"status":"published","plannedPublishTime":null,"checked":null,"isEditorial":true}},"articlesIds":{},"isLoading":false,"pagesCount":{},"route":{},"reasonsList":null,"view":"cards","lastVisitedRoute":{},"ssrCommentsArticleIds":[""],"karma":{}},"authorContribution":{"authors":{}},"betaTest":{"currentAnnouncement":null,"announcements":{},"announcementCards":null,"announcementComments":{},"announcementCommentThreads":{},"announcementCommentingStatuses":{},"archivedList":[]},"authorStatistics":{"articleRefs":{},"articleIds":{},"pagesCount":{},"route":{},"viewsCount":[],"maxStatsCount":{}},"career":{"seoLandings":[],"hubs":"3d_graphics,gamedev,reverse-engineering,game_design"},"comments":{"articleComments":{},"searchCommentsResults":null,"previewComment":null,"pagesCount":null,"commentAccess":{},"scrollParents":{},"pageArticleComments":{"lastViewedComment":0,"postId":null,"lastCommentTimestamp":"","moderated":[],"moderatedIds":[],"commentRoute":""}},"companies":{"companyRefs":{},"companyIds":{},"companyTopIds":{},"pagesCount":{},"companyProfiles":{},"companiesCategories":[],"companiesCategoriesTotalCount":0,"companiesWidgets":{},"companiesWorkers":{},"companiesFans":{},"route":{},"isLoading":false,"companyWorkersLoading":false,"companyFansLoading":false,"vacancies":{}},"companiesContribution":{"hubs":{},"flows":{},"companyRefs":{}},"companyHubsContribution":{"contributionRefs":{"hubRefs":{},"hubIds":{}}},"conversation":{"messages":[],"respondent":null,"isLoadMore":false},"conversations":{"conversations":[],"unreadCount":0,"pagesCount":0,"isLoadMore":false},"desktopState":{"desktopFl":null,"desktopHl":null,"isChecked":false,"isLoginDemanded":false},"dfp":{"slotsDict":{}},"docs":{"menu":{},"articles":{},"mainMenu":[],"loading":{"main":false,"dropdown":false,"article":false}},"feature":{"isProbablyVisible":"true"},"flows":{"flows":[{"alias":"develop","id":1,"route":{"name":"FLOW_PAGE","params":{"flowName":"develop"}}},{"alias":"admin","id":6,"route":{"name":"FLOW_PAGE","params":{"flowName":"admin"}}},{"alias":"design","id":2,"route":{"name":"FLOW_PAGE","params":{"flowName":"design"}}},{"alias":"management","id":3,"route":{"name":"FLOW_PAGE","params":{"flowName":"management"}}},{"alias":"marketing","id":4,"route":{"name":"FLOW_PAGE","params":{"flowName":"marketing"}}},{"alias":"popsci","id":7,"route":{"name":"FLOW_PAGE","params":{"flowName":"popsci"}}}]},"global":{"isPwa":false,"device":"desktop","isHabrCom":true},"hubs":{"hubRefs":{},"hubIds":{},"pagesCount":{},"isLoading":false,"route":{}},"hubsBlock":{"hubRefs":{},"hubIds":{}},"i18n":{"fl":"ru","hl":"ru"},"info":{"infoPage":{},"isLoading":true},"location":{"urlStruct":{"protocol":null,"slashes":null,"auth":null,"host":null,"port":null,"hostname":null,"hash":null,"search":null,"query":{},"pathname":null,"path":null,"href":""},"searchQuery":null},"me":{"user":null,"ppgDemanded":false,"karmaResetInfo":{"canReincarnate":null,"wasReincarnated":null,"currentScore":null},"notes":null},"mostReadingList":{"mostReadingListIds":[],"mostReadingListRefs":null,"promoPost":null},"pinnedPost":{"pinnedPost":null},"ppa":{"articles":{},"card":null,"transactions":null,"totalTransactions":null,"isAccessible":null},"projectsBlocks":{"activeBlocks":{}},"pullRefresh":{"shouldRefresh":false},"sandbox":{"articleIds":[],"articleRefs":{},"pagesCount":null,"route":{},"lastVisitedRoute":{},"isLoading":false},"settingsOther":{"inputs":{"uiLang":{"errors":[],"ref":null,"value":""},"articlesLangEnglish":{"errors":[],"ref":null,"value":false},"articlesLangRussian":{"errors":[],"ref":null,"value":false},"agreement":{"errors":[],"ref":null,"value":false},"email":{"errors":[],"ref":null,"value":true},"digest":{"errors":[],"ref":null,"value":true}}},"similarList":{"similarListIds":[],"similarListRefs":null},"ssr":{"error":null,"isDataLoaded":false,"isDataLoading":false,"isHydrationFailed":false,"isServer":false},"userHubsContribution":{"contributionRefs":{"hubRefs":{},"hubIds":{}}},"userInvites":{"availableInvites":0,"usedInvitesIds":[],"usedInvitesRefs":{},"usedInvitesPagesCount":0,"unusedInvitesIds":[],"unusedInvitesRefs":{},"unusedInvitesPagesCount":0},"users":{"authorRefs":{},"authorIds":{},"pagesCount":{},"authorProfiles":{},"userHubs":{},"userInvitations":{},"authorFollowers":{},"authorFollowed":{},"karmaStats":[],"statistics":null,"isLoading":false,"authorFollowersLoading":false,"authorFollowedLoading":false,"userHubsLoading":false,"userInvitationsLoading":false,"route":{}},"viewport":{"prevScrollY":{},"scrollY":0,"width":0},"tracker":{"items":{},"pagesCache":{},"markedViewedSilently":{},"markedRead":{},"unreadCounters":{"applications":null,"system":null,"mentions":null,"subscribers":null,"posts_and_comments":null},"unviewedCounters":{"applications":null,"system":null,"mentions":null,"subscribers":null,"posts_and_comments":null}}};(function(){var s;(s=document.currentScript||document.scripts[document.scripts.length-1]).parentNode.removeChild(s);}());</script>
<script src="https://assets.habr.com/habr-web/js/chunk-vendors.c2c3fc9a.js" defer></script><script src="https://assets.habr.com/habr-web/js/app.c0af73e7.js" defer></script>



    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
        (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
        m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
    </script>
  
  <script type="text/javascript" >
    (function(m,e,t,r,i,k,a){m[i]=m[i]||function(){(m[i].a=m[i].a||[]).push(arguments)};
    m[i].l=1*new Date();k=e.createElement(t),a=e.getElementsByTagName(t)[0],k.async=1,k.src=r,a.parentNode.insertBefore(k,a)})
    (window, document, "script", "https://mc.yandex.ru/metrika/tag.js", "ym");

    ym(24049213, "init", {
      defer:true,
      trackLinks:true,
      accurateTrackBounce:true,
      webvisor:false,
    });
  </script>
  <noscript>
    <div>
      <img src="https://mc.yandex.ru/watch/24049213" style="position:absolute; left:-9999px;" alt="" />
    </div>
  </noscript>
  
    <script type="text/javascript">
      window.addEventListener('load', function () {
        setTimeout(() => {
          const img = new Image();
          img.src = 'https://vk.com/rtrg?p=VK-RTRG-421343-57vKE';
        }, 0);
      });
    </script>
  
</body>
</html>
