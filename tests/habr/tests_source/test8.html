<!DOCTYPE html>
<html lang="ru" data-vue-meta="%7B%22lang%22:%7B%22ssr%22:%22ru%22%7D%7D">
<head >
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width,initial-scale=1.0,viewport-fit=cover">
  <title>﻿Находим баги в LLVM 8 с помощью анализатора PVS-Studio / Хабр</title>
  <style>
    /* cyrillic-ext */
    @font-face {
      font-family: 'Fira Sans';
      font-style: normal;
      font-weight: 500;
      font-display: swap;
      src: url(https://fonts.gstatic.com/s/firasans/v11/va9B4kDNxMZdWfMOD5VnZKveSxf6TF0.woff2) format('woff2');
      unicode-range: U+0460-052F, U+1C80-1C88, U+20B4, U+2DE0-2DFF, U+A640-A69F, U+FE2E-FE2F;
    }

    /* cyrillic */
    @font-face {
      font-family: 'Fira Sans';
      font-style: normal;
      font-weight: 500;
      font-display: swap;
      src: url(https://fonts.gstatic.com/s/firasans/v11/va9B4kDNxMZdWfMOD5VnZKveQhf6TF0.woff2) format('woff2');
      unicode-range: U+0400-045F, U+0490-0491, U+04B0-04B1, U+2116;
    }

    /* latin-ext */
    @font-face {
      font-family: 'Fira Sans';
      font-style: normal;
      font-weight: 500;
      font-display: swap;
      src: url(https://fonts.gstatic.com/s/firasans/v11/va9B4kDNxMZdWfMOD5VnZKveSBf6TF0.woff2) format('woff2');
      unicode-range: U+0100-024F, U+0259, U+1E00-1EFF, U+2020, U+20A0-20AB, U+20AD-20CF, U+2113, U+2C60-2C7F, U+A720-A7FF;
    }

    /* latin */
    @font-face {
      font-family: 'Fira Sans';
      font-style: normal;
      font-weight: 500;
      font-display: swap;
      src: url(https://fonts.gstatic.com/s/firasans/v11/va9B4kDNxMZdWfMOD5VnZKveRhf6.woff2) format('woff2');
      unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2122, U+2191, U+2193, U+2212, U+2215, U+FEFF, U+FFFD;
    }
  </style>
  <link rel="preload" href="https://assets.habr.com/habr-web/css/chunk-vendors.e7843cc0.css" as="style"><link rel="preload" href="https://assets.habr.com/habr-web/js/chunk-vendors.c2c3fc9a.js" as="script"><link rel="preload" href="https://assets.habr.com/habr-web/css/app.02ee25a4.css" as="style"><link rel="preload" href="https://assets.habr.com/habr-web/js/app.c0af73e7.js" as="script">
  <link rel="stylesheet" href="https://assets.habr.com/habr-web/css/chunk-vendors.e7843cc0.css"><link rel="stylesheet" href="https://assets.habr.com/habr-web/css/app.02ee25a4.css">
  <script>window.i18nFetch = new Promise((res, rej) => {
          const xhr = new XMLHttpRequest();
          xhr.open('GET', '/js/i18n/ru-compiled.85eb77f0b17c8235e7b64b9f81ea5ec2.json');
          xhr.responseType = 'json';
          xhr.onload = function(e) {
            if (this.status === 200) {
              res({ru: xhr.response});
            } else {
              rej(e);
            }
          };
          xhr.send();
        });</script>
  
  <script data-vue-meta="ssr" src="/js/ads.js" onload="window['zhY4i4nJ9K'] = true" data-vmid="checkad"></script><script data-vue-meta="ssr" type="application/ld+json" data-vmid="ldjson-schema">{"@context":"http:\/\/schema.org","@type":"Article","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/habr.com\/ru\/company\/pvs-studio\/blog\/450008\/"},"headline":"﻿Находим баги в LLVM 8 с помощью анализатора PVS-Studio","datePublished":"2019-04-29T16:52:32+03:00","dateModified":"2019-04-30T00:31:49+03:00","author":{"@type":"Person","name":"Andrey Karpov"},"publisher":{"@type":"Organization","name":"Habr","logo":{"@type":"ImageObject","url":"https:\/\/habrastorage.org\/webt\/a_\/lk\/9m\/a_lk9mjkccjox-zccjrpfolmkmq.png"}},"description":"Прошло более двух лет с момента последней проверки кода проекта LLVM с помощью нашего анализатора PVS-Studio. Давайте убедимся, что анализатор PVS-Studio по-пре...","url":"https:\/\/habr.com\/ru\/company\/pvs-studio\/blog\/450008\/#post-content-body","about":["c_pvs-studio","h_open_source","h_cpp","h_compilers","h_devops","f_develop","f_admin"],"image":["https:\/\/habrastorage.org\/getpro\/habr\/post_images\/2f2\/8d4\/5bf\/2f28d45bf369270d9330bfbe2ea78f00.png","https:\/\/habrastorage.org\/getpro\/habr\/post_images\/d5d\/183\/d4e\/d5d183d4e2d3107bc512e52d893fda25.png","https:\/\/habrastorage.org\/getpro\/habr\/post_images\/8a2\/f86\/58f\/8a2f8658fdacb0dde918807666d1cd39.png","https:\/\/habrastorage.org\/getpro\/habr\/post_images\/c78\/30f\/70c\/c7830f70c5577c3d6704f254d7cad6a3.png"]}</script>
  <script src="//www.googletagservices.com/tag/js/gpt.js" async></script>
  <style>.grecaptcha-badge{visibility: hidden;}</style>
  <meta name="habr-version" content="2.49.0">
  
  <meta data-vue-meta="ssr" property="fb:app_id" content="444736788986613"><meta data-vue-meta="ssr" property="fb:pages" content="472597926099084"><meta data-vue-meta="ssr" name="twitter:card" content="summary_large_image"><meta data-vue-meta="ssr" name="twitter:site" content="@habr_eng"><meta data-vue-meta="ssr" property="og:title" content="﻿Находим баги в LLVM 8 с помощью анализатора PVS-Studio" data-vmid="og:title"><meta data-vue-meta="ssr" name="twitter:title" content="﻿Находим баги в LLVM 8 с помощью анализатора PVS-Studio" data-vmid="twitter:title"><meta data-vue-meta="ssr" name="aiturec:title" content="﻿Находим баги в LLVM 8 с помощью анализатора PVS-Studio" data-vmid="aiturec:title"><meta data-vue-meta="ssr" name="description" content="Прошло более двух лет с момента последней проверки кода проекта LLVM с помощью нашего анализатора PVS-Studio. Давайте убедимся, что анализатор PVS-Studio по-прежнему является лидирующим инструментом..." data-vmid="description"><meta data-vue-meta="ssr" itemprop="description" content="Прошло более двух лет с момента последней проверки кода проекта LLVM с помощью нашего анализатора PVS-Studio. Давайте убедимся, что анализатор PVS-Studio по-прежнему является лидирующим инструментом..." data-vmid="description:itemprop"><meta data-vue-meta="ssr" property="og:description" content="Прошло более двух лет с момента последней проверки кода проекта LLVM с помощью нашего анализатора PVS-Studio. Давайте убедимся, что анализатор PVS-Studio по-прежнему является лидирующим инструментом..." data-vmid="og:description"><meta data-vue-meta="ssr" name="twitter:description" content="Прошло более двух лет с момента последней проверки кода проекта LLVM с помощью нашего анализатора PVS-Studio. Давайте убедимся, что анализатор PVS-Studio по-прежнему является лидирующим инструментом..." data-vmid="twitter:description"><meta data-vue-meta="ssr" property="aiturec:description" content="Прошло более двух лет с момента последней проверки кода проекта LLVM с помощью нашего анализатора PVS-Studio. Давайте убедимся, что анализатор PVS-Studio по-прежнему является лидирующим инструментом..." data-vmid="aiturec:description"><meta data-vue-meta="ssr" itemprop="image" content="https://habr.com/share/publication/450008/63d71ef8c5bfaaa3818dde5b3df1c543/" data-vmid="image:itemprop"><meta data-vue-meta="ssr" property="og:image" content="https://habr.com/share/publication/450008/63d71ef8c5bfaaa3818dde5b3df1c543/" data-vmid="og:image"><meta data-vue-meta="ssr" property="aiturec:image" content="https://habr.com/share/publication/450008/63d71ef8c5bfaaa3818dde5b3df1c543/" data-vmid="aiturec:image"><meta data-vue-meta="ssr" name="twitter:image" content="https://habr.com/share/publication/450008/63d71ef8c5bfaaa3818dde5b3df1c543/" data-vmid="twitter:image"><meta data-vue-meta="ssr" property="vk:image" content="https://habr.com/share/publication/450008/63d71ef8c5bfaaa3818dde5b3df1c543/" data-vmid="vk:image"><meta data-vue-meta="ssr" property="aiturec:item_id" content="450008" data-vmid="aiturec:item_id"><meta data-vue-meta="ssr" property="aiturec:datetime" content="2019-04-29T13:52:32.000Z" data-vmid="aiturec:datetime"><meta data-vue-meta="ssr" property="og:type" content="article" data-vmid="og:type"><meta data-vue-meta="ssr" property="og:locale" content="ru_RU" data-vmid="og:locale"><meta data-vue-meta="ssr" property="og:image:width" content="1200" data-vmid="og:image:width"><meta data-vue-meta="ssr" property="og:image:height" content="630" data-vmid="og:image:height">
  <link data-vue-meta="ssr" href="https://habr.com/ru/rss/post/450008/?fl=ru" type="application/rss+xml" title="" rel="alternate" name="rss"><link data-vue-meta="ssr" href="https://habr.com/ru/company/pvs-studio/blog/450008/" rel="canonical" data-vmid="canonical"><link data-vue-meta="ssr" data-vmid="hreflang"><link data-vue-meta="ssr" image_src="image" href="https://habr.com/share/publication/450008/63d71ef8c5bfaaa3818dde5b3df1c543/" data-vmid="image:href">
  <meta name="apple-mobile-web-app-status-bar-style" content="#303b44">
  <meta name="msapplication-TileColor" content="#629FBC">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="mobile-web-app-capable" content="yes">
  <link
    rel="shortcut icon"
    type="image/png"
    sizes="16x16"
    href="https://assets.habr.com/habr-web/img/favicons/favicon-16.png"
  >
  <link
    rel="shortcut icon"
    type="image/png"
    sizes="32x32"
    href="https://assets.habr.com/habr-web/img/favicons/favicon-32.png"
  >
  <link
    rel="apple-touch-icon"
    type="image/png"
    sizes="76x76"
    href="https://assets.habr.com/habr-web/img/favicons/apple-touch-icon-76.png"
  >
  <link
    rel="apple-touch-icon"
    type="image/png"
    sizes="120x120"
    href="https://assets.habr.com/habr-web/img/favicons/apple-touch-icon-120.png"
  >
  <link
    rel="apple-touch-icon"
    type="image/png"
    sizes="152x152"
    href="https://assets.habr.com/habr-web/img/favicons/apple-touch-icon-152.png"
  >
  <link
    rel="apple-touch-icon"
    type="image/png"
    sizes="180x180"
    href="https://assets.habr.com/habr-web/img/favicons/apple-touch-icon-180.png"
  >
  <link
    rel="apple-touch-icon"
    type="image/png"
    sizes="256x256"
    href="https://assets.habr.com/habr-web/img/favicons/apple-touch-icon-256.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 320px) and (device-height: 568px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1136x640.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 375px) and (device-height: 812px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_2436x1125.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1792x828.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_828x1792.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 375px) and (device-height: 667px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1334x750.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1242x2668.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 414px) and (device-height: 736px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_2208x1242.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 375px) and (device-height: 812px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1125x2436.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 414px) and (device-height: 736px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1242x2208.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 1024px) and (device-height: 1366px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_2732x2048.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_2688x1242.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 834px) and (device-height: 1112px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_2224x1668.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 375px) and (device-height: 667px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_750x1334.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 1024px) and (device-height: 1366px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_2048x2732.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 834px) and (device-height: 1194px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_2388x1668.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 834px) and (device-height: 1112px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1668x2224.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 320px) and (device-height: 568px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_640x1136.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 834px) and (device-height: 1194px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1668x2388.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 768px) and (device-height: 1024px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_2048x1536.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 768px) and (device-height: 1024px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1536x2048.png"
  >
  <link
    rel="mask-icon"
    color="#77a2b6"
    href="https://assets.habr.com/habr-web/img/favicons/apple-touch-icon-120.svg"
  >
  <link
    crossorigin="use-credentials"
    href="/manifest.webmanifest"
    rel="manifest"
  >
</head>
<body>


<div id="app" data-server-rendered="true" data-async-called="true"><div class="tm-layout__wrapper"><!----> <div></div> <!----> <header class="tm-header"><div class="tm-page-width"><div class="tm-header__container"><!----> <span class="tm-header__logo-wrap"><a href="/ru/" class="tm-header__logo tm-header__logo_ru"><svg height="16" width="16" class="tm-svg-img tm-header__icon"><title>Хабр</title> <use xlink:href="/img/habr-logo-ru.svg#logo"></use></svg></a> <span class="tm-header__beta-sign" style="display:none;">β</span></span> <div class="tm-dropdown tm-header__projects"><div class="tm-dropdown__head"><button class="tm-header__dropdown-toggle"><svg height="16" width="16" class="tm-svg-img tm-header__icon tm-header__icon_dropdown"><title>Открыть список</title> <use xlink:href="/img/megazord-v24.ce74655c.svg#arrow-down"></use></svg></button></div> <!----></div> <a href="/ru/sandbox/start/" class="tm-header__become-author-btn">
            Как стать автором
          </a> <div class="tm-feature tm-header__feature tm-feature_variant-inline"><!----></div> <!----> <!----></div></div></header> <div class="tm-layout"><div class="tm-page-progress-bar"></div> <div data-menu-sticky="true" class="tm-base-layout__header tm-base-layout__header_is-sticky"><div class="tm-page-width"><div class="tm-base-layout__header-wrapper"><div class="tm-main-menu"><div class="tm-main-menu__section"><nav class="tm-main-menu__section-content"><!----> <a href="/ru/all/" class="tm-main-menu__item">
        Все потоки
      </a> <a href="/ru/flows/develop/" class="tm-main-menu__item">
          Разработка
        </a><a href="/ru/flows/admin/" class="tm-main-menu__item">
          Администрирование
        </a><a href="/ru/flows/design/" class="tm-main-menu__item">
          Дизайн
        </a><a href="/ru/flows/management/" class="tm-main-menu__item">
          Менеджмент
        </a><a href="/ru/flows/marketing/" class="tm-main-menu__item">
          Маркетинг
        </a><a href="/ru/flows/popsci/" class="tm-main-menu__item">
          Научпоп
        </a></nav></div></div> <div class="tm-header-user-menu tm-base-layout__user-menu"><a href="/ru/search/" class="tm-header-user-menu__item tm-header-user-menu__search"><svg height="24" width="24" class="tm-svg-img tm-header-user-menu__icon tm-header-user-menu__icon_search tm-header-user-menu__icon_dark"><title>Поиск</title> <use xlink:href="/img/megazord-v24.ce74655c.svg#search"></use></svg></a> <!----> <!----> <!----> <div class="tm-header-user-menu__item tm-header-user-menu__user_desktop"><div class="tm-dropdown"><div class="tm-dropdown__head"><svg height="24" width="24" data-test-id="menu-toggle-guest" class="tm-svg-img tm-header-user-menu__icon"><title>Профиль</title> <use xlink:href="/img/megazord-v24.ce74655c.svg#header-user"></use></svg> <!----></div> <!----></div> <!----></div> <!----></div></div></div></div> <!----> <div class="tm-page-width"></div> <main class="tm-layout__container"><div hl="ru" companyName="pvs-studio" data-async-called="true" class="tm-page"><div class="tm-page-width"><div class="tm-page__header"><!----></div> <div class="tm-page__wrapper"><div class="tm-page__main tm-page__main_has-sidebar"><div class="pull-down"><div class="pull-down__header" style="height:0px;"><div class="pull-down__content" style="bottom:10px;"><svg height="24" width="24" class="tm-svg-img pull-down__arrow"><title>Обновить</title> <use xlink:href="/img/megazord-v24.ce74655c.svg#pull-arrow"></use></svg></div></div> <div class="tm-article-presenter"><div class="tm-company-card tm-company-article__company-card"><div class="tm-company-card__info"><div class="tm-company-card__header"><a href="/ru/company/pvs-studio/profile/" class="tm-company-card__avatar"><div class="tm-entity-image"><img alt="" height="48" src="//habrastorage.org/getpro/habr/company/95a/244/327/95a244327fc36477b6048c0f8b67df8b.png" width="48" class="tm-entity-image__pic"></div></a> <!----> <div class="tm-rating tm-company-card__rating"><div class="tm-rating__header"> <div class="tm-rating__counter">256.33</div></div> <div class="tm-rating__text">
    Рейтинг
  </div></div></div> <div class="tm-company-card__info"><a href="/ru/company/pvs-studio/profile/" class="tm-company-card__name">
        PVS-Studio
      </a> <div class="tm-company-card__description">Статический анализ кода для C, C++, C# и Java</div></div></div> <div class="tm-company-card__buttons"><!----> <!----></div></div> <div class="tm-article-presenter__body"><div class="tm-misprint-area"><div class="tm-misprint-area__wrapper"><article class="tm-article-presenter__content tm-article-presenter__content_narrow"><div class="tm-article-presenter__header"> <div class="tm-article-snippet tm-article-presenter__snippet"><div class="tm-article-snippet__meta-container"><div class="tm-article-snippet__meta"><span class="tm-user-info tm-article-snippet__author"><a href="/ru/users/Andrey2008/" title="Andrey2008" class="tm-user-info__userpic"><div class="tm-entity-image"><img alt="" height="24" loading="lazy" src="//habrastorage.org/r/w32/getpro/habr/avatars/71b/4ac/f13/71b4acf131d3d675b999b4a47f573b0a.jpg" width="24" class="tm-entity-image__pic"></div></a> <span class="tm-user-info__user"><a href="/ru/users/Andrey2008/" class="tm-user-info__username">
      Andrey2008
    </a> </span></span> <span class="tm-article-snippet__datetime-published"><time datetime="2019-04-29T13:52:32.000Z" title="2019-04-29, 16:52">29  апреля  2019 в 16:52</time></span></div> <!----></div> <h1 lang="ru" class="tm-article-snippet__title tm-article-snippet__title_h1"><span>﻿Находим баги в LLVM 8 с помощью анализатора PVS-Studio</span></h1> <div class="tm-article-snippet__hubs"><span class="tm-article-snippet__hubs-item"><a href="/ru/company/pvs-studio/blog/" class="tm-article-snippet__hubs-item-link router-link-active"><span>Блог компании PVS-Studio</span> <!----></a></span><span class="tm-article-snippet__hubs-item"><a href="/ru/hub/open_source/" class="tm-article-snippet__hubs-item-link"><span>Open source</span> <span title="Профильный хаб" class="tm-article-snippet__profiled-hub">*</span></a></span><span class="tm-article-snippet__hubs-item"><a href="/ru/hub/cpp/" class="tm-article-snippet__hubs-item-link"><span>C++</span> <span title="Профильный хаб" class="tm-article-snippet__profiled-hub">*</span></a></span><span class="tm-article-snippet__hubs-item"><a href="/ru/hub/compilers/" class="tm-article-snippet__hubs-item-link"><span>Компиляторы</span> <span title="Профильный хаб" class="tm-article-snippet__profiled-hub">*</span></a></span><span class="tm-article-snippet__hubs-item"><a href="/ru/hub/devops/" class="tm-article-snippet__hubs-item-link"><span>DevOps</span> <span title="Профильный хаб" class="tm-article-snippet__profiled-hub">*</span></a></span></div> <!----> <!----> <!----></div></div> <!----> <div data-gallery-root="" lang="ru" class="tm-article-body"><div id="post-content-body" class="article-formatted-body article-formatted-body_version-1"><div xmlns="http://www.w3.org/1999/xhtml"><div style="text-align:center;"><img src="/img/image-loader.svg" alt="PVS-Studio and LLVM 8.0.0" data-src="https://habrastorage.org/getpro/habr/post_images/2f2/8d4/5bf/2f28d45bf369270d9330bfbe2ea78f00.png"/></div><br/>
Прошло более двух лет с момента последней проверки кода проекта LLVM с помощью нашего анализатора PVS-Studio. Давайте убедимся, что анализатор PVS-Studio по-прежнему является лидирующим инструментом по выявлению ошибок и потенциальных уязвимостей. Для этого проверим и найдём новые ошибки в релизе LLVM 8.0.0.<br/>
<a name="habracut"></a><br/>
<h2>Статья, которая должна быть написана</h2><br/>
Если честно, мне не хотелось писать эту статью. Неинтересно писать про проект, который мы уже неоднократно проверяли (<a href="https://www.viva64.com/ru/b/0108/">1</a>, <a href="https://www.viva64.com/ru/b/0155/">2</a>, <a href="https://www.viva64.com/ru/b/0446/">3</a>). Лучше написать про что-то новое, но у меня нет выбора.<br/>
<br/>
Каждый раз, когда выходит новая версия LLVM или обновляется <a href="https://clang-analyzer.llvm.org/">Clang Static Analyzer</a>, у нас в почте появляются вопросы следующего типа:<br/>
<br/>
<i>Смотрите, новая версия Clang Static Analyzer научилась находить новые ошибки! Мне кажется, актуальность использовать PVS-Studio уменьшается. Clang находит больше ошибок, чем раньше и догоняет по возможностям PVS-Studio. Что вы про это думаете?</i><br/>
<br/>
На это мне всегда хочется ответить что-то в духе:<br/>
<br/>
<b>Мы тоже не сидим без дела!</b> Мы существенно улучшили возможности анализатора PVS-Studio. Так что не волнуйтесь, мы продолжаем лидировать, как и раньше.<br/>
<br/>
К сожалению, это плохой ответ. В нём нет proof-ов. И именно поэтому сейчас я пишу эту статью. Итак, проект LLVM в очередной раз проверен и в нём найдены разнообразнейшие ошибки. Те, которые мне показались интересными, я сейчас продемонстрирую. Эти ошибки не может найти Clang Static Analyzer (или это крайне неудобно делать с его помощью). А мы можем. Причём я нашел и выписал все эти ошибки за один вечер.<br/>
<br/>
А вот написание статьи затянулось на несколько недель. Никак не мог себя заставить всё это оформить в виде текста :).<br/>
<br/>
Кстати, если вам интересно, какие технологии используются в анализаторе PVS-Studio для выявления ошибок и потенциальных уязвимостей, то я предлагаю познакомиться с этой <a href="https://www.viva64.com/ru/b/0592/">заметкой</a>.<br/>
<br/>
<h2>Новые и старые диагностики</h2><br/>
Как уже было отмечено, около двух лет назад проект LLVM был в очередной раз проверен, а найденные ошибки исправлены. Теперь в этой статье будет представлена новая порция ошибок. Почему были найдены новые ошибки? На это есть 3 причины:<br/>
<br/>
<ol>
<li>Проект LLVM развивается, в нём изменяется старый код, и появляется новый. Естественно в изменённом и написанном коде есть новые ошибки. Это хорошо демонстрирует, что статический анализ должен применяться регулярно, а не от случая к случаю. Наши статьи хорошо показывают возможности анализатора PVS-Studio, но это не имеет ничего общего с повышением качества кода и снижением стоимости исправления ошибок. Используйте статический анализатор кода регулярно!</li>
<li>Мы дорабатываем и усовершенствуем уже существующие диагностики. Поэтому анализатор может выявить ошибки, которые не замечал при предыдущих проверках.</li>
<li>В PVS-Studio появились новые диагностики, которых не было 2 года назад. Я решил выделить их в отдельный раздел, чтобы наглядно показать развитие PVS-Studio.</li>
</ol><br/>
<h2>Дефекты, выявленные диагностиками, существовавшими 2 года назад</h2><br/>
<b>Фрагмент N1: Copy-Paste</b><br/>
<br/>
<pre><code class="cpp">static bool ShouldUpgradeX86Intrinsic(Function *F, StringRef Name) {
  if (Name == "addcarryx.u32" || // Added in 8.0
    ....
    Name == "avx512.mask.cvtps2pd.128" || // Added in 7.0
    Name == "avx512.mask.cvtps2pd.256" || // Added in 7.0
    Name == "avx512.cvtusi2sd" || // Added in 7.0
    Name.startswith("avx512.mask.permvar.") || // Added in 7.0     // &lt;=
    Name.startswith("avx512.mask.permvar.") || // Added in 7.0     // &lt;=
    Name == "sse2.pmulu.dq" || // Added in 7.0
    Name == "sse41.pmuldq" || // Added in 7.0
    Name == "avx2.pmulu.dq" || // Added in 7.0
  ....
}</code></pre><br/>
Предупреждение PVS-Studio: <a href="https://www.viva64.com/ru/w/v501/">V501</a> [CWE-570] There are identical sub-expressions 'Name.startswith(«avx512.mask.permvar.»)' to the left and to the right of the '||' operator. AutoUpgrade.cpp 73<br/>
<br/>
Дважды проверяется, что имя начинается с подстроки «avx512.mask.permvar.». Во второй проверке явно хотели написать что-то ещё, но забыли исправить скопированный текст.<br/>
<br/>
<b>Фрагмент N2: Опечатка</b><br/>
<br/>
<pre><code class="cpp">enum CXNameRefFlags {
  CXNameRange_WantQualifier = 0x1,
  CXNameRange_WantTemplateArgs = 0x2,
  CXNameRange_WantSinglePiece = 0x4
};

void AnnotateTokensWorker::HandlePostPonedChildCursor(
    CXCursor Cursor, unsigned StartTokenIndex) {
  const auto flags = CXNameRange_WantQualifier | CXNameRange_WantQualifier;
  ....
}</code></pre><br/>
Предупреждение PVS-Studio: V501 There are identical sub-expressions 'CXNameRange_WantQualifier' to the left and to the right of the '|' operator. CIndex.cpp 7245<br/>
<br/>
Из-за опечатки дважды используется одна и та же именованная константа <i>CXNameRange_WantQualifier</i>.<br/>
<br/>
<b>Фрагмент N3: Путаница с приоритетами операторов</b><br/>
<br/>
<pre><code class="cpp">int PPCTTIImpl::getVectorInstrCost(unsigned Opcode, Type *Val, unsigned Index) {
  ....
  if (ISD == ISD::EXTRACT_VECTOR_ELT &amp;&amp; Index == ST->isLittleEndian() ? 1 : 0)
    return 0;
  ....
}</code></pre><br/>
Предупреждение PVS-Studio: <a href="https://www.viva64.com/ru/w/v502/">V502</a> [CWE-783] Perhaps the '?:' operator works in a different way than it was expected. The '?:' operator has a lower priority than the '==' operator. PPCTargetTransformInfo.cpp 404<br/>
<br/>
На мой взгляд, это очень красивая ошибка. Да, я знаю, что у меня странные представления о красоте :).<br/>
<br/>
Сейчас, согласно <a href="https://www.viva64.com/ru/t/0064/">приоритетам операторов</a>, выражение вычисляется следующим образом:<br/>
<br/>
<pre><code class="cpp">(ISD == ISD::EXTRACT_VECTOR_ELT &amp;&amp; (Index == ST->isLittleEndian())) ? 1 : 0</code></pre><br/>
С практической точки зрения такое условие не имеет смысла, так как его можно сократить до:<br/>
<br/>
<pre><code class="cpp">(ISD == ISD::EXTRACT_VECTOR_ELT &amp;&amp; Index == ST->isLittleEndian())</code></pre><br/>
Это явная ошибка. Скорее всего, 0/1 хотели сравнить с переменной <i>Index</i>. Чтобы исправить код необходимо добавить скобки вокруг тернарного оператора:<br/>
<br/>
<pre><code class="cpp">if (ISD == ISD::EXTRACT_VECTOR_ELT &amp;&amp; Index == (ST->isLittleEndian() ? 1 : 0))</code></pre><br/>
Кстати, тернарный оператор очень опасный и провоцирует логические ошибки. Будьте очень аккуратны с ним и не жадничайте ставить круглые скобки. Подробнее эту тему я рассматривал <a href="https://www.viva64.com/ru/b/0391/">здесь</a>, в главе «Бойтесь оператора ?: и заключайте его в круглые скобки».<br/>
<br/>
<b>Фрагмент N4, N5: Нулевой указатель</b><br/>
<br/>
<pre><code class="cpp">Init *TGParser::ParseValue(Record *CurRec, RecTy *ItemType, IDParseMode Mode) {
  ....
  TypedInit *LHS = dyn_cast&lt;TypedInit>(Result);
  ....
  LHS = dyn_cast&lt;TypedInit>(
    UnOpInit::get(UnOpInit::CAST, LHS, StringRecTy::get())
      ->Fold(CurRec));
  if (!LHS) {
    Error(PasteLoc, Twine("can't cast '") + LHS->getAsString() +
                    "' to string");
    return nullptr;
  }
  ....
}</code></pre><br/>
Предупреждение PVS-Studio: <a href="https://www.viva64.com/ru/w/v522/">V522</a> [CWE-476] Dereferencing of the null pointer 'LHS' might take place. TGParser.cpp 2152<br/>
<br/>
Если указатель <i>LHS</i> окажется нулевым, то должно быть выдано предупреждение. Однако вместо этого произойдёт разыменование этого самого нулевого указателя: <i>LHS->getAsString()</i>.<br/>
<br/>
Это весьма типовая ситуация, когда ошибка прячется в обработчике ошибок, так как их никто не тестирует. Статические анализаторы проверяют весь достижимый код, независимо от того, как часто он используется. Это очень хороший пример, как статический анализ дополняет другие методики тестирования и защиты от ошибок.<br/>
<br/>
Аналогичная ошибка обработки указателя <i>RHS</i> допущена в коде чуть ниже: V522 [CWE-476] Dereferencing of the null pointer 'RHS' might take place. TGParser.cpp 2186<br/>
<br/>
<b>Фрагмент N6: Использование указателя после перемещения</b><br/>
<br/>
<pre><code class="cpp">static Expected&lt;bool>
ExtractBlocks(....)
{
  ....
  std::unique_ptr&lt;Module> ProgClone = CloneModule(BD.getProgram(), VMap);
  ....
  BD.setNewProgram(std::move(ProgClone));                                // &lt;=
  MiscompiledFunctions.clear();

  for (unsigned i = 0, e = MisCompFunctions.size(); i != e; ++i) {
    Function *NewF = ProgClone->getFunction(MisCompFunctions[i].first);  // &lt;=
    assert(NewF &amp;&amp; "Function not found??");
    MiscompiledFunctions.push_back(NewF);
  }
  ....
}</code></pre><br/>
Предупреждение PVS-Studio: V522 [CWE-476] Dereferencing of the null pointer 'ProgClone' might take place. Miscompilation.cpp 601<br/>
<br/>
В начале умный указатель <i>ProgClone</i> перестаёт владеть объектом:<br/>
<br/>
<pre><code class="cpp">BD.setNewProgram(std::move(ProgClone));</code></pre><br/>
Фактически, теперь <i>ProgClone </i> — это нулевой указатель. Поэтому чуть ниже должно произойти разыменование нулевого указателя:<br/>
<br/>
<pre><code class="cpp">Function *NewF = ProgClone->getFunction(MisCompFunctions[i].first);</code></pre><br/>
Но, на самом деле, этого не произойдёт! Обратите внимание, что цикл на самом деле не выполняется.<br/>
<br/>
В начале контейнер <i>MiscompiledFunctions</i> очищается:<br/>
<br/>
<pre><code class="cpp">MiscompiledFunctions.clear();</code></pre><br/>
Далее размер этого контейнера используется в условии цикла:<br/>
<br/>
<pre><code class="cpp">for (unsigned i = 0, e = MisCompFunctions.size(); i != e; ++i) {</code></pre><br/>
Легко видеть, что цикл не запускается. Думаю, это тоже ошибка, и код должен быть написан иным образом.<br/>
<br/>
Кажется, мы встретили ту самую знаменитую чётность ошибок! Одна ошибка маскирует другую :).<br/>
<br/>
<b>Фрагмент N7: Использование указателя после перемещения</b><br/>
<br/>
<pre><code class="cpp">static Expected&lt;bool> TestOptimizer(BugDriver &amp;BD, std::unique_ptr&lt;Module> Test,
                                    std::unique_ptr&lt;Module> Safe) {
  outs() &lt;&lt; "  Optimizing functions being tested: ";
  std::unique_ptr&lt;Module> Optimized =
      BD.runPassesOn(Test.get(), BD.getPassesToRun());
  if (!Optimized) {
    errs() &lt;&lt; " Error running this sequence of passes"
           &lt;&lt; " on the input program!\n";
    BD.setNewProgram(std::move(Test));                       // &lt;=
    BD.EmitProgressBitcode(*Test, "pass-error", false);      // &lt;=
    if (Error E = BD.debugOptimizerCrash())
      return std::move(E);
    return false;
  }
  ....
}</code></pre><br/>
Предупреждение PVS-Studio: V522 [CWE-476] Dereferencing of the null pointer 'Test' might take place. Miscompilation.cpp 709<br/>
<br/>
Вновь та же самая ситуация. В начале содержимое объекта перемещается, а затем он используется как ни в чём не бывало. Я всё чаще встречаю эту ситуацию в коде программ, после того, как в С++ появилась семантика перемещения. За это я и люблю язык C++! Появляются всё новые и новые способы отстрелить себе ногу. Анализатору PVS-Studio всегда будет работа :).<br/>
<br/>
<b>Фрагмент N8: Нулевой указатель</b><br/>
<br/>
<pre><code class="cpp">void FunctionDumper::dump(const PDBSymbolTypeFunctionArg &amp;Symbol) {
  uint32_t TypeId = Symbol.getTypeId();
  auto Type = Symbol.getSession().getSymbolById(TypeId);
  if (Type)
    Printer &lt;&lt; "&lt;unknown-type>";
  else
    Type->dump(*this);
}</code></pre><br/>
Предупреждение PVS-Studio: V522 [CWE-476] Dereferencing of the null pointer 'Type' might take place. PrettyFunctionDumper.cpp 233<br/>
<br/>
Помимо обработчиков ошибок, обычно не тестируются и функции отладочной распечатки данных. Перед нами как раз такой случай. Функция ждёт пользователя, которой вместо того чтобы решить свои проблемы, будет вынужден заняться её исправлением.<br/>
<br/>
Правильно:<br/>
<br/>
<pre><code class="cpp">if (Type)
  Type->dump(*this);
else
  Printer &lt;&lt; "&lt;unknown-type>";</code></pre><br/>
<b>Фрагмент N9: Нулевой указатель</b><br/>
<br/>
<pre><code class="cpp">void SearchableTableEmitter::collectTableEntries(
    GenericTable &amp;Table, const std::vector&lt;Record *> &amp;Items) {
  ....
  RecTy *Ty = resolveTypes(Field.RecType, TI->getType());
  if (!Ty)                                                              // &lt;=
    PrintFatalError(Twine("Field '") + Field.Name + "' of table '" +
                    Table.Name + "' has incompatible type: " +
                    Ty->getAsString() + " vs. " +                       // &lt;=
                    TI->getType()->getAsString());
   ....
}</code></pre><br/>
Предупреждение PVS-Studio: V522 [CWE-476] Dereferencing of the null pointer 'Ty' might take place. SearchableTableEmitter.cpp 614<br/>
<br/>
Думаю, и так всё понятно и не требует пояснений.<br/>
<br/>
<b>Фрагмент N10: Опечатка</b><br/>
<br/>
<pre><code class="cpp">bool FormatTokenLexer::tryMergeCSharpNullConditionals() {
  ....
  auto &amp;Identifier = *(Tokens.end() - 2);
  auto &amp;Question = *(Tokens.end() - 1);
  ....
  Identifier->ColumnWidth += Question->ColumnWidth;
  Identifier->Type = Identifier->Type;                    // &lt;=
  Tokens.erase(Tokens.end() - 1);
  return true;
}</code></pre><br/>
Предупреждение PVS-Studio: <a href="https://www.viva64.com/ru/w/v570/">V570</a> The 'Identifier->Type' variable is assigned to itself. FormatTokenLexer.cpp 249<br/>
<br/>
Нет смысла присваивать переменную саму себе. Скорее всего хотели написать:<br/>
<br/>
<pre><code class="cpp">Identifier->Type = Question->Type;</code></pre><br/>
<b>Фрагмент N11: Подозрительный break</b><br/>
<pre><code class="cpp">void SystemZOperand::print(raw_ostream &amp;OS) const {
  switch (Kind) {
    break;
  case KindToken:
    OS &lt;&lt; "Token:" &lt;&lt; getToken();
    break;
  case KindReg:
    OS &lt;&lt; "Reg:" &lt;&lt; SystemZInstPrinter::getRegisterName(getReg());
    break;
  ....
}</code></pre><br/>
Предупреждение PVS-Studio: <a href="https://www.viva64.com/ru/w/v622/">V622</a> [CWE-478] Consider inspecting the 'switch' statement. It's possible that the first 'case' operator is missing. SystemZAsmParser.cpp 652<br/>
<br/>
В начале присутствует очень подозрительный оператор <i>break</i>. Не забыли ли здесь написать что-то ещё?<br/>
<br/>
<b>Фрагмент N12: Проверка указателя после разыменования</b><br/>
<br/>
<pre><code class="cpp">InlineCost AMDGPUInliner::getInlineCost(CallSite CS) {
  Function *Callee = CS.getCalledFunction();
  Function *Caller = CS.getCaller();
  TargetTransformInfo &amp;TTI = TTIWP->getTTI(*Callee);

  if (!Callee || Callee->isDeclaration())
    return llvm::InlineCost::getNever("undefined callee");
  ....
}</code></pre><br/>
Предупреждение PVS-Studio: <a href="https://www.viva64.com/ru/w/v595/">V595</a> [CWE-476] The 'Callee' pointer was utilized before it was verified against nullptr. Check lines: 172, 174. AMDGPUInline.cpp 172<br/>
<br/>
Указатель <i>Callee</i> в начале разыменовывается в момент вызова функции <i>getTTI</i>.<br/>
<br/>
А затем оказывается, что этот указатель следует проверять на равенство <i>nullptr</i>:<br/>
<br/>
<pre><code class="cpp">if (!Callee || Callee->isDeclaration())</code></pre><br/>
Но уже поздно…<br/>
<br/>
<b>Фрагмент N13 — N...: Проверка указателя после разыменования</b><br/>
<br/>
Ситуация, рассмотренная в предыдущем фрагменте кода не уникальна. Она встречается здесь:<br/>
<br/>
<pre><code class="cpp">static Value *optimizeDoubleFP(CallInst *CI, IRBuilder&lt;> &amp;B,
                               bool isBinary, bool isPrecise = false) {
  ....
  Function *CalleeFn = CI->getCalledFunction();
  StringRef CalleeNm = CalleeFn->getName();                 // &lt;=
  AttributeList CalleeAt = CalleeFn->getAttributes();
  if (CalleeFn &amp;&amp; !CalleeFn->isIntrinsic()) {               // &lt;=
  ....
}</code></pre><br/>
Предупреждение PVS-Studio: V595 [CWE-476] The 'CalleeFn' pointer was utilized before it was verified against nullptr. Check lines: 1079, 1081. SimplifyLibCalls.cpp 1079<br/>
<br/>
И здесь:<br/>
<br/>
<pre><code class="cpp">void Sema::InstantiateAttrs(const MultiLevelTemplateArgumentList &amp;TemplateArgs,
                            const Decl *Tmpl, Decl *New,
                            LateInstantiatedAttrVec *LateAttrs,
                            LocalInstantiationScope *OuterMostScope) {
  ....
  NamedDecl *ND = dyn_cast&lt;NamedDecl>(New);
  CXXRecordDecl *ThisContext =
    dyn_cast_or_null&lt;CXXRecordDecl>(ND->getDeclContext());         // &lt;=
  CXXThisScopeRAII ThisScope(*this, ThisContext, Qualifiers(),
                             ND &amp;&amp; ND->isCXXInstanceMember());     // &lt;=
  ....
}</code></pre><br/>
Предупреждение PVS-Studio: V595 [CWE-476] The 'ND' pointer was utilized before it was verified against nullptr. Check lines: 532, 534. SemaTemplateInstantiateDecl.cpp 532<br/>
<br/>
И здесь:<br/>
<br/>
<ul>
<li>V595 [CWE-476] The 'U' pointer was utilized before it was verified against nullptr. Check lines: 404, 407. DWARFFormValue.cpp 404</li>
<li>V595 [CWE-476] The 'ND' pointer was utilized before it was verified against nullptr. Check lines: 2149, 2151. SemaTemplateInstantiate.cpp 2149</li>
</ul><br/>
А дальше мне стало неинтересно изучать предупреждения с номером V595. Так что я не знаю, есть ли ещё подобные ошибки, помимо перечисленных здесь. Скорее всего есть.<br/>
<br/>
<b>Фрагмент N17, N18: Подозрительный сдвиг</b><br/>
<br/>
<pre><code class="cpp">static inline bool processLogicalImmediate(uint64_t Imm, unsigned RegSize,
                                           uint64_t &amp;Encoding) {
  ....
  unsigned Size = RegSize;
  ....
  uint64_t NImms = ~(Size-1) &lt;&lt; 1;
  ....
}</code></pre><br/>
Предупреждение PVS-Studio: <a href="https://www.viva64.com/ru/w/v629/">V629</a> [CWE-190] Consider inspecting the '~(Size — 1) &lt;&lt; 1' expression. Bit shifting of the 32-bit value with a subsequent expansion to the 64-bit type. AArch64AddressingModes.h 260<br/>
<br/>
Возможно, это не ошибка, и код работает именно так, как и задумано. Но это явно очень подозрительное место, и его нужно проверить.<br/>
<br/>
Допустим, переменная <i>Size</i> равна 16, и тогда автор кода планировал получить в переменной <i>NImms</i> значение:<br/>
<br/>
1111111111111111111111111111111111111111111111111111111111100000<br/>
<br/>
Однако, на самом деле, получится значение:<br/>
<br/>
0000000000000000000000000000000011111111111111111111111111100000<br/>
<br/>
Дело в том, что все вычисления происходят с использованием 32-битного типа unsigned. И только затем, этот 32-битный беззнаковый тип будет неявно расширен до <i>uint64_t</i>. При этом старшие биты окажутся нулевыми.<br/>
<br/>
Исправить ситуацию можно так:<br/>
<br/>
<pre><code class="cpp">uint64_t NImms = ~static_cast&lt;uint64_t>(Size-1) &lt;&lt; 1;</code></pre><br/>
Аналогичная ситуация: V629 [CWE-190] Consider inspecting the 'Immr &lt;&lt; 6' expression. Bit shifting of the 32-bit value with a subsequent expansion to the 64-bit type. AArch64AddressingModes.h 269<br/>
<br/>
<b>Фрагмент N19: Пропущено ключевое слово </b><b><i>else</i></b><b>?</b><br/>
<br/>
<pre><code class="cpp">void AMDGPUAsmParser::cvtDPP(MCInst &amp;Inst, const OperandVector &amp;Operands) {
  ....
  if (Op.isReg() &amp;&amp; Op.Reg.RegNo == AMDGPU::VCC) {
    // VOP2b (v_add_u32, v_sub_u32 ...) dpp use "vcc" token.
    // Skip it.
    continue;
  } if (isRegOrImmWithInputMods(Desc, Inst.getNumOperands())) {    // &lt;=
    Op.addRegWithFPInputModsOperands(Inst, 2);
  } else if (Op.isDPPCtrl()) {
    Op.addImmOperands(Inst, 1);
  } else if (Op.isImm()) {
    // Handle optional arguments
    OptionalIdx[Op.getImmTy()] = I;
  } else {
    llvm_unreachable("Invalid operand type");
  }
  ....
}</code></pre><br/>
Предупреждение PVS-Studio: <a href="https://www.viva64.com/ru/w/v646/">V646</a> [CWE-670] Consider inspecting the application's logic. It's possible that 'else' keyword is missing. AMDGPUAsmParser.cpp 5655<br/>
<br/>
Ошибки здесь нет. Так как then-блок первого <i>if</i> оканчивается на <i>continue</i>, то не важно, есть ключевое слово <i>else </i> или нет. В любом случае код будет работать одинаково. Тем не менее, пропущенный <i>else </i> делает код более непонятным и опасным. Если в дальнейшем <i>continue </i> исчезнет, то код начнёт работать совсем по-другому. На мой взгляд, лучше добавить <i>else</i>.<br/>
<br/>
<b>Фрагмент N20: Четыре однотипных опечатки</b><br/>
<br/>
<pre><code class="cpp">LLVM_DUMP_METHOD void Symbol::dump(raw_ostream &amp;OS) const {
  std::string Result;
  if (isUndefined())
    Result += "(undef) ";
  if (isWeakDefined())
    Result += "(weak-def) ";
  if (isWeakReferenced())
    Result += "(weak-ref) ";
  if (isThreadLocalValue())
    Result += "(tlv) ";
  switch (Kind) {
  case SymbolKind::GlobalSymbol:
    Result + Name.str();                        // &lt;=
    break;
  case SymbolKind::ObjectiveCClass:
    Result + "(ObjC Class) " + Name.str();      // &lt;=
    break;
  case SymbolKind::ObjectiveCClassEHType:
    Result + "(ObjC Class EH) " + Name.str();   // &lt;=
    break;
  case SymbolKind::ObjectiveCInstanceVariable:
    Result + "(ObjC IVar) " + Name.str();       // &lt;=
    break;
  }
  OS &lt;&lt; Result;
}</code></pre><br/>
Предупреждения PVS-Studio:<br/>
<br/>
<ul>
<li>V655 [CWE-480] The strings were concatenated but are not utilized. Consider inspecting the 'Result + Name.str()' expression. Symbol.cpp 32</li>
<li>V655 [CWE-480] The strings were concatenated but are not utilized. Consider inspecting the 'Result + "(ObjC Class) " + Name.str()' expression. Symbol.cpp 35</li>
<li>V655 [CWE-480] The strings were concatenated but are not utilized. Consider inspecting the 'Result + "(ObjC Class EH) " + Name.str()' expression. Symbol.cpp 38</li>
<li>V655 [CWE-480] The strings were concatenated but are not utilized. Consider inspecting the 'Result + "(ObjC IVar) " + Name.str()' expression. Symbol.cpp 41</li>
</ul><br/>
Случайно вместо оператора += используется оператор +. В результате получаются конструкции, лишённые смысла.<br/>
<br/>
<b>Фрагмент N21: Неопределённое поведение</b><br/>
<br/>
<pre><code class="cpp">static void getReqFeatures(std::map&lt;StringRef, int> &amp;FeaturesMap,
                           const std::vector&lt;Record *> &amp;ReqFeatures) {
  for (auto &amp;R : ReqFeatures) {
    StringRef AsmCondString = R->getValueAsString("AssemblerCondString");

    SmallVector&lt;StringRef, 4> Ops;
    SplitString(AsmCondString, Ops, ",");
    assert(!Ops.empty() &amp;&amp; "AssemblerCondString cannot be empty");

    for (auto &amp;Op : Ops) {
      assert(!Op.empty() &amp;&amp; "Empty operator");
      if (FeaturesMap.find(Op) == FeaturesMap.end())
        FeaturesMap[Op] = FeaturesMap.size();
    }
  }
}</code></pre><br/>
Попробуйте самостоятельно найти опасный код. А это картинка для отвлечения внимания, чтобы сразу не посмотреть на ответ:<br/>
<br/>
<p></p><div style="text-align:center;"><img src="/img/image-loader.svg" alt="Хммм..." data-src="https://habrastorage.org/getpro/habr/post_images/d5d/183/d4e/d5d183d4e2d3107bc512e52d893fda25.png"/></div><br/>
<br/>
Предупреждение PVS-Studio: <a href="https://www.viva64.com/ru/w/v708/">V708</a> [CWE-758] Dangerous construction is used: 'FeaturesMap[Op] = FeaturesMap.size()', where 'FeaturesMap' is of 'map' class. This may lead to undefined behavior. RISCVCompressInstEmitter.cpp 490<br/>
<br/>
Проблемная строчка:<br/>
<br/>
<pre><code class="cpp">FeaturesMap[Op] = FeaturesMap.size();</code></pre><br/>
Если элемент <i>Op</i> не найден, то создаётся новый элемент в карте и туда записывается количество элементов в этой карте. Вот только неизвестно, будет вызвана функция <i>size</i> до или после добавления нового элемента.<br/>
<br/>
<b>Фрагмент N22-N24: Повторные присваивания</b><br/>
<br/>
<pre><code class="cpp">Error MachOObjectFile::checkSymbolTable() const {
  ....
  } else {
    MachO::nlist STE = getSymbolTableEntry(SymDRI);
    NType = STE.n_type;                              // &lt;=
    NType = STE.n_type;                              // &lt;=
    NSect = STE.n_sect;
    NDesc = STE.n_desc;
    NStrx = STE.n_strx;
    NValue = STE.n_value;
  }
  ....
}</code></pre><br/>
Предупреждение PVS-Studio: <a href="https://www.viva64.com/ru/w/v519/">V519</a> [CWE-563] The 'NType' variable is assigned values twice successively. Perhaps this is a mistake. Check lines: 1663, 1664. MachOObjectFile.cpp 1664<br/>
<br/>
Думаю, настоящей ошибки здесь нет. Просто лишнее повторяющееся присваивание. Но всё равно ляп.<br/>
<br/>
Аналогично:<br/>
<br/>
<ul>
<li>V519 [CWE-563] The 'B.NDesc' variable is assigned values twice successively. Perhaps this is a mistake. Check lines: 1488, 1489. llvm-nm.cpp 1489</li>
<li>V519 [CWE-563] The variable is assigned values twice successively. Perhaps this is a mistake. Check lines: 59, 61. coff2yaml.cpp 61</li>
</ul><br/>
<b>Фрагмент N25-N27: Ещё повторные присваивания</b><br/>
<br/>
Теперь рассмотрим немного другой вариант повторного присваивания.<br/>
<br/>
<pre><code class="cpp">bool Vectorizer::vectorizeLoadChain(
    ArrayRef&lt;Instruction *> Chain,
    SmallPtrSet&lt;Instruction *, 16> *InstructionsProcessed) {
  ....
  unsigned Alignment = getAlignment(L0);
  ....
  unsigned NewAlign = getOrEnforceKnownAlignment(L0->getPointerOperand(),
                                                 StackAdjustedAlignment,
                                                 DL, L0, nullptr, &amp;DT);
  if (NewAlign != 0)
    Alignment = NewAlign;
  Alignment = NewAlign;
  ....
}</code></pre><br/>
Предупреждение PVS-Studio: V519 [CWE-563] The 'Alignment' variable is assigned values twice successively. Perhaps this is a mistake. Check lines: 1158, 1160. LoadStoreVectorizer.cpp 1160<br/>
<br/>
Это очень странный код, который по всей видимости содержит логическую ошибку. В начале, переменной <i>Alignment</i> присваивается значение в зависимости от условия. А затем вновь происходит присваивание, но теперь уже без всякой проверки.<br/>
<br/>
Аналогичные ситуации можно увидеть здесь:<br/>
<br/>
<ul>
<li>V519 [CWE-563] The 'Effects' variable is assigned values twice successively. Perhaps this is a mistake. Check lines: 152, 165. WebAssemblyRegStackify.cpp 165</li>
<li>V519 [CWE-563] The 'ExpectNoDerefChunk' variable is assigned values twice successively. Perhaps this is a mistake. Check lines: 4970, 4973. SemaType.cpp 4973</li>
</ul><br/>
<b>Фрагмент N28: Всегда истинное условие</b><br/>
<br/>
<pre><code class="cpp">static int readPrefixes(struct InternalInstruction* insn) {
  ....
  uint8_t byte = 0;
  uint8_t nextByte;
  ....
  if (byte == 0xf3 &amp;&amp; (nextByte == 0x88 || nextByte == 0x89 ||
                       nextByte == 0xc6 || nextByte == 0xc7)) {
    insn->xAcquireRelease = true;
    if (nextByte != 0x90) // PAUSE instruction support             // &lt;=
      break;
  }
  ....
}</code></pre><br/>
Предупреждение PVS-Studio: <a href="https://www.viva64.com/ru/w/v547/">V547</a> [CWE-571] Expression 'nextByte != 0x90' is always true. X86DisassemblerDecoder.cpp 379<br/>
<br/>
Проверка не имеет смысла. Переменная <i>nextByte</i> всегда не равна значению <i>0x90</i>, что вытекает из предыдущей проверки. Это какая-то логическая ошибка.<br/>
<br/>
<b>Фрагмент N29 — N...: Всегда истинные/ложные условия</b><br/>
<br/>
Анализатор выдаёт много предупреждений о том, что всё условие (<a href="https://www.viva64.com/ru/w/v547/">V547</a>) или его часть (<a href="https://www.viva64.com/ru/w/v560/">V560</a>) всегда истинно или ложно. Часто это не настоящие ошибки, а просто неаккуратный код, результат развертывания макросов и тому подобное. Тем не менее, есть смысл посмотреть все эти предупреждения, так как время от времени встречаются настоящие логические ошибки. Например, подозрителен вот этот участок кода:<br/>
<br/>
<pre><code class="cpp">static DecodeStatus DecodeGPRPairRegisterClass(MCInst &amp;Inst, unsigned RegNo,
                                   uint64_t Address, const void *Decoder) {
  DecodeStatus S = MCDisassembler::Success;

  if (RegNo > 13)
    return MCDisassembler::Fail;

  if ((RegNo &amp; 1) || RegNo == 0xe)
     S = MCDisassembler::SoftFail;
  ....
}</code></pre><br/>
Предупреждение PVS-Studio: <a href="https://www.viva64.com/ru/w/v560/">V560</a> [CWE-570] A part of conditional expression is always false: RegNo == 0xe. ARMDisassembler.cpp 939<br/>
<br/>
Константа 0xE это значение 14 в десятичной системе. Проверка <i>RegNo == 0xe</i> не имеет смысла, так как если <i>RegNo > 13</i>, то функция завершит своё выполнение.<br/>
<br/>
Было множество других предупреждений с идентификатором V547 и V560, но, как и в случае с <a href="https://www.viva64.com/ru/w/v595/">V595</a>, изучать эти предупреждения мне было неинтересно. Было и так понятно, что мне хватит материала для написания статьи :). Поэтому неизвестно, сколько всего можно выявить ошибок этого типа в LLVM с помощью PVS-Studio.<br/>
<br/>
Приведу пример, почему изучать эти срабатывания скучно. Анализатор совершенно прав, выдавая предупреждение на следующий код. Но это и не ошибка.<br/>
<br/>
<pre><code class="cpp">bool UnwrappedLineParser::parseBracedList(bool ContinueOnSemicolons,
                                          tok::TokenKind ClosingBraceKind) {
  bool HasError = false;
  ....
  HasError = true;
  if (!ContinueOnSemicolons)
    return !HasError;
  ....
}</code></pre><br/>
Предупреждение PVS-Studio: V547 [CWE-570] Expression '!HasError' is always false. UnwrappedLineParser.cpp 1635<br/>
<br/>
<b>Фрагмент N30: Подозрительный return</b><br/>
<br/>
<pre><code class="cpp">static bool
isImplicitlyDef(MachineRegisterInfo &amp;MRI, unsigned Reg) {
  for (MachineRegisterInfo::def_instr_iterator It = MRI.def_instr_begin(Reg),
      E = MRI.def_instr_end(); It != E; ++It) {
    return (*It).isImplicitDef();
  }
  ....
}</code></pre><br/>
Предупреждение PVS-Studio: <a href="https://www.viva64.com/ru/w/v612/">V612</a> [CWE-670] An unconditional 'return' within a loop. R600OptimizeVectorRegisters.cpp 63<br/>
<br/>
Это или ошибка, или специфический приём, который призван что-то пояснить программистам, читающим код. Мне такая конструкция ничего не поясняет и выглядит очень подозрительной. Лучше так не писать :).<br/>
<br/>
Устали? Тогда время заварить чай или кофе.<br/>
<br/>
<p></p><div style="text-align:center;"><img src="/img/image-loader.svg" alt="Кофе" data-src="https://habrastorage.org/getpro/habr/post_images/8a2/f86/58f/8a2f8658fdacb0dde918807666d1cd39.png"/></div><br/>
<br/>
<h2>Дефекты, выявленные новыми диагностиками</h2><br/>
Думаю, 30 срабатываний старых диагностик достаточно. Давайте теперь посмотрим, что интересного можно находить новыми диагностиками, которые появились в анализаторе уже после <a href="https://www.viva64.com/ru/b/0446/">предыдущей</a> проверки. Всего за это время в C++ анализаторе добавилось 66 диагностик общего назначения.<br/>
<br/>
<b>Фрагмент N31: Недостижимый код</b><br/>
<br/>
<pre><code class="cpp">Error CtorDtorRunner::run() {
  ....
  if (auto CtorDtorMap =
          ES.lookup(JITDylibSearchList({{&amp;JD, true}}), std::move(Names),
                    NoDependenciesToRegister, true))
  {
    ....
    return Error::success();
  } else
    return CtorDtorMap.takeError();

  CtorDtorsByPriority.clear();

  return Error::success();
}</code></pre><br/>
Предупреждение PVS-Studio: <a href="https://www.viva64.com/ru/w/v779/">V779</a> [CWE-561] Unreachable code detected. It is possible that an error is present. ExecutionUtils.cpp 146<br/>
<br/>
Как видите, обе ветки оператора <i>if</i> заканчиваются вызовом оператора <i>return</i>. Соответственно, контейнер <i>CtorDtorsByPriority</i> никогда не будет очищен.<br/>
<br/>
<b>Фрагмент N32: Недостижимый код</b><br/>
<br/>
<pre><code class="cpp">bool LLParser::ParseSummaryEntry() {
  ....
  switch (Lex.getKind()) {
  case lltok::kw_gv:
    return ParseGVEntry(SummaryID);
  case lltok::kw_module:
    return ParseModuleEntry(SummaryID);
  case lltok::kw_typeid:
    return ParseTypeIdEntry(SummaryID);                        // &lt;=
    break;                                                     // &lt;=
  default:
    return Error(Lex.getLoc(), "unexpected summary kind");
  }
  Lex.setIgnoreColonInIdentifiers(false);                      // &lt;=
  return false;
}</code></pre><br/>
Предупреждение PVS-Studio: V779 [CWE-561] Unreachable code detected. It is possible that an error is present. LLParser.cpp 835<br/>
<br/>
Интересная ситуация. Давайте рассмотрим в начале вот это место:<br/>
<br/>
<pre><code class="cpp">return ParseTypeIdEntry(SummaryID);
break;</code></pre><br/>
На первый взгляд кажется, что ошибки здесь нет. Похоже, что оператор <i>break</i> здесь лишний, и его можно просто удалить. Однако, не всё так просто.<br/>
<br/>
Анализатор выдаёт предупреждение на строчки:<br/>
<br/>
<pre><code class="cpp">Lex.setIgnoreColonInIdentifiers(false);
return false;</code></pre><br/>
И действительно, этот код недостижим. Все случаи в <i>switch</i> заканчиваются вызовом оператором <i>return</i>. И теперь бессмысленный одинокий <i>break</i> не выглядит таким безобидным! Быть может одна из веток должна заканчиваться на <i>break</i>, а не на <i>return</i>?<br/>
<br/>
<b>Фрагмент N33: Случайное обнуление старших бит</b><br/>
<br/>
<pre><code class="cpp">unsigned getStubAlignment() override {
  if (Arch == Triple::systemz)
    return 8;
  else
    return 1;
}

Expected&lt;unsigned>
RuntimeDyldImpl::emitSection(const ObjectFile &amp;Obj,
                             const SectionRef &amp;Section,
                             bool IsCode) {
  ....
  uint64_t DataSize = Section.getSize();
  ....
  if (StubBufSize > 0)
    DataSize &amp;= ~(getStubAlignment() - 1);
  ....
}</code></pre><br/>
Предупреждение PVS-Studio: <a href="https://www.viva64.com/ru/w/v784/">V784</a> The size of the bit mask is less than the size of the first operand. This will cause the loss of higher bits. RuntimeDyld.cpp 815<br/>
<br/>
Обратите внимание, что функция <i>getStubAlignment</i> возвращает тип <i>unsigned</i>. Вычислим значение выражения, если предположить, что функция вернёт значение 8:<br/>
<br/>
~(getStubAlignment() — 1)<br/>
<br/>
~(8u-1)<br/>
<br/>
0xFFFFFFF8‬u<br/>
<br/>
Теперь обратите внимание, что переменная <i>DataSize</i> имеет 64-битный беззнаковый тип. Получается, что при выполнении операции DataSize &amp; 0xFFFFFFF8‬u все тридцать два старших бита будут обнулены. Скорее всего, это не то, что хотел программист. Подозреваю, что он хотел вычислить: DataSize &amp; 0xFFFFFFFFFFFFFFF8‬u.<br/>
<br/>
Чтобы исправить ошибку, следует написать так:<br/>
<br/>
<pre><code class="cpp">DataSize &amp;= ~(static_cast&lt;uint64_t>(getStubAlignment()) - 1);</code></pre><br/>
Или так:<br/>
<br/>
<pre><code class="cpp">DataSize &amp;= ~(getStubAlignment() - 1ULL);</code></pre><br/>
<b>Фрагмент N34: Неудачное явное приведение типа</b><br/>
<br/>
<pre><code class="cpp">template &lt;typename T>
void scaleShuffleMask(int Scale, ArrayRef&lt;T> Mask,
                      SmallVectorImpl&lt;T> &amp;ScaledMask) {
  assert(0 &lt; Scale &amp;&amp; "Unexpected scaling factor");
  int NumElts = Mask.size();
  ScaledMask.assign(static_cast&lt;size_t>(NumElts * Scale), -1);
  ....
}</code></pre><br/>
Предупреждение PVS-Studio: <a href="https://www.viva64.com/ru/w/v1028/">V1028</a> [CWE-190] Possible overflow. Consider casting operands of the 'NumElts * Scale' operator to the 'size_t' type, not the result. X86ISelLowering.h 1577<br/>
<br/>
Явное приведение типа используется для того, чтобы не возникло переполнение при перемножении переменных типа <i>int</i>. Однако, здесь явное приведение типа не защищает от переполнения. В начале переменные будут перемножены, и только потом 32-битный результат умножения будет расширен до типа <a href="https://www.viva64.com/ru/t/0044/"><i>size_t</i></a>.<br/>
<br/>
<b>Фрагмент N35: Неудачный Copy-Paste</b><br/>
<br/>
<pre><code class="cpp">Instruction *InstCombiner::visitFCmpInst(FCmpInst &amp;I) {
  ....
  if (!match(Op0, m_PosZeroFP()) &amp;&amp; isKnownNeverNaN(Op0, &amp;TLI)) {
    I.setOperand(0, ConstantFP::getNullValue(Op0->getType()));
    return &amp;I;
  }
  if (!match(Op1, m_PosZeroFP()) &amp;&amp; isKnownNeverNaN(Op1, &amp;TLI)) {
    I.setOperand(1, ConstantFP::getNullValue(Op0->getType()));        // &lt;=
    return &amp;I;
  }
  ....
}</code></pre><br/>
<a href="https://www.viva64.com/ru/w/v778/">V778</a> [CWE-682] Two similar code fragments were found. Perhaps, this is a typo and 'Op1' variable should be used instead of 'Op0'. InstCombineCompares.cpp 5507<br/>
<br/>
Эта новая интересная диагностика выявляет ситуации, когда фрагмент кода был скопирован, и в нём начали менять некоторые имена, но в одном месте не поправили.<br/>
<br/>
Обратите внимание, что во втором блоке меняли <i>Op0</i> на <i>Op1</i>. Но в одном месте не поправили. Скорее всего, должно было быть написано так:<br/>
<br/>
<pre><code class="cpp">if (!match(Op1, m_PosZeroFP()) &amp;&amp; isKnownNeverNaN(Op1, &amp;TLI)) {
  I.setOperand(1, ConstantFP::getNullValue(Op1->getType()));
  return &amp;I;
}</code></pre><br/>
<b>Фрагмент N36: Путаница в переменных</b><br/>
<br/>
<pre><code class="cpp">struct Status {
  unsigned Mask;
  unsigned Mode;

  Status() : Mask(0), Mode(0){};

  Status(unsigned Mask, unsigned Mode) : Mask(Mask), Mode(Mode) {
    Mode &amp;= Mask;
  };
  ....
};</code></pre><br/>
Предупреждение PVS-Studio: <a href="https://www.viva64.com/ru/w/v1001/">V1001</a> [CWE-563] The 'Mode' variable is assigned but is not used by the end of the function. SIModeRegister.cpp 48<br/>
<br/>
Очень опасно давать аргументам функций те же самые имена, что и членам класса. Очень легко запутаться. Перед нами как раз такой случай. Это выражение не имеет смысла:<br/>
<br/>
<pre><code class="cpp">Mode &amp;= Mask;</code></pre><br/>
Меняется аргумент функции. И всё. Этот аргумент больше никак не используется. Скорее всего, надо было написать так:<br/>
<br/>
<pre><code class="cpp">Status(unsigned Mask, unsigned Mode) : Mask(Mask), Mode(Mode) {
  this->Mode &amp;= Mask;
};</code></pre><br/>
<b>Фрагмент N37: Путаница в переменных</b><br/>
<br/>
<pre><code class="cpp">class SectionBase {
  ....
  uint64_t Size = 0;
  ....
};

class SymbolTableSection : public SectionBase {
  ....
};

void SymbolTableSection::addSymbol(Twine Name, uint8_t Bind, uint8_t Type,
                                   SectionBase *DefinedIn, uint64_t Value,
                                   uint8_t Visibility, uint16_t Shndx,
                                   uint64_t Size) {
  ....
  Sym.Value = Value;
  Sym.Visibility = Visibility;
  Sym.Size = Size;
  Sym.Index = Symbols.size();
  Symbols.emplace_back(llvm::make_unique&lt;Symbol>(Sym));
  Size += this->EntrySize;
}</code></pre><br/>
Предупреждение PVS-Studio: V1001 [CWE-563] The 'Size' variable is assigned but is not used by the end of the function. Object.cpp 424<br/>
<br/>
Ситуация аналогична предыдущей. Должно быть написано:<br/>
<br/>
<pre><code class="cpp">this->Size += this->EntrySize;</code></pre><br/>
<b>Фрагмент N38-N47: Указатель забыли проверить</b><br/>
<br/>
Ранее мы рассматривали примеры срабатывания диагностики <a href="https://www.viva64.com/ru/w/v595/">V595</a>. Её суть в том, что указатель в начале разыменовывается, а только потом проверяется. Молодая диагностика <a href="https://www.viva64.com/ru/w/v1004/">V1004</a> является обратной ей по смыслу, но также обнаруживает очень много ошибок. Она выявляет ситуации, когда указатель в начале проверяли, а затем забыли это сделать. Рассмотрим такие случаи, найденные внутри LLVM.<br/>
<br/>
<pre><code class="cpp">int getGEPCost(Type *PointeeType, const Value *Ptr,
               ArrayRef&lt;const Value *> Operands) {
  ....
  if (Ptr != nullptr) {                                            // &lt;=
    assert(....);
    BaseGV = dyn_cast&lt;GlobalValue>(Ptr->stripPointerCasts());
  }
  bool HasBaseReg = (BaseGV == nullptr);

  auto PtrSizeBits = DL.getPointerTypeSizeInBits(Ptr->getType());  // &lt;=
  ....
}</code></pre><br/>
Предупреждение PVS-Studio: V1004 [CWE-476] The 'Ptr' pointer was used unsafely after it was verified against nullptr. Check lines: 729, 738. TargetTransformInfoImpl.h 738<br/>
<br/>
Переменная <i>Ptr </i> может быть равна <i>nullptr</i>, о чём свидетельствует проверка:<br/>
<br/>
<pre><code class="cpp">if (Ptr != nullptr)</code></pre><br/>
Однако, ниже этот указатель разыменовывается уже без предварительной проверки:<br/>
<br/>
<pre><code class="cpp">auto PtrSizeBits = DL.getPointerTypeSizeInBits(Ptr->getType());</code></pre><br/>
Рассмотрим другой аналогичный случай.<br/>
<br/>
<pre><code class="cpp">llvm::DISubprogram *CGDebugInfo::getFunctionFwdDeclOrStub(GlobalDecl GD,
                                                          bool Stub) {
  ....
  auto *FD = dyn_cast&lt;FunctionDecl>(GD.getDecl());
  SmallVector&lt;QualType, 16> ArgTypes;
  if (FD)                                                                // &lt;=
    for (const ParmVarDecl *Parm : FD->parameters())
      ArgTypes.push_back(Parm->getType());
  CallingConv CC = FD->getType()->castAs&lt;FunctionType>()->getCallConv(); // &lt;=
  ....
}</code></pre><br/>
Предупреждение PVS-Studio: V1004 [CWE-476] The 'FD' pointer was used unsafely after it was verified against nullptr. Check lines: 3228, 3231. CGDebugInfo.cpp 3231<br/>
<br/>
Обратите внимание на указатель <i>FD</i>. Уверен, проблема хорошо видна, и специальных пояснений не требуется.<br/>
<br/>
И ещё:<br/>
<br/>
<pre><code class="cpp">static void computePolynomialFromPointer(Value &amp;Ptr, Polynomial &amp;Result,
                                         Value *&amp;BasePtr,
                                         const DataLayout &amp;DL) {
  PointerType *PtrTy = dyn_cast&lt;PointerType>(Ptr.getType());
  if (!PtrTy) {                                                   // &lt;=
    Result = Polynomial();
    BasePtr = nullptr;
  }
  unsigned PointerBits =
      DL.getIndexSizeInBits(PtrTy->getPointerAddressSpace());     // &lt;=
  ....
}</code></pre><br/>
Предупреждение PVS-Studio: V1004 [CWE-476] The 'PtrTy' pointer was used unsafely after it was verified against nullptr. Check lines: 960, 965. InterleavedLoadCombinePass.cpp 965<br/>
<br/>
Как защититься от таких ошибок? Будьте внимательней на Code-Review и используйте для регулярной проверки кода статический анализатор PVS-Studio.<br/>
<br/>
Приводить другие фрагменты кода с ошибками данного вида смысла нет. Оставлю в статье только список предупреждений:<br/>
<br/>
<ul>
<li>V1004 [CWE-476] The 'Expr' pointer was used unsafely after it was verified against nullptr. Check lines: 1049, 1078. DebugInfoMetadata.cpp 1078</li>
<li>V1004 [CWE-476] The 'PI' pointer was used unsafely after it was verified against nullptr. Check lines: 733, 753. LegacyPassManager.cpp 753</li>
<li>V1004 [CWE-476] The 'StatepointCall' pointer was used unsafely after it was verified against nullptr. Check lines: 4371, 4379. Verifier.cpp 4379</li>
<li>V1004 [CWE-476] The 'RV' pointer was used unsafely after it was verified against nullptr. Check lines: 2263, 2268. TGParser.cpp 2268</li>
<li>V1004 [CWE-476] The 'CalleeFn' pointer was used unsafely after it was verified against nullptr. Check lines: 1081, 1096. SimplifyLibCalls.cpp 1096</li>
<li>V1004 [CWE-476] The 'TC' pointer was used unsafely after it was verified against nullptr. Check lines: 1819, 1824. Driver.cpp 1824</li>
</ul><br/>
<b>Фрагмент N48-N60: Не критично, но дефект (возможна утечка памяти)</b><br/>
<br/>
<pre><code class="cpp">std::unique_ptr&lt;IRMutator> createISelMutator() {
  ....
  std::vector&lt;std::unique_ptr&lt;IRMutationStrategy>> Strategies;
  Strategies.emplace_back(
      new InjectorIRStrategy(InjectorIRStrategy::getDefaultOps()));
  ....
}</code></pre><br/>
Предупреждение PVS-Studio: <a href="https://www.viva64.com/ru/w/v1023/">V1023</a> [CWE-460] A pointer without owner is added to the 'Strategies' container by the 'emplace_back' method. A memory leak will occur in case of an exception. llvm-isel-fuzzer.cpp 58<br/>
<br/>
Для добавлении элемента в конец контейнера типа <i>std::vector&lt;std::unique_ptr&lt;X>></i> нельзя просто написать <i>xxx.push_back(new X)</i>, так как нет неявного преобразования из <i>X*</i> в <i>std::unique_ptr&lt;X></i>.<br/>
<br/>
Распространенным решением является написание <i>xxx.emplace_back(new X)</i>, так как он компилируется: метод <i>emplace_back</i> конструирует элемент непосредственно из аргументов и поэтому может использовать явные конструкторы.<br/>
<br/>
Это небезопасно. Если вектор полон, то происходит перевыделение памяти. Операция перевыделения памяти может закончиться неудачей, в результате чего будет сгенерировано исключение <i>std::bad_alloc</i>. В этом случае указатель будет потерян, и созданный объект никогда не будет удален.<br/>
<br/>
Безопасным решением является создание <i>unique_ptr</i>, который будет владеть указателем до того, как вектор попытается перевыделить память:<br/>
<br/>
<pre><code class="cpp">xxx.push_back(std::unique_ptr&lt;X>(new X))</code></pre><br/>
Начиная с C++14, можно использовать 'std::make_unique':<br/>
<br/>
<pre><code class="cpp">xxx.push_back(std::make_unique&lt;X>())</code></pre><br/>
Данный вид дефекта не критичен для LLVM. Если не удастся выделить память, то работа компилятора будет просто остановлена. Однако, для приложений с долгим <a href="https://ru.wikipedia.org/wiki/%D0%90%D0%BF%D1%82%D0%B0%D0%B9%D0%BC">аптаймом</a>, которые не могут просто так завершаться, если не удалось выделить память, это может быть настоящей неприятной ошибкой.<br/>
<br/>
Итак, хотя данный код не представляет практической опасности для LLVM, я посчитал полезным рассказать о данном паттерне ошибок и что анализатор PVS-Studio научился его выявлять.<br/>
<br/>
Другие предупреждения данного типа:<br/>
<br/>
<ul>
<li>V1023 [CWE-460] A pointer without owner is added to the 'Passes' container by the 'emplace_back' method. A memory leak will occur in case of an exception. PassManager.h 546</li>
<li>V1023 [CWE-460] A pointer without owner is added to the 'AAs' container by the 'emplace_back' method. A memory leak will occur in case of an exception. AliasAnalysis.h 324</li>
<li>V1023 [CWE-460] A pointer without owner is added to the 'Entries' container by the 'emplace_back' method. A memory leak will occur in case of an exception. DWARFDebugFrame.cpp 519</li>
<li>V1023 [CWE-460] A pointer without owner is added to the 'AllEdges' container by the 'emplace_back' method. A memory leak will occur in case of an exception. CFGMST.h 268</li>
<li>V1023 [CWE-460] A pointer without owner is added to the 'VMaps' container by the 'emplace_back' method. A memory leak will occur in case of an exception. SimpleLoopUnswitch.cpp 2012</li>
<li>V1023 [CWE-460] A pointer without owner is added to the 'Records' container by the 'emplace_back' method. A memory leak will occur in case of an exception. FDRLogBuilder.h 30</li>
<li>V1023 [CWE-460] A pointer without owner is added to the 'PendingSubmodules' container by the 'emplace_back' method. A memory leak will occur in case of an exception. ModuleMap.cpp 810</li>
<li>V1023 [CWE-460] A pointer without owner is added to the 'Objects' container by the 'emplace_back' method. A memory leak will occur in case of an exception. DebugMap.cpp 88</li>
<li>V1023 [CWE-460] A pointer without owner is added to the 'Strategies' container by the 'emplace_back' method. A memory leak will occur in case of an exception. llvm-isel-fuzzer.cpp 60</li>
<li>V1023 [CWE-460] A pointer without owner is added to the 'Modifiers' container by the 'emplace_back' method. A memory leak will occur in case of an exception. llvm-stress.cpp 685</li>
<li>V1023 [CWE-460] A pointer without owner is added to the 'Modifiers' container by the 'emplace_back' method. A memory leak will occur in case of an exception. llvm-stress.cpp 686</li>
<li>V1023 [CWE-460] A pointer without owner is added to the 'Modifiers' container by the 'emplace_back' method. A memory leak will occur in case of an exception. llvm-stress.cpp 688</li>
<li>V1023 [CWE-460] A pointer without owner is added to the 'Modifiers' container by the 'emplace_back' method. A memory leak will occur in case of an exception. llvm-stress.cpp 689</li>
<li>V1023 [CWE-460] A pointer without owner is added to the 'Modifiers' container by the 'emplace_back' method. A memory leak will occur in case of an exception. llvm-stress.cpp 690</li>
<li>V1023 [CWE-460] A pointer without owner is added to the 'Modifiers' container by the 'emplace_back' method. A memory leak will occur in case of an exception. llvm-stress.cpp 691</li>
<li>V1023 [CWE-460] A pointer without owner is added to the 'Modifiers' container by the 'emplace_back' method. A memory leak will occur in case of an exception. llvm-stress.cpp 692</li>
<li>V1023 [CWE-460] A pointer without owner is added to the 'Modifiers' container by the 'emplace_back' method. A memory leak will occur in case of an exception. llvm-stress.cpp 693</li>
<li>V1023 [CWE-460] A pointer without owner is added to the 'Modifiers' container by the 'emplace_back' method. A memory leak will occur in case of an exception. llvm-stress.cpp 694</li>
<li>V1023 [CWE-460] A pointer without owner is added to the 'Operands' container by the 'emplace_back' method. A memory leak will occur in case of an exception. GlobalISelEmitter.cpp 1911</li>
<li>V1023 [CWE-460] A pointer without owner is added to the 'Stash' container by the 'emplace_back' method. A memory leak will occur in case of an exception. GlobalISelEmitter.cpp 2100</li>
<li>V1023 [CWE-460] A pointer without owner is added to the 'Matchers' container by the 'emplace_back' method. A memory leak will occur in case of an exception. GlobalISelEmitter.cpp 2702</li>
</ul><br/>
<h2>Заключение</h2><br/>
Всего я выписал 60 предупреждений, после чего остановился. Есть ли другие дефекты, которые обнаруживает в LLVM анализатор PVS-Studio? Да, есть. Однако, когда я выписывал фрагменты кода для статьи, наступил поздний вечер, вернее, даже ночь, и я решил, что пора закругляться.<br/>
<br/>
Надеюсь, вам было интересно, и вы захотите попробовать анализатор PVS-Studio.<br/>
<br/>
Вы можете скачать анализатор и получить триальный ключ на <a href="https://www.viva64.com/ru/pvs-studio-download/">этой странице</a>.<br/>
<br/>
Самое главное, используйте статический анализ регулярно. <b>Разовые проверки</b>, выполняемыми нами с целью популяризации методологии статического анализа и PVS-Studio не являются нормальным сценарием.<br/>
<br/>
Удачи в улучшении качества и надёжности кода!<br/>
<br/>
<p><a href="https://habr.com/en/company/pvs-studio/blog/450002/"><img src="/img/image-loader.svg" align="left" data-src="https://habrastorage.org/getpro/habr/post_images/c78/30f/70c/c7830f70c5577c3d6704f254d7cad6a3.png"/></a></p><br/>
<br/>
Если хотите поделиться этой статьей с англоязычной аудиторией, то прошу использовать ссылку на перевод: Andrey Karpov. <a href="https://habr.com/en/company/pvs-studio/blog/450002/">Finding Bugs in LLVM 8 with PVS-Studio</a>.</div></div> <!----> <!----></div> <div class="tm-article-presenter__meta"><div class="tm-separated-list tm-article-presenter__meta-list"><span class="tm-separated-list__title">Теги:</span> <ul class="tm-separated-list__list"><li class="tm-separated-list__item"><a href="/ru/search/?target_type=posts&amp;order=relevance&amp;q=%5Bc%2B%2B%5D" class="tm-tags-list__link">c++</a></li><li class="tm-separated-list__item"><a href="/ru/search/?target_type=posts&amp;order=relevance&amp;q=%5Bclang%5D" class="tm-tags-list__link">clang</a></li><li class="tm-separated-list__item"><a href="/ru/search/?target_type=posts&amp;order=relevance&amp;q=%5Bllvm%5D" class="tm-tags-list__link">llvm</a></li><li class="tm-separated-list__item"><a href="/ru/search/?target_type=posts&amp;order=relevance&amp;q=%5Bcompiler%5D" class="tm-tags-list__link">compiler</a></li><li class="tm-separated-list__item"><a href="/ru/search/?target_type=posts&amp;order=relevance&amp;q=%5Bpvs-studio%5D" class="tm-tags-list__link">pvs-studio</a></li><li class="tm-separated-list__item"><a href="/ru/search/?target_type=posts&amp;order=relevance&amp;q=%5Bopen%20source%5D" class="tm-tags-list__link">open source</a></li><li class="tm-separated-list__item"><a href="/ru/search/?target_type=posts&amp;order=relevance&amp;q=%5Bdevops%5D" class="tm-tags-list__link">devops</a></li><li class="tm-separated-list__item"><a href="/ru/search/?target_type=posts&amp;order=relevance&amp;q=%5Bbugs%5D" class="tm-tags-list__link">bugs</a></li><li class="tm-separated-list__item"><a href="/ru/search/?target_type=posts&amp;order=relevance&amp;q=%5B%D0%B1%D0%B0%D0%B3%D0%B8%5D" class="tm-tags-list__link">баги</a></li><li class="tm-separated-list__item"><a href="/ru/search/?target_type=posts&amp;order=relevance&amp;q=%5B%D0%BA%D0%BE%D0%BC%D0%BF%D0%B8%D0%BB%D1%8F%D1%82%D0%BE%D1%80%D1%8B%5D" class="tm-tags-list__link">компиляторы</a></li><li class="tm-separated-list__item"><a href="/ru/search/?target_type=posts&amp;order=relevance&amp;q=%5B%D0%BA%D0%B0%D1%87%D0%B5%D1%81%D1%82%D0%B2%D0%BE%20%D0%BA%D0%BE%D0%B4%D0%B0%5D" class="tm-tags-list__link">качество кода</a></li><li class="tm-separated-list__item"><a href="/ru/search/?target_type=posts&amp;order=relevance&amp;q=%5B%D1%81%D1%82%D0%B0%D1%82%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B9%20%D0%B0%D0%BD%D0%B0%D0%BB%D0%B8%D0%B7%20%D0%BA%D0%BE%D0%B4%D0%B0%5D" class="tm-tags-list__link">статический анализ кода</a></li></ul></div> <div class="tm-separated-list tm-article-presenter__meta-list"><span class="tm-separated-list__title">Хабы:</span> <ul class="tm-separated-list__list"><li class="tm-separated-list__item"><a href="/ru/company/pvs-studio/blog/" class="tm-hubs-list__link router-link-active">
    Блог компании PVS-Studio
  </a></li><li class="tm-separated-list__item"><a href="/ru/hub/open_source/" class="tm-hubs-list__link">
    Open source
  </a></li><li class="tm-separated-list__item"><a href="/ru/hub/cpp/" class="tm-hubs-list__link">
    C++
  </a></li><li class="tm-separated-list__item"><a href="/ru/hub/compilers/" class="tm-hubs-list__link">
    Компиляторы
  </a></li><li class="tm-separated-list__item"><a href="/ru/hub/devops/" class="tm-hubs-list__link">
    DevOps
  </a></li></ul></div></div></article></div> <!----></div> <div class="tm-article-sticky-panel"><div class="tm-data-icons tm-article-sticky-panel__icons"><div class="tm-article-rating tm-data-icons__item"><div class="tm-votes-meter tm-article-rating__votes-switcher"><svg height="16" width="16" class="tm-svg-img tm-votes-meter__icon tm-votes-meter__icon_medium"><title>Всего голосов 54: ↑50 и ↓4</title> <use xlink:href="/img/megazord-v24.ce74655c.svg#counter-rating"></use></svg> <span title="Всего голосов 54: ↑50 и ↓4" class="tm-votes-meter__value tm-votes-meter__value_positive tm-votes-meter__value_medium">+46</span></div> <DIV class="v-portal" style="display:none;"></DIV></div> <!----> <span title="Количество просмотров" class="tm-icon-counter tm-data-icons__item"><svg height="16" width="16" class="tm-svg-img tm-icon-counter__icon"><title>Просмотры</title> <use xlink:href="/img/megazord-v24.ce74655c.svg#counter-views"></use></svg> <span class="tm-icon-counter__value">7K</span></span> <button title="Добавить в закладки" type="button" class="bookmarks-button tm-data-icons__item"><span title="Добавить в закладки" class="tm-svg-icon__wrapper bookmarks-button__icon"><svg height="16" width="16" class="tm-svg-img tm-svg-icon"><title>Добавить в закладки</title> <use xlink:href="/img/megazord-v24.ce74655c.svg#counter-favorite"></use></svg></span> <span title="Количество пользователей, добавивших публикацию в закладки" class="bookmarks-button__counter">
    14
  </span></button> <!----> <div title="Поделиться" class="tm-sharing tm-data-icons__item"><button type="button" class="tm-sharing__button"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" class="tm-sharing__icon"><path fill="currentColor" d="M10.33.275l9.047 7.572a.2.2 0 010 .306l-9.048 7.572a.2.2 0 01-.328-.153V11c-8 0-9.94 6-9.94 6S-1 5 10 5V.428a.2.2 0 01.328-.153z"></path></svg></button> <!----></div> <DIV class="v-portal" style="display:none;"></DIV></div> </div></div> <!----> <!----> <div class="tm-article-presenter__footer"><div class="tm-article-blocks"><!----> <section class="tm-block tm-block_spacing-bottom"><!----> <div class="tm-block__body tm-block__body_variant-balanced"><div class="tm-article-author"><div class="tm-article-author__company"><div class="tm-article-author__company-card"><div class="tm-company-snippet"><a href="/ru/company/pvs-studio/profile/" class="tm-company-snippet__logo-link"><div class="tm-entity-image"><img alt="" height="40" src="//habrastorage.org/getpro/habr/company/95a/244/327/95a244327fc36477b6048c0f8b67df8b.png" width="40" class="tm-entity-image__pic"></div></a> <div class="tm-company-snippet__info"><a href="/ru/company/pvs-studio/profile/" class="tm-company-snippet__title">PVS-Studio</a> <div class="tm-company-snippet__description">Статический анализ кода для C, C++, C# и Java</div></div></div> <div class="tm-article-author__buttons"><!----> <!----></div></div> <div class="tm-article-author__company-contacts"><a href="https://pvs-studio.com/" rel="noopener" target="_blank" class="tm-article-author__contact">
      Сайт
    </a><a href="https://facebook.com/StaticCodeAnalyzer" rel="noopener" target="_blank" class="tm-article-author__contact">
      Facebook
    </a><a href="https://twitter.com/Code_Analysis" rel="noopener" target="_blank" class="tm-article-author__contact">
      Twitter
    </a><a href="https://instagram.com/pvsstudio_rus" rel="noopener" target="_blank" class="tm-article-author__contact">
      Instagram
    </a><a href="https://telegram.me/pvsstudio_rus" rel="noopener" target="_blank" class="tm-article-author__contact">
      Telegram
    </a></div> <div class="tm-article-author__separator"></div></div> <div class="tm-user-card tm-article-author__user-card tm-user-card_variant-article"><div class="tm-user-card__info-container"><div class="tm-user-card__header"><div class="tm-user-card__header-data"><a href="/ru/users/Andrey2008/" class="tm-user-card__userpic tm-user-card__userpic_size-40"><div class="tm-entity-image"><img alt="" src="//habrastorage.org/getpro/habr/avatars/71b/4ac/f13/71b4acf131d3d675b999b4a47f573b0a.jpg" class="tm-entity-image__pic"></div></a> <div class="tm-user-card__meta"><div title=" 1344 голоса " class="tm-karma tm-user-card__karma"><div class="tm-karma__votes tm-karma__votes_positive">
    508.3
  </div> <div class="tm-karma__text">
    Карма
  </div></div> <div title="Рейтинг пользователя" class="tm-rating tm-user-card__rating"><div class="tm-rating__header"> <div class="tm-rating__counter">62.4</div></div> <div class="tm-rating__text">
    Рейтинг
  </div></div></div></div></div> <div class="tm-user-card__info tm-user-card__info_variant-article"><div class="tm-user-card__title tm-user-card__title_variant-article"><span class="tm-user-card__name tm-user-card__name_variant-article">Andrey Karpov</span> <a href="/ru/users/Andrey2008/" class="tm-user-card__nickname tm-user-card__nickname_variant-article">
          @Andrey2008
        </a> <!----></div> <p class="tm-user-card__short-info tm-user-card__short-info_variant-article">DevRel</p></div></div> <div class="tm-user-card__buttons tm-user-card__buttons_variant-article"><!----> <!----> <!----> <!----> <!----></div></div> <!----></div> <DIV class="v-portal" style="display:none;"></DIV></div> <!----></section> <div class="tm-article-blocks__comments"><div class="tm-article-page-comments"><div class="tm-article-comments-counter-link tm-article-comments-counter-button"><a href="/ru/company/pvs-studio/blog/450008/comments/" class="tm-article-comments-counter-link__link tm-article-comments-counter-link__link_button-style"><svg height="16" width="16" class="tm-svg-img tm-article-comments-counter-link__icon tm-article-comments-counter-link__icon_contrasted"><title>Комментарии</title> <use xlink:href="/img/megazord-v24.ce74655c.svg#counter-comments"></use></svg> <span class="tm-article-comments-counter-link__value tm-article-comments-counter-link__value_contrasted">
       Комментарии 23 
    </span></a> <!----></div></div></div>  <!---->  <!----> <!----></div></div></div></div></div> <div class="tm-page__sidebar"><div class="tm-layout-sidebar"><div class="tm-layout-sidebar__placeholder_initial"></div> <div class="tm-sexy-sidebar tm-sexy-sidebar_initial" style="margin-top:0px;"><!----> <section class="tm-block tm-block_spacing-bottom"><header class="tm-block__header"><h2 class="tm-block__title">Информация</h2> <!----></header> <div class="tm-block__body"><div class="tm-company-basic-info"><dl class="tm-description-list tm-description-list_variant-columns-nowrap"><dt class="tm-description-list__title tm-description-list__title_variant-columns-nowrap">Дата основания</dt> <dd class="tm-description-list__body tm-description-list__body_variant-columns-nowrap"><span>
      2008
    </span></dd></dl> <dl class="tm-description-list tm-description-list_variant-columns-nowrap"><dt class="tm-description-list__title tm-description-list__title_variant-columns-nowrap">Местоположение</dt> <dd class="tm-description-list__body tm-description-list__body_variant-columns-nowrap">
    Россия
  </dd></dl> <dl class="tm-description-list tm-description-list_variant-columns-nowrap"><dt class="tm-description-list__title tm-description-list__title_variant-columns-nowrap">Сайт</dt> <dd class="tm-description-list__body tm-description-list__body_variant-columns-nowrap"><a href="https://pvs-studio.com/" target="_blank" class="tm-company-basic-info__link">
      pvs-studio.com
    </a></dd></dl> <dl class="tm-description-list tm-description-list_variant-columns-nowrap"><dt class="tm-description-list__title tm-description-list__title_variant-columns-nowrap">Численность</dt> <dd class="tm-description-list__body tm-description-list__body_variant-columns-nowrap">
    31–50 человек
  </dd></dl> <dl class="tm-description-list tm-description-list_variant-columns-nowrap"><dt class="tm-description-list__title tm-description-list__title_variant-columns-nowrap">Дата регистрации</dt> <dd class="tm-description-list__body tm-description-list__body_variant-columns-nowrap"><time datetime="2013-05-06T12:33:02.000Z" title="2013-05-06, 16:33">6  мая  2013</time></dd></dl> <!----></div></div> <!----></section> <div class="tm-company-widgets"></div> <!----></div></div></div></div></div></div></main> <!----></div> <div class="tm-footer-menu"><div class="tm-page-width"><div class="tm-footer-menu__container"><div class="tm-footer-menu__block"><h3 class="tm-footer-menu__block-title">
          Ваш аккаунт
        </h3> <div class="tm-footer-menu__block-content"><ul class="tm-footer-menu__list"><li class="tm-footer-menu__list-item"><a href="/kek/v1/auth/habrahabr/?back=/ru/company/pvs-studio/blog/450008/&amp;hl=ru" rel="nofollow" target="_self">
                Войти
              </a></li><li class="tm-footer-menu__list-item"><a href="/kek/v1/auth/habrahabr-register/?back=/ru/company/pvs-studio/blog/450008/&amp;hl=ru" rel="nofollow" target="_self">
                Регистрация
              </a></li></ul></div></div><div class="tm-footer-menu__block"><h3 class="tm-footer-menu__block-title">
          Разделы
        </h3> <div class="tm-footer-menu__block-content"><ul class="tm-footer-menu__list"><li class="tm-footer-menu__list-item"><a href="/ru/" class="footer-menu__item-link router-link-active">
                Публикации
              </a></li><li class="tm-footer-menu__list-item"><a href="/ru/news/" class="footer-menu__item-link">
                Новости
              </a></li><li class="tm-footer-menu__list-item"><a href="/ru/hubs/" class="footer-menu__item-link">
                Хабы
              </a></li><li class="tm-footer-menu__list-item"><a href="/ru/companies/" class="footer-menu__item-link">
                Компании
              </a></li><li class="tm-footer-menu__list-item"><a href="/ru/users/" class="footer-menu__item-link">
                Авторы
              </a></li><li class="tm-footer-menu__list-item"><a href="/ru/sandbox/" class="footer-menu__item-link">
                Песочница
              </a></li></ul></div></div><div class="tm-footer-menu__block"><h3 class="tm-footer-menu__block-title">
          Информация
        </h3> <div class="tm-footer-menu__block-content"><ul class="tm-footer-menu__list"><li class="tm-footer-menu__list-item"><a href="/ru/docs/help/" class="footer-menu__item-link">
                Устройство сайта
              </a></li><li class="tm-footer-menu__list-item"><a href="/ru/docs/authors/codex/" class="footer-menu__item-link">
                Для авторов
              </a></li><li class="tm-footer-menu__list-item"><a href="/ru/docs/companies/corpblogs/" class="footer-menu__item-link">
                Для компаний
              </a></li><li class="tm-footer-menu__list-item"><a href="/ru/docs/docs/transparency/" class="footer-menu__item-link">
                Документы
              </a></li><li class="tm-footer-menu__list-item"><a href="https://account.habr.com/info/agreement" target="_blank">
                Соглашение
              </a></li><li class="tm-footer-menu__list-item"><a href="https://account.habr.com/info/confidential/" target="_blank">
                Конфиденциальность
              </a></li></ul></div></div><div class="tm-footer-menu__block"><h3 class="tm-footer-menu__block-title">
          Услуги
        </h3> <div class="tm-footer-menu__block-content"><ul class="tm-footer-menu__list"><li class="tm-footer-menu__list-item"><a href="https://docs.google.com/presentation/d/e/2PACX-1vQLwRfQmXibiUlWaRg-BAc38s7oM3lJiaPju7qmdJsp8ysIvZ_G-Npem0njJLMozE2bPHMpDqiI5hhy/pub?start=false&amp;loop=false&amp;delayms=60000&amp;slide=id.g91a03369cd_4_297" target="_blank">
                Реклама
              </a></li><li class="tm-footer-menu__list-item"><a href="https://habrastorage.org/storage/stuff/habr/service_price.pdf" target="_blank">
                Тарифы
              </a></li><li class="tm-footer-menu__list-item"><a href="https://docs.google.com/presentation/d/e/2PACX-1vQJJds8-Di7BQSP_guHxICN7woVYoN5NP_22ra-BIo4bqnTT9FR6fB-Ku2P0AoRpX0Ds-LRkDeAoD8F/pub?start=false&amp;loop=false&amp;delayms=60000" target="_blank">
                Контент
              </a></li><li class="tm-footer-menu__list-item"><a href="https://tmtm.timepad.ru/" target="_blank">
                Семинары
              </a></li><li class="tm-footer-menu__list-item"><a href="/ru/megaprojects/" class="footer-menu__item-link">
                Мегапроекты
              </a></li></ul></div></div></div></div></div> <div class="tm-footer"><div class="tm-page-width"><div class="tm-footer__container"><!----> <div class="tm-footer__social"><a href="https://www.facebook.com/habrahabr.ru" rel="nofollow noopener noreferrer" target="_blank" class="tm-svg-icon__wrapper tm-social-icons__icon"><svg height="16" width="16" class="tm-svg-img tm-svg-icon"><title>Facebook</title> <use xlink:href="/img/social-icons-sprite.svg#social-logo-facebook"></use></svg></a><a href="https://twitter.com/habr_com" rel="nofollow noopener noreferrer" target="_blank" class="tm-svg-icon__wrapper tm-social-icons__icon"><svg height="16" width="16" class="tm-svg-img tm-svg-icon"><title>Twitter</title> <use xlink:href="/img/social-icons-sprite.svg#social-logo-twitter"></use></svg></a><a href="https://vk.com/habr" rel="nofollow noopener noreferrer" target="_blank" class="tm-svg-icon__wrapper tm-social-icons__icon"><svg height="16" width="16" class="tm-svg-img tm-svg-icon"><title>VK</title> <use xlink:href="/img/social-icons-sprite.svg#social-logo-vkontakte"></use></svg></a><a href="https://telegram.me/habr_com" rel="nofollow noopener noreferrer" target="_blank" class="tm-svg-icon__wrapper tm-social-icons__icon"><svg height="16" width="16" class="tm-svg-img tm-svg-icon"><title>Telegram</title> <use xlink:href="/img/social-icons-sprite.svg#social-logo-telegram"></use></svg></a><a href="https://www.youtube.com/channel/UCd_sTwKqVrweTt4oAKY5y4w" rel="nofollow noopener noreferrer" target="_blank" class="tm-svg-icon__wrapper tm-social-icons__icon"><svg height="16" width="16" class="tm-svg-img tm-svg-icon"><title>Youtube</title> <use xlink:href="/img/social-icons-sprite.svg#social-logo-youtube"></use></svg></a><a href="https://zen.yandex.ru/habr" rel="nofollow noopener noreferrer" target="_blank" class="tm-svg-icon__wrapper tm-social-icons__icon"><svg height="16" width="16" class="tm-svg-img tm-svg-icon"><title>Яндекс Дзен</title> <use xlink:href="/img/social-icons-sprite.svg#social-logo-zen"></use></svg></a></div> <DIV class="v-portal" style="display:none;"></DIV> <button class="tm-footer__link"><!---->
        Настройка языка
      </button> <a href="/ru/about" class="tm-footer__link">
        О сайте
      </a> <a href="/ru/feedback/" class="tm-footer__link">
        Техническая поддержка
      </a> <!----> <a href="/berserk-mode-nope" class="tm-footer__link">
        Вернуться на старую версию
      </a> <div class="tm-footer-copyright"><span class="tm-copyright"><span class="tm-copyright__years">© 2006–2021 </span> <span class="tm-copyright__name">«<a href="https://company.habr.com/" rel="noopener" target="_blank" class="tm-copyright__link">Habr</a>»</span></span></div></div></div></div> <!----> <!----></div> <div class="vue-portal-target"></div></div>
<script>window.__INITIAL_STATE__={"adblock":{"hasAcceptableAdsFilter":false,"hasAdblock":false},"articlesList":{"articlesList":{"450008":{"id":"450008","timePublished":"2019-04-29T13:52:32+00:00","isCorporative":true,"lang":"ru","titleHtml":"﻿Находим баги в LLVM 8 с помощью анализатора PVS-Studio","leadData":{"textHtml":"\u003Cdiv style=\"text-align:center;\"\u003E\u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fpost_images\u002F2f2\u002F8d4\u002F5bf\u002F2f28d45bf369270d9330bfbe2ea78f00.png\" alt=\"PVS-Studio and LLVM 8.0.0\"\u003E\u003C\u002Fdiv\u003E\u003Cbr\u003E\r\nПрошло более двух лет с момента последней проверки кода проекта LLVM с помощью нашего анализатора PVS-Studio. Давайте убедимся, что анализатор PVS-Studio по-прежнему является лидирующим инструментом по выявлению ошибок и потенциальных уязвимостей. Для этого проверим и найдём новые ошибки в релизе LLVM 8.0.0.\u003Cbr\u003E","imageUrl":null,"buttonTextHtml":"Читать дальше →","image":null},"editorVersion":"1.0","postType":"article","postLabels":[],"author":{"scoreStats":{"score":508.3,"votesCount":1344},"rating":62.4,"relatedData":null,"contacts":[],"authorContacts":[],"paymentDetails":{"paymentYandexMoney":null,"paymentPayPalMe":null,"paymentWebmoney":null},"id":"39063","alias":"Andrey2008","fullname":"Andrey Karpov","avatarUrl":"\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Favatars\u002F71b\u002F4ac\u002Ff13\u002F71b4acf131d3d675b999b4a47f573b0a.jpg","speciality":"DevRel"},"statistics":{"commentsCount":23,"favoritesCount":14,"readingCount":6993,"score":46,"votesCount":54},"hubs":[{"relatedData":null,"id":"18095","alias":"pvs-studio","type":"corporative","title":"Блог компании PVS-Studio","titleHtml":"Блог компании PVS-Studio","isProfiled":false},{"relatedData":null,"id":"144","alias":"open_source","type":"collective","title":"Open source","titleHtml":"Open source","isProfiled":true},{"relatedData":null,"id":"559","alias":"cpp","type":"collective","title":"C++","titleHtml":"C++","isProfiled":true},{"relatedData":null,"id":"17188","alias":"compilers","type":"collective","title":"Компиляторы","titleHtml":"Компиляторы","isProfiled":true},{"relatedData":null,"id":"20788","alias":"devops","type":"collective","title":"DevOps","titleHtml":"DevOps","isProfiled":true}],"flows":[{"id":"1","alias":"develop","title":"Разработка"},{"id":"6","alias":"admin","title":"Администрирование"}],"relatedData":null,"textHtml":"\u003Cdiv xmlns=\"http:\u002F\u002Fwww.w3.org\u002F1999\u002Fxhtml\"\u003E\u003Cdiv style=\"text-align:center;\"\u003E\u003Cimg src=\"\u002Fimg\u002Fimage-loader.svg\" alt=\"PVS-Studio and LLVM 8.0.0\" data-src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fpost_images\u002F2f2\u002F8d4\u002F5bf\u002F2f28d45bf369270d9330bfbe2ea78f00.png\"\u002F\u003E\u003C\u002Fdiv\u003E\u003Cbr\u002F\u003E\r\nПрошло более двух лет с момента последней проверки кода проекта LLVM с помощью нашего анализатора PVS-Studio. Давайте убедимся, что анализатор PVS-Studio по-прежнему является лидирующим инструментом по выявлению ошибок и потенциальных уязвимостей. Для этого проверим и найдём новые ошибки в релизе LLVM 8.0.0.\u003Cbr\u002F\u003E\r\n\u003Ca name=\"habracut\"\u003E\u003C\u002Fa\u003E\u003Cbr\u002F\u003E\r\n\u003Ch2\u003EСтатья, которая должна быть написана\u003C\u002Fh2\u003E\u003Cbr\u002F\u003E\r\nЕсли честно, мне не хотелось писать эту статью. Неинтересно писать про проект, который мы уже неоднократно проверяли (\u003Ca href=\"https:\u002F\u002Fwww.viva64.com\u002Fru\u002Fb\u002F0108\u002F\"\u003E1\u003C\u002Fa\u003E, \u003Ca href=\"https:\u002F\u002Fwww.viva64.com\u002Fru\u002Fb\u002F0155\u002F\"\u003E2\u003C\u002Fa\u003E, \u003Ca href=\"https:\u002F\u002Fwww.viva64.com\u002Fru\u002Fb\u002F0446\u002F\"\u003E3\u003C\u002Fa\u003E). Лучше написать про что-то новое, но у меня нет выбора.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nКаждый раз, когда выходит новая версия LLVM или обновляется \u003Ca href=\"https:\u002F\u002Fclang-analyzer.llvm.org\u002F\"\u003EClang Static Analyzer\u003C\u002Fa\u003E, у нас в почте появляются вопросы следующего типа:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Ci\u003EСмотрите, новая версия Clang Static Analyzer научилась находить новые ошибки! Мне кажется, актуальность использовать PVS-Studio уменьшается. Clang находит больше ошибок, чем раньше и догоняет по возможностям PVS-Studio. Что вы про это думаете?\u003C\u002Fi\u003E\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nНа это мне всегда хочется ответить что-то в духе:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cb\u003EМы тоже не сидим без дела!\u003C\u002Fb\u003E Мы существенно улучшили возможности анализатора PVS-Studio. Так что не волнуйтесь, мы продолжаем лидировать, как и раньше.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nК сожалению, это плохой ответ. В нём нет proof-ов. И именно поэтому сейчас я пишу эту статью. Итак, проект LLVM в очередной раз проверен и в нём найдены разнообразнейшие ошибки. Те, которые мне показались интересными, я сейчас продемонстрирую. Эти ошибки не может найти Clang Static Analyzer (или это крайне неудобно делать с его помощью). А мы можем. Причём я нашел и выписал все эти ошибки за один вечер.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nА вот написание статьи затянулось на несколько недель. Никак не мог себя заставить всё это оформить в виде текста :).\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nКстати, если вам интересно, какие технологии используются в анализаторе PVS-Studio для выявления ошибок и потенциальных уязвимостей, то я предлагаю познакомиться с этой \u003Ca href=\"https:\u002F\u002Fwww.viva64.com\u002Fru\u002Fb\u002F0592\u002F\"\u003Eзаметкой\u003C\u002Fa\u003E.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Ch2\u003EНовые и старые диагностики\u003C\u002Fh2\u003E\u003Cbr\u002F\u003E\r\nКак уже было отмечено, около двух лет назад проект LLVM был в очередной раз проверен, а найденные ошибки исправлены. Теперь в этой статье будет представлена новая порция ошибок. Почему были найдены новые ошибки? На это есть 3 причины:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Col\u003E\r\n\u003Cli\u003EПроект LLVM развивается, в нём изменяется старый код, и появляется новый. Естественно в изменённом и написанном коде есть новые ошибки. Это хорошо демонстрирует, что статический анализ должен применяться регулярно, а не от случая к случаю. Наши статьи хорошо показывают возможности анализатора PVS-Studio, но это не имеет ничего общего с повышением качества кода и снижением стоимости исправления ошибок. Используйте статический анализатор кода регулярно!\u003C\u002Fli\u003E\r\n\u003Cli\u003EМы дорабатываем и усовершенствуем уже существующие диагностики. Поэтому анализатор может выявить ошибки, которые не замечал при предыдущих проверках.\u003C\u002Fli\u003E\r\n\u003Cli\u003EВ PVS-Studio появились новые диагностики, которых не было 2 года назад. Я решил выделить их в отдельный раздел, чтобы наглядно показать развитие PVS-Studio.\u003C\u002Fli\u003E\r\n\u003C\u002Fol\u003E\u003Cbr\u002F\u003E\r\n\u003Ch2\u003EДефекты, выявленные диагностиками, существовавшими 2 года назад\u003C\u002Fh2\u003E\u003Cbr\u002F\u003E\r\n\u003Cb\u003EФрагмент N1: Copy-Paste\u003C\u002Fb\u003E\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"cpp\"\u003Estatic bool ShouldUpgradeX86Intrinsic(Function *F, StringRef Name) {\n  if (Name == \"addcarryx.u32\" || \u002F\u002F Added in 8.0\n    ....\n    Name == \"avx512.mask.cvtps2pd.128\" || \u002F\u002F Added in 7.0\n    Name == \"avx512.mask.cvtps2pd.256\" || \u002F\u002F Added in 7.0\n    Name == \"avx512.cvtusi2sd\" || \u002F\u002F Added in 7.0\n    Name.startswith(\"avx512.mask.permvar.\") || \u002F\u002F Added in 7.0     \u002F\u002F &lt;=\n    Name.startswith(\"avx512.mask.permvar.\") || \u002F\u002F Added in 7.0     \u002F\u002F &lt;=\n    Name == \"sse2.pmulu.dq\" || \u002F\u002F Added in 7.0\n    Name == \"sse41.pmuldq\" || \u002F\u002F Added in 7.0\n    Name == \"avx2.pmulu.dq\" || \u002F\u002F Added in 7.0\n  ....\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nПредупреждение PVS-Studio: \u003Ca href=\"https:\u002F\u002Fwww.viva64.com\u002Fru\u002Fw\u002Fv501\u002F\"\u003EV501\u003C\u002Fa\u003E [CWE-570] There are identical sub-expressions 'Name.startswith(«avx512.mask.permvar.»)' to the left and to the right of the '||' operator. AutoUpgrade.cpp 73\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nДважды проверяется, что имя начинается с подстроки «avx512.mask.permvar.». Во второй проверке явно хотели написать что-то ещё, но забыли исправить скопированный текст.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cb\u003EФрагмент N2: Опечатка\u003C\u002Fb\u003E\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"cpp\"\u003Eenum CXNameRefFlags {\n  CXNameRange_WantQualifier = 0x1,\n  CXNameRange_WantTemplateArgs = 0x2,\n  CXNameRange_WantSinglePiece = 0x4\n};\n\nvoid AnnotateTokensWorker::HandlePostPonedChildCursor(\n    CXCursor Cursor, unsigned StartTokenIndex) {\n  const auto flags = CXNameRange_WantQualifier | CXNameRange_WantQualifier;\n  ....\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nПредупреждение PVS-Studio: V501 There are identical sub-expressions 'CXNameRange_WantQualifier' to the left and to the right of the '|' operator. CIndex.cpp 7245\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nИз-за опечатки дважды используется одна и та же именованная константа \u003Ci\u003ECXNameRange_WantQualifier\u003C\u002Fi\u003E.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cb\u003EФрагмент N3: Путаница с приоритетами операторов\u003C\u002Fb\u003E\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"cpp\"\u003Eint PPCTTIImpl::getVectorInstrCost(unsigned Opcode, Type *Val, unsigned Index) {\n  ....\n  if (ISD == ISD::EXTRACT_VECTOR_ELT &amp;&amp; Index == ST-\u003EisLittleEndian() ? 1 : 0)\n    return 0;\n  ....\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nПредупреждение PVS-Studio: \u003Ca href=\"https:\u002F\u002Fwww.viva64.com\u002Fru\u002Fw\u002Fv502\u002F\"\u003EV502\u003C\u002Fa\u003E [CWE-783] Perhaps the '?:' operator works in a different way than it was expected. The '?:' operator has a lower priority than the '==' operator. PPCTargetTransformInfo.cpp 404\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nНа мой взгляд, это очень красивая ошибка. Да, я знаю, что у меня странные представления о красоте :).\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nСейчас, согласно \u003Ca href=\"https:\u002F\u002Fwww.viva64.com\u002Fru\u002Ft\u002F0064\u002F\"\u003Eприоритетам операторов\u003C\u002Fa\u003E, выражение вычисляется следующим образом:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"cpp\"\u003E(ISD == ISD::EXTRACT_VECTOR_ELT &amp;&amp; (Index == ST-\u003EisLittleEndian())) ? 1 : 0\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nС практической точки зрения такое условие не имеет смысла, так как его можно сократить до:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"cpp\"\u003E(ISD == ISD::EXTRACT_VECTOR_ELT &amp;&amp; Index == ST-\u003EisLittleEndian())\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nЭто явная ошибка. Скорее всего, 0\u002F1 хотели сравнить с переменной \u003Ci\u003EIndex\u003C\u002Fi\u003E. Чтобы исправить код необходимо добавить скобки вокруг тернарного оператора:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"cpp\"\u003Eif (ISD == ISD::EXTRACT_VECTOR_ELT &amp;&amp; Index == (ST-\u003EisLittleEndian() ? 1 : 0))\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nКстати, тернарный оператор очень опасный и провоцирует логические ошибки. Будьте очень аккуратны с ним и не жадничайте ставить круглые скобки. Подробнее эту тему я рассматривал \u003Ca href=\"https:\u002F\u002Fwww.viva64.com\u002Fru\u002Fb\u002F0391\u002F\"\u003Eздесь\u003C\u002Fa\u003E, в главе «Бойтесь оператора ?: и заключайте его в круглые скобки».\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cb\u003EФрагмент N4, N5: Нулевой указатель\u003C\u002Fb\u003E\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"cpp\"\u003EInit *TGParser::ParseValue(Record *CurRec, RecTy *ItemType, IDParseMode Mode) {\n  ....\n  TypedInit *LHS = dyn_cast&lt;TypedInit\u003E(Result);\n  ....\n  LHS = dyn_cast&lt;TypedInit\u003E(\n    UnOpInit::get(UnOpInit::CAST, LHS, StringRecTy::get())\n      -\u003EFold(CurRec));\n  if (!LHS) {\n    Error(PasteLoc, Twine(\"can't cast '\") + LHS-\u003EgetAsString() +\n                    \"' to string\");\n    return nullptr;\n  }\n  ....\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nПредупреждение PVS-Studio: \u003Ca href=\"https:\u002F\u002Fwww.viva64.com\u002Fru\u002Fw\u002Fv522\u002F\"\u003EV522\u003C\u002Fa\u003E [CWE-476] Dereferencing of the null pointer 'LHS' might take place. TGParser.cpp 2152\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nЕсли указатель \u003Ci\u003ELHS\u003C\u002Fi\u003E окажется нулевым, то должно быть выдано предупреждение. Однако вместо этого произойдёт разыменование этого самого нулевого указателя: \u003Ci\u003ELHS-\u003EgetAsString()\u003C\u002Fi\u003E.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nЭто весьма типовая ситуация, когда ошибка прячется в обработчике ошибок, так как их никто не тестирует. Статические анализаторы проверяют весь достижимый код, независимо от того, как часто он используется. Это очень хороший пример, как статический анализ дополняет другие методики тестирования и защиты от ошибок.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nАналогичная ошибка обработки указателя \u003Ci\u003ERHS\u003C\u002Fi\u003E допущена в коде чуть ниже: V522 [CWE-476] Dereferencing of the null pointer 'RHS' might take place. TGParser.cpp 2186\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cb\u003EФрагмент N6: Использование указателя после перемещения\u003C\u002Fb\u003E\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"cpp\"\u003Estatic Expected&lt;bool\u003E\nExtractBlocks(....)\n{\n  ....\n  std::unique_ptr&lt;Module\u003E ProgClone = CloneModule(BD.getProgram(), VMap);\n  ....\n  BD.setNewProgram(std::move(ProgClone));                                \u002F\u002F &lt;=\n  MiscompiledFunctions.clear();\n\n  for (unsigned i = 0, e = MisCompFunctions.size(); i != e; ++i) {\n    Function *NewF = ProgClone-\u003EgetFunction(MisCompFunctions[i].first);  \u002F\u002F &lt;=\n    assert(NewF &amp;&amp; \"Function not found??\");\n    MiscompiledFunctions.push_back(NewF);\n  }\n  ....\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nПредупреждение PVS-Studio: V522 [CWE-476] Dereferencing of the null pointer 'ProgClone' might take place. Miscompilation.cpp 601\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nВ начале умный указатель \u003Ci\u003EProgClone\u003C\u002Fi\u003E перестаёт владеть объектом:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"cpp\"\u003EBD.setNewProgram(std::move(ProgClone));\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nФактически, теперь \u003Ci\u003EProgClone \u003C\u002Fi\u003E — это нулевой указатель. Поэтому чуть ниже должно произойти разыменование нулевого указателя:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"cpp\"\u003EFunction *NewF = ProgClone-\u003EgetFunction(MisCompFunctions[i].first);\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nНо, на самом деле, этого не произойдёт! Обратите внимание, что цикл на самом деле не выполняется.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nВ начале контейнер \u003Ci\u003EMiscompiledFunctions\u003C\u002Fi\u003E очищается:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"cpp\"\u003EMiscompiledFunctions.clear();\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nДалее размер этого контейнера используется в условии цикла:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"cpp\"\u003Efor (unsigned i = 0, e = MisCompFunctions.size(); i != e; ++i) {\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nЛегко видеть, что цикл не запускается. Думаю, это тоже ошибка, и код должен быть написан иным образом.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nКажется, мы встретили ту самую знаменитую чётность ошибок! Одна ошибка маскирует другую :).\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cb\u003EФрагмент N7: Использование указателя после перемещения\u003C\u002Fb\u003E\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"cpp\"\u003Estatic Expected&lt;bool\u003E TestOptimizer(BugDriver &amp;BD, std::unique_ptr&lt;Module\u003E Test,\n                                    std::unique_ptr&lt;Module\u003E Safe) {\n  outs() &lt;&lt; \"  Optimizing functions being tested: \";\n  std::unique_ptr&lt;Module\u003E Optimized =\n      BD.runPassesOn(Test.get(), BD.getPassesToRun());\n  if (!Optimized) {\n    errs() &lt;&lt; \" Error running this sequence of passes\"\n           &lt;&lt; \" on the input program!\\n\";\n    BD.setNewProgram(std::move(Test));                       \u002F\u002F &lt;=\n    BD.EmitProgressBitcode(*Test, \"pass-error\", false);      \u002F\u002F &lt;=\n    if (Error E = BD.debugOptimizerCrash())\n      return std::move(E);\n    return false;\n  }\n  ....\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nПредупреждение PVS-Studio: V522 [CWE-476] Dereferencing of the null pointer 'Test' might take place. Miscompilation.cpp 709\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nВновь та же самая ситуация. В начале содержимое объекта перемещается, а затем он используется как ни в чём не бывало. Я всё чаще встречаю эту ситуацию в коде программ, после того, как в С++ появилась семантика перемещения. За это я и люблю язык C++! Появляются всё новые и новые способы отстрелить себе ногу. Анализатору PVS-Studio всегда будет работа :).\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cb\u003EФрагмент N8: Нулевой указатель\u003C\u002Fb\u003E\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"cpp\"\u003Evoid FunctionDumper::dump(const PDBSymbolTypeFunctionArg &amp;Symbol) {\n  uint32_t TypeId = Symbol.getTypeId();\n  auto Type = Symbol.getSession().getSymbolById(TypeId);\n  if (Type)\n    Printer &lt;&lt; \"&lt;unknown-type\u003E\";\n  else\n    Type-\u003Edump(*this);\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nПредупреждение PVS-Studio: V522 [CWE-476] Dereferencing of the null pointer 'Type' might take place. PrettyFunctionDumper.cpp 233\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nПомимо обработчиков ошибок, обычно не тестируются и функции отладочной распечатки данных. Перед нами как раз такой случай. Функция ждёт пользователя, которой вместо того чтобы решить свои проблемы, будет вынужден заняться её исправлением.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nПравильно:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"cpp\"\u003Eif (Type)\n  Type-\u003Edump(*this);\nelse\n  Printer &lt;&lt; \"&lt;unknown-type\u003E\";\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003Cb\u003EФрагмент N9: Нулевой указатель\u003C\u002Fb\u003E\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"cpp\"\u003Evoid SearchableTableEmitter::collectTableEntries(\n    GenericTable &amp;Table, const std::vector&lt;Record *\u003E &amp;Items) {\n  ....\n  RecTy *Ty = resolveTypes(Field.RecType, TI-\u003EgetType());\n  if (!Ty)                                                              \u002F\u002F &lt;=\n    PrintFatalError(Twine(\"Field '\") + Field.Name + \"' of table '\" +\n                    Table.Name + \"' has incompatible type: \" +\n                    Ty-\u003EgetAsString() + \" vs. \" +                       \u002F\u002F &lt;=\n                    TI-\u003EgetType()-\u003EgetAsString());\n   ....\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nПредупреждение PVS-Studio: V522 [CWE-476] Dereferencing of the null pointer 'Ty' might take place. SearchableTableEmitter.cpp 614\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nДумаю, и так всё понятно и не требует пояснений.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cb\u003EФрагмент N10: Опечатка\u003C\u002Fb\u003E\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"cpp\"\u003Ebool FormatTokenLexer::tryMergeCSharpNullConditionals() {\n  ....\n  auto &amp;Identifier = *(Tokens.end() - 2);\n  auto &amp;Question = *(Tokens.end() - 1);\n  ....\n  Identifier-\u003EColumnWidth += Question-\u003EColumnWidth;\n  Identifier-\u003EType = Identifier-\u003EType;                    \u002F\u002F &lt;=\n  Tokens.erase(Tokens.end() - 1);\n  return true;\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nПредупреждение PVS-Studio: \u003Ca href=\"https:\u002F\u002Fwww.viva64.com\u002Fru\u002Fw\u002Fv570\u002F\"\u003EV570\u003C\u002Fa\u003E The 'Identifier-\u003EType' variable is assigned to itself. FormatTokenLexer.cpp 249\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nНет смысла присваивать переменную саму себе. Скорее всего хотели написать:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"cpp\"\u003EIdentifier-\u003EType = Question-\u003EType;\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003Cb\u003EФрагмент N11: Подозрительный break\u003C\u002Fb\u003E\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"cpp\"\u003Evoid SystemZOperand::print(raw_ostream &amp;OS) const {\n  switch (Kind) {\n    break;\n  case KindToken:\n    OS &lt;&lt; \"Token:\" &lt;&lt; getToken();\n    break;\n  case KindReg:\n    OS &lt;&lt; \"Reg:\" &lt;&lt; SystemZInstPrinter::getRegisterName(getReg());\n    break;\n  ....\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nПредупреждение PVS-Studio: \u003Ca href=\"https:\u002F\u002Fwww.viva64.com\u002Fru\u002Fw\u002Fv622\u002F\"\u003EV622\u003C\u002Fa\u003E [CWE-478] Consider inspecting the 'switch' statement. It's possible that the first 'case' operator is missing. SystemZAsmParser.cpp 652\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nВ начале присутствует очень подозрительный оператор \u003Ci\u003Ebreak\u003C\u002Fi\u003E. Не забыли ли здесь написать что-то ещё?\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cb\u003EФрагмент N12: Проверка указателя после разыменования\u003C\u002Fb\u003E\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"cpp\"\u003EInlineCost AMDGPUInliner::getInlineCost(CallSite CS) {\n  Function *Callee = CS.getCalledFunction();\n  Function *Caller = CS.getCaller();\n  TargetTransformInfo &amp;TTI = TTIWP-\u003EgetTTI(*Callee);\n\n  if (!Callee || Callee-\u003EisDeclaration())\n    return llvm::InlineCost::getNever(\"undefined callee\");\n  ....\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nПредупреждение PVS-Studio: \u003Ca href=\"https:\u002F\u002Fwww.viva64.com\u002Fru\u002Fw\u002Fv595\u002F\"\u003EV595\u003C\u002Fa\u003E [CWE-476] The 'Callee' pointer was utilized before it was verified against nullptr. Check lines: 172, 174. AMDGPUInline.cpp 172\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nУказатель \u003Ci\u003ECallee\u003C\u002Fi\u003E в начале разыменовывается в момент вызова функции \u003Ci\u003EgetTTI\u003C\u002Fi\u003E.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nА затем оказывается, что этот указатель следует проверять на равенство \u003Ci\u003Enullptr\u003C\u002Fi\u003E:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"cpp\"\u003Eif (!Callee || Callee-\u003EisDeclaration())\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nНо уже поздно…\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cb\u003EФрагмент N13 — N...: Проверка указателя после разыменования\u003C\u002Fb\u003E\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nСитуация, рассмотренная в предыдущем фрагменте кода не уникальна. Она встречается здесь:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"cpp\"\u003Estatic Value *optimizeDoubleFP(CallInst *CI, IRBuilder&lt;\u003E &amp;B,\n                               bool isBinary, bool isPrecise = false) {\n  ....\n  Function *CalleeFn = CI-\u003EgetCalledFunction();\n  StringRef CalleeNm = CalleeFn-\u003EgetName();                 \u002F\u002F &lt;=\n  AttributeList CalleeAt = CalleeFn-\u003EgetAttributes();\n  if (CalleeFn &amp;&amp; !CalleeFn-\u003EisIntrinsic()) {               \u002F\u002F &lt;=\n  ....\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nПредупреждение PVS-Studio: V595 [CWE-476] The 'CalleeFn' pointer was utilized before it was verified against nullptr. Check lines: 1079, 1081. SimplifyLibCalls.cpp 1079\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nИ здесь:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"cpp\"\u003Evoid Sema::InstantiateAttrs(const MultiLevelTemplateArgumentList &amp;TemplateArgs,\n                            const Decl *Tmpl, Decl *New,\n                            LateInstantiatedAttrVec *LateAttrs,\n                            LocalInstantiationScope *OuterMostScope) {\n  ....\n  NamedDecl *ND = dyn_cast&lt;NamedDecl\u003E(New);\n  CXXRecordDecl *ThisContext =\n    dyn_cast_or_null&lt;CXXRecordDecl\u003E(ND-\u003EgetDeclContext());         \u002F\u002F &lt;=\n  CXXThisScopeRAII ThisScope(*this, ThisContext, Qualifiers(),\n                             ND &amp;&amp; ND-\u003EisCXXInstanceMember());     \u002F\u002F &lt;=\n  ....\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nПредупреждение PVS-Studio: V595 [CWE-476] The 'ND' pointer was utilized before it was verified against nullptr. Check lines: 532, 534. SemaTemplateInstantiateDecl.cpp 532\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nИ здесь:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cul\u003E\r\n\u003Cli\u003EV595 [CWE-476] The 'U' pointer was utilized before it was verified against nullptr. Check lines: 404, 407. DWARFFormValue.cpp 404\u003C\u002Fli\u003E\r\n\u003Cli\u003EV595 [CWE-476] The 'ND' pointer was utilized before it was verified against nullptr. Check lines: 2149, 2151. SemaTemplateInstantiate.cpp 2149\u003C\u002Fli\u003E\r\n\u003C\u002Ful\u003E\u003Cbr\u002F\u003E\r\nА дальше мне стало неинтересно изучать предупреждения с номером V595. Так что я не знаю, есть ли ещё подобные ошибки, помимо перечисленных здесь. Скорее всего есть.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cb\u003EФрагмент N17, N18: Подозрительный сдвиг\u003C\u002Fb\u003E\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"cpp\"\u003Estatic inline bool processLogicalImmediate(uint64_t Imm, unsigned RegSize,\n                                           uint64_t &amp;Encoding) {\n  ....\n  unsigned Size = RegSize;\n  ....\n  uint64_t NImms = ~(Size-1) &lt;&lt; 1;\n  ....\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nПредупреждение PVS-Studio: \u003Ca href=\"https:\u002F\u002Fwww.viva64.com\u002Fru\u002Fw\u002Fv629\u002F\"\u003EV629\u003C\u002Fa\u003E [CWE-190] Consider inspecting the '~(Size — 1) &lt;&lt; 1' expression. Bit shifting of the 32-bit value with a subsequent expansion to the 64-bit type. AArch64AddressingModes.h 260\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nВозможно, это не ошибка, и код работает именно так, как и задумано. Но это явно очень подозрительное место, и его нужно проверить.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nДопустим, переменная \u003Ci\u003ESize\u003C\u002Fi\u003E равна 16, и тогда автор кода планировал получить в переменной \u003Ci\u003ENImms\u003C\u002Fi\u003E значение:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n1111111111111111111111111111111111111111111111111111111111100000\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nОднако, на самом деле, получится значение:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n0000000000000000000000000000000011111111111111111111111111100000\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nДело в том, что все вычисления происходят с использованием 32-битного типа unsigned. И только затем, этот 32-битный беззнаковый тип будет неявно расширен до \u003Ci\u003Euint64_t\u003C\u002Fi\u003E. При этом старшие биты окажутся нулевыми.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nИсправить ситуацию можно так:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"cpp\"\u003Euint64_t NImms = ~static_cast&lt;uint64_t\u003E(Size-1) &lt;&lt; 1;\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nАналогичная ситуация: V629 [CWE-190] Consider inspecting the 'Immr &lt;&lt; 6' expression. Bit shifting of the 32-bit value with a subsequent expansion to the 64-bit type. AArch64AddressingModes.h 269\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cb\u003EФрагмент N19: Пропущено ключевое слово \u003C\u002Fb\u003E\u003Cb\u003E\u003Ci\u003Eelse\u003C\u002Fi\u003E\u003C\u002Fb\u003E\u003Cb\u003E?\u003C\u002Fb\u003E\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"cpp\"\u003Evoid AMDGPUAsmParser::cvtDPP(MCInst &amp;Inst, const OperandVector &amp;Operands) {\n  ....\n  if (Op.isReg() &amp;&amp; Op.Reg.RegNo == AMDGPU::VCC) {\n    \u002F\u002F VOP2b (v_add_u32, v_sub_u32 ...) dpp use \"vcc\" token.\n    \u002F\u002F Skip it.\n    continue;\n  } if (isRegOrImmWithInputMods(Desc, Inst.getNumOperands())) {    \u002F\u002F &lt;=\n    Op.addRegWithFPInputModsOperands(Inst, 2);\n  } else if (Op.isDPPCtrl()) {\n    Op.addImmOperands(Inst, 1);\n  } else if (Op.isImm()) {\n    \u002F\u002F Handle optional arguments\n    OptionalIdx[Op.getImmTy()] = I;\n  } else {\n    llvm_unreachable(\"Invalid operand type\");\n  }\n  ....\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nПредупреждение PVS-Studio: \u003Ca href=\"https:\u002F\u002Fwww.viva64.com\u002Fru\u002Fw\u002Fv646\u002F\"\u003EV646\u003C\u002Fa\u003E [CWE-670] Consider inspecting the application's logic. It's possible that 'else' keyword is missing. AMDGPUAsmParser.cpp 5655\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nОшибки здесь нет. Так как then-блок первого \u003Ci\u003Eif\u003C\u002Fi\u003E оканчивается на \u003Ci\u003Econtinue\u003C\u002Fi\u003E, то не важно, есть ключевое слово \u003Ci\u003Eelse \u003C\u002Fi\u003E или нет. В любом случае код будет работать одинаково. Тем не менее, пропущенный \u003Ci\u003Eelse \u003C\u002Fi\u003E делает код более непонятным и опасным. Если в дальнейшем \u003Ci\u003Econtinue \u003C\u002Fi\u003E исчезнет, то код начнёт работать совсем по-другому. На мой взгляд, лучше добавить \u003Ci\u003Eelse\u003C\u002Fi\u003E.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cb\u003EФрагмент N20: Четыре однотипных опечатки\u003C\u002Fb\u003E\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"cpp\"\u003ELLVM_DUMP_METHOD void Symbol::dump(raw_ostream &amp;OS) const {\n  std::string Result;\n  if (isUndefined())\n    Result += \"(undef) \";\n  if (isWeakDefined())\n    Result += \"(weak-def) \";\n  if (isWeakReferenced())\n    Result += \"(weak-ref) \";\n  if (isThreadLocalValue())\n    Result += \"(tlv) \";\n  switch (Kind) {\n  case SymbolKind::GlobalSymbol:\n    Result + Name.str();                        \u002F\u002F &lt;=\n    break;\n  case SymbolKind::ObjectiveCClass:\n    Result + \"(ObjC Class) \" + Name.str();      \u002F\u002F &lt;=\n    break;\n  case SymbolKind::ObjectiveCClassEHType:\n    Result + \"(ObjC Class EH) \" + Name.str();   \u002F\u002F &lt;=\n    break;\n  case SymbolKind::ObjectiveCInstanceVariable:\n    Result + \"(ObjC IVar) \" + Name.str();       \u002F\u002F &lt;=\n    break;\n  }\n  OS &lt;&lt; Result;\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nПредупреждения PVS-Studio:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cul\u003E\r\n\u003Cli\u003EV655 [CWE-480] The strings were concatenated but are not utilized. Consider inspecting the 'Result + Name.str()' expression. Symbol.cpp 32\u003C\u002Fli\u003E\r\n\u003Cli\u003EV655 [CWE-480] The strings were concatenated but are not utilized. Consider inspecting the 'Result + \"(ObjC Class) \" + Name.str()' expression. Symbol.cpp 35\u003C\u002Fli\u003E\r\n\u003Cli\u003EV655 [CWE-480] The strings were concatenated but are not utilized. Consider inspecting the 'Result + \"(ObjC Class EH) \" + Name.str()' expression. Symbol.cpp 38\u003C\u002Fli\u003E\r\n\u003Cli\u003EV655 [CWE-480] The strings were concatenated but are not utilized. Consider inspecting the 'Result + \"(ObjC IVar) \" + Name.str()' expression. Symbol.cpp 41\u003C\u002Fli\u003E\r\n\u003C\u002Ful\u003E\u003Cbr\u002F\u003E\r\nСлучайно вместо оператора += используется оператор +. В результате получаются конструкции, лишённые смысла.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cb\u003EФрагмент N21: Неопределённое поведение\u003C\u002Fb\u003E\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"cpp\"\u003Estatic void getReqFeatures(std::map&lt;StringRef, int\u003E &amp;FeaturesMap,\n                           const std::vector&lt;Record *\u003E &amp;ReqFeatures) {\n  for (auto &amp;R : ReqFeatures) {\n    StringRef AsmCondString = R-\u003EgetValueAsString(\"AssemblerCondString\");\n\n    SmallVector&lt;StringRef, 4\u003E Ops;\n    SplitString(AsmCondString, Ops, \",\");\n    assert(!Ops.empty() &amp;&amp; \"AssemblerCondString cannot be empty\");\n\n    for (auto &amp;Op : Ops) {\n      assert(!Op.empty() &amp;&amp; \"Empty operator\");\n      if (FeaturesMap.find(Op) == FeaturesMap.end())\n        FeaturesMap[Op] = FeaturesMap.size();\n    }\n  }\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nПопробуйте самостоятельно найти опасный код. А это картинка для отвлечения внимания, чтобы сразу не посмотреть на ответ:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cp\u003E\u003C\u002Fp\u003E\u003Cdiv style=\"text-align:center;\"\u003E\u003Cimg src=\"\u002Fimg\u002Fimage-loader.svg\" alt=\"Хммм...\" data-src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fpost_images\u002Fd5d\u002F183\u002Fd4e\u002Fd5d183d4e2d3107bc512e52d893fda25.png\"\u002F\u003E\u003C\u002Fdiv\u003E\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nПредупреждение PVS-Studio: \u003Ca href=\"https:\u002F\u002Fwww.viva64.com\u002Fru\u002Fw\u002Fv708\u002F\"\u003EV708\u003C\u002Fa\u003E [CWE-758] Dangerous construction is used: 'FeaturesMap[Op] = FeaturesMap.size()', where 'FeaturesMap' is of 'map' class. This may lead to undefined behavior. RISCVCompressInstEmitter.cpp 490\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nПроблемная строчка:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"cpp\"\u003EFeaturesMap[Op] = FeaturesMap.size();\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nЕсли элемент \u003Ci\u003EOp\u003C\u002Fi\u003E не найден, то создаётся новый элемент в карте и туда записывается количество элементов в этой карте. Вот только неизвестно, будет вызвана функция \u003Ci\u003Esize\u003C\u002Fi\u003E до или после добавления нового элемента.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cb\u003EФрагмент N22-N24: Повторные присваивания\u003C\u002Fb\u003E\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"cpp\"\u003EError MachOObjectFile::checkSymbolTable() const {\n  ....\n  } else {\n    MachO::nlist STE = getSymbolTableEntry(SymDRI);\n    NType = STE.n_type;                              \u002F\u002F &lt;=\n    NType = STE.n_type;                              \u002F\u002F &lt;=\n    NSect = STE.n_sect;\n    NDesc = STE.n_desc;\n    NStrx = STE.n_strx;\n    NValue = STE.n_value;\n  }\n  ....\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nПредупреждение PVS-Studio: \u003Ca href=\"https:\u002F\u002Fwww.viva64.com\u002Fru\u002Fw\u002Fv519\u002F\"\u003EV519\u003C\u002Fa\u003E [CWE-563] The 'NType' variable is assigned values twice successively. Perhaps this is a mistake. Check lines: 1663, 1664. MachOObjectFile.cpp 1664\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nДумаю, настоящей ошибки здесь нет. Просто лишнее повторяющееся присваивание. Но всё равно ляп.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nАналогично:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cul\u003E\r\n\u003Cli\u003EV519 [CWE-563] The 'B.NDesc' variable is assigned values twice successively. Perhaps this is a mistake. Check lines: 1488, 1489. llvm-nm.cpp 1489\u003C\u002Fli\u003E\r\n\u003Cli\u003EV519 [CWE-563] The variable is assigned values twice successively. Perhaps this is a mistake. Check lines: 59, 61. coff2yaml.cpp 61\u003C\u002Fli\u003E\r\n\u003C\u002Ful\u003E\u003Cbr\u002F\u003E\r\n\u003Cb\u003EФрагмент N25-N27: Ещё повторные присваивания\u003C\u002Fb\u003E\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nТеперь рассмотрим немного другой вариант повторного присваивания.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"cpp\"\u003Ebool Vectorizer::vectorizeLoadChain(\n    ArrayRef&lt;Instruction *\u003E Chain,\n    SmallPtrSet&lt;Instruction *, 16\u003E *InstructionsProcessed) {\n  ....\n  unsigned Alignment = getAlignment(L0);\n  ....\n  unsigned NewAlign = getOrEnforceKnownAlignment(L0-\u003EgetPointerOperand(),\n                                                 StackAdjustedAlignment,\n                                                 DL, L0, nullptr, &amp;DT);\n  if (NewAlign != 0)\n    Alignment = NewAlign;\n  Alignment = NewAlign;\n  ....\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nПредупреждение PVS-Studio: V519 [CWE-563] The 'Alignment' variable is assigned values twice successively. Perhaps this is a mistake. Check lines: 1158, 1160. LoadStoreVectorizer.cpp 1160\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nЭто очень странный код, который по всей видимости содержит логическую ошибку. В начале, переменной \u003Ci\u003EAlignment\u003C\u002Fi\u003E присваивается значение в зависимости от условия. А затем вновь происходит присваивание, но теперь уже без всякой проверки.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nАналогичные ситуации можно увидеть здесь:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cul\u003E\r\n\u003Cli\u003EV519 [CWE-563] The 'Effects' variable is assigned values twice successively. Perhaps this is a mistake. Check lines: 152, 165. WebAssemblyRegStackify.cpp 165\u003C\u002Fli\u003E\r\n\u003Cli\u003EV519 [CWE-563] The 'ExpectNoDerefChunk' variable is assigned values twice successively. Perhaps this is a mistake. Check lines: 4970, 4973. SemaType.cpp 4973\u003C\u002Fli\u003E\r\n\u003C\u002Ful\u003E\u003Cbr\u002F\u003E\r\n\u003Cb\u003EФрагмент N28: Всегда истинное условие\u003C\u002Fb\u003E\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"cpp\"\u003Estatic int readPrefixes(struct InternalInstruction* insn) {\n  ....\n  uint8_t byte = 0;\n  uint8_t nextByte;\n  ....\n  if (byte == 0xf3 &amp;&amp; (nextByte == 0x88 || nextByte == 0x89 ||\n                       nextByte == 0xc6 || nextByte == 0xc7)) {\n    insn-\u003ExAcquireRelease = true;\n    if (nextByte != 0x90) \u002F\u002F PAUSE instruction support             \u002F\u002F &lt;=\n      break;\n  }\n  ....\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nПредупреждение PVS-Studio: \u003Ca href=\"https:\u002F\u002Fwww.viva64.com\u002Fru\u002Fw\u002Fv547\u002F\"\u003EV547\u003C\u002Fa\u003E [CWE-571] Expression 'nextByte != 0x90' is always true. X86DisassemblerDecoder.cpp 379\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nПроверка не имеет смысла. Переменная \u003Ci\u003EnextByte\u003C\u002Fi\u003E всегда не равна значению \u003Ci\u003E0x90\u003C\u002Fi\u003E, что вытекает из предыдущей проверки. Это какая-то логическая ошибка.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cb\u003EФрагмент N29 — N...: Всегда истинные\u002Fложные условия\u003C\u002Fb\u003E\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nАнализатор выдаёт много предупреждений о том, что всё условие (\u003Ca href=\"https:\u002F\u002Fwww.viva64.com\u002Fru\u002Fw\u002Fv547\u002F\"\u003EV547\u003C\u002Fa\u003E) или его часть (\u003Ca href=\"https:\u002F\u002Fwww.viva64.com\u002Fru\u002Fw\u002Fv560\u002F\"\u003EV560\u003C\u002Fa\u003E) всегда истинно или ложно. Часто это не настоящие ошибки, а просто неаккуратный код, результат развертывания макросов и тому подобное. Тем не менее, есть смысл посмотреть все эти предупреждения, так как время от времени встречаются настоящие логические ошибки. Например, подозрителен вот этот участок кода:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"cpp\"\u003Estatic DecodeStatus DecodeGPRPairRegisterClass(MCInst &amp;Inst, unsigned RegNo,\n                                   uint64_t Address, const void *Decoder) {\n  DecodeStatus S = MCDisassembler::Success;\n\n  if (RegNo \u003E 13)\n    return MCDisassembler::Fail;\n\n  if ((RegNo &amp; 1) || RegNo == 0xe)\n     S = MCDisassembler::SoftFail;\n  ....\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nПредупреждение PVS-Studio: \u003Ca href=\"https:\u002F\u002Fwww.viva64.com\u002Fru\u002Fw\u002Fv560\u002F\"\u003EV560\u003C\u002Fa\u003E [CWE-570] A part of conditional expression is always false: RegNo == 0xe. ARMDisassembler.cpp 939\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nКонстанта 0xE это значение 14 в десятичной системе. Проверка \u003Ci\u003ERegNo == 0xe\u003C\u002Fi\u003E не имеет смысла, так как если \u003Ci\u003ERegNo \u003E 13\u003C\u002Fi\u003E, то функция завершит своё выполнение.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nБыло множество других предупреждений с идентификатором V547 и V560, но, как и в случае с \u003Ca href=\"https:\u002F\u002Fwww.viva64.com\u002Fru\u002Fw\u002Fv595\u002F\"\u003EV595\u003C\u002Fa\u003E, изучать эти предупреждения мне было неинтересно. Было и так понятно, что мне хватит материала для написания статьи :). Поэтому неизвестно, сколько всего можно выявить ошибок этого типа в LLVM с помощью PVS-Studio.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nПриведу пример, почему изучать эти срабатывания скучно. Анализатор совершенно прав, выдавая предупреждение на следующий код. Но это и не ошибка.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"cpp\"\u003Ebool UnwrappedLineParser::parseBracedList(bool ContinueOnSemicolons,\n                                          tok::TokenKind ClosingBraceKind) {\n  bool HasError = false;\n  ....\n  HasError = true;\n  if (!ContinueOnSemicolons)\n    return !HasError;\n  ....\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nПредупреждение PVS-Studio: V547 [CWE-570] Expression '!HasError' is always false. UnwrappedLineParser.cpp 1635\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cb\u003EФрагмент N30: Подозрительный return\u003C\u002Fb\u003E\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"cpp\"\u003Estatic bool\nisImplicitlyDef(MachineRegisterInfo &amp;MRI, unsigned Reg) {\n  for (MachineRegisterInfo::def_instr_iterator It = MRI.def_instr_begin(Reg),\n      E = MRI.def_instr_end(); It != E; ++It) {\n    return (*It).isImplicitDef();\n  }\n  ....\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nПредупреждение PVS-Studio: \u003Ca href=\"https:\u002F\u002Fwww.viva64.com\u002Fru\u002Fw\u002Fv612\u002F\"\u003EV612\u003C\u002Fa\u003E [CWE-670] An unconditional 'return' within a loop. R600OptimizeVectorRegisters.cpp 63\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nЭто или ошибка, или специфический приём, который призван что-то пояснить программистам, читающим код. Мне такая конструкция ничего не поясняет и выглядит очень подозрительной. Лучше так не писать :).\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nУстали? Тогда время заварить чай или кофе.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cp\u003E\u003C\u002Fp\u003E\u003Cdiv style=\"text-align:center;\"\u003E\u003Cimg src=\"\u002Fimg\u002Fimage-loader.svg\" alt=\"Кофе\" data-src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fpost_images\u002F8a2\u002Ff86\u002F58f\u002F8a2f8658fdacb0dde918807666d1cd39.png\"\u002F\u003E\u003C\u002Fdiv\u003E\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Ch2\u003EДефекты, выявленные новыми диагностиками\u003C\u002Fh2\u003E\u003Cbr\u002F\u003E\r\nДумаю, 30 срабатываний старых диагностик достаточно. Давайте теперь посмотрим, что интересного можно находить новыми диагностиками, которые появились в анализаторе уже после \u003Ca href=\"https:\u002F\u002Fwww.viva64.com\u002Fru\u002Fb\u002F0446\u002F\"\u003Eпредыдущей\u003C\u002Fa\u003E проверки. Всего за это время в C++ анализаторе добавилось 66 диагностик общего назначения.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cb\u003EФрагмент N31: Недостижимый код\u003C\u002Fb\u003E\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"cpp\"\u003EError CtorDtorRunner::run() {\n  ....\n  if (auto CtorDtorMap =\n          ES.lookup(JITDylibSearchList({{&amp;JD, true}}), std::move(Names),\n                    NoDependenciesToRegister, true))\n  {\n    ....\n    return Error::success();\n  } else\n    return CtorDtorMap.takeError();\n\n  CtorDtorsByPriority.clear();\n\n  return Error::success();\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nПредупреждение PVS-Studio: \u003Ca href=\"https:\u002F\u002Fwww.viva64.com\u002Fru\u002Fw\u002Fv779\u002F\"\u003EV779\u003C\u002Fa\u003E [CWE-561] Unreachable code detected. It is possible that an error is present. ExecutionUtils.cpp 146\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nКак видите, обе ветки оператора \u003Ci\u003Eif\u003C\u002Fi\u003E заканчиваются вызовом оператора \u003Ci\u003Ereturn\u003C\u002Fi\u003E. Соответственно, контейнер \u003Ci\u003ECtorDtorsByPriority\u003C\u002Fi\u003E никогда не будет очищен.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cb\u003EФрагмент N32: Недостижимый код\u003C\u002Fb\u003E\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"cpp\"\u003Ebool LLParser::ParseSummaryEntry() {\n  ....\n  switch (Lex.getKind()) {\n  case lltok::kw_gv:\n    return ParseGVEntry(SummaryID);\n  case lltok::kw_module:\n    return ParseModuleEntry(SummaryID);\n  case lltok::kw_typeid:\n    return ParseTypeIdEntry(SummaryID);                        \u002F\u002F &lt;=\n    break;                                                     \u002F\u002F &lt;=\n  default:\n    return Error(Lex.getLoc(), \"unexpected summary kind\");\n  }\n  Lex.setIgnoreColonInIdentifiers(false);                      \u002F\u002F &lt;=\n  return false;\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nПредупреждение PVS-Studio: V779 [CWE-561] Unreachable code detected. It is possible that an error is present. LLParser.cpp 835\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nИнтересная ситуация. Давайте рассмотрим в начале вот это место:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"cpp\"\u003Ereturn ParseTypeIdEntry(SummaryID);\nbreak;\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nНа первый взгляд кажется, что ошибки здесь нет. Похоже, что оператор \u003Ci\u003Ebreak\u003C\u002Fi\u003E здесь лишний, и его можно просто удалить. Однако, не всё так просто.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nАнализатор выдаёт предупреждение на строчки:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"cpp\"\u003ELex.setIgnoreColonInIdentifiers(false);\nreturn false;\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nИ действительно, этот код недостижим. Все случаи в \u003Ci\u003Eswitch\u003C\u002Fi\u003E заканчиваются вызовом оператором \u003Ci\u003Ereturn\u003C\u002Fi\u003E. И теперь бессмысленный одинокий \u003Ci\u003Ebreak\u003C\u002Fi\u003E не выглядит таким безобидным! Быть может одна из веток должна заканчиваться на \u003Ci\u003Ebreak\u003C\u002Fi\u003E, а не на \u003Ci\u003Ereturn\u003C\u002Fi\u003E?\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cb\u003EФрагмент N33: Случайное обнуление старших бит\u003C\u002Fb\u003E\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"cpp\"\u003Eunsigned getStubAlignment() override {\n  if (Arch == Triple::systemz)\n    return 8;\n  else\n    return 1;\n}\n\nExpected&lt;unsigned\u003E\nRuntimeDyldImpl::emitSection(const ObjectFile &amp;Obj,\n                             const SectionRef &amp;Section,\n                             bool IsCode) {\n  ....\n  uint64_t DataSize = Section.getSize();\n  ....\n  if (StubBufSize \u003E 0)\n    DataSize &amp;= ~(getStubAlignment() - 1);\n  ....\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nПредупреждение PVS-Studio: \u003Ca href=\"https:\u002F\u002Fwww.viva64.com\u002Fru\u002Fw\u002Fv784\u002F\"\u003EV784\u003C\u002Fa\u003E The size of the bit mask is less than the size of the first operand. This will cause the loss of higher bits. RuntimeDyld.cpp 815\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nОбратите внимание, что функция \u003Ci\u003EgetStubAlignment\u003C\u002Fi\u003E возвращает тип \u003Ci\u003Eunsigned\u003C\u002Fi\u003E. Вычислим значение выражения, если предположить, что функция вернёт значение 8:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n~(getStubAlignment() — 1)\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n~(8u-1)\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n0xFFFFFFF8‬u\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nТеперь обратите внимание, что переменная \u003Ci\u003EDataSize\u003C\u002Fi\u003E имеет 64-битный беззнаковый тип. Получается, что при выполнении операции DataSize &amp; 0xFFFFFFF8‬u все тридцать два старших бита будут обнулены. Скорее всего, это не то, что хотел программист. Подозреваю, что он хотел вычислить: DataSize &amp; 0xFFFFFFFFFFFFFFF8‬u.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nЧтобы исправить ошибку, следует написать так:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"cpp\"\u003EDataSize &amp;= ~(static_cast&lt;uint64_t\u003E(getStubAlignment()) - 1);\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nИли так:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"cpp\"\u003EDataSize &amp;= ~(getStubAlignment() - 1ULL);\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003Cb\u003EФрагмент N34: Неудачное явное приведение типа\u003C\u002Fb\u003E\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"cpp\"\u003Etemplate &lt;typename T\u003E\nvoid scaleShuffleMask(int Scale, ArrayRef&lt;T\u003E Mask,\n                      SmallVectorImpl&lt;T\u003E &amp;ScaledMask) {\n  assert(0 &lt; Scale &amp;&amp; \"Unexpected scaling factor\");\n  int NumElts = Mask.size();\n  ScaledMask.assign(static_cast&lt;size_t\u003E(NumElts * Scale), -1);\n  ....\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nПредупреждение PVS-Studio: \u003Ca href=\"https:\u002F\u002Fwww.viva64.com\u002Fru\u002Fw\u002Fv1028\u002F\"\u003EV1028\u003C\u002Fa\u003E [CWE-190] Possible overflow. Consider casting operands of the 'NumElts * Scale' operator to the 'size_t' type, not the result. X86ISelLowering.h 1577\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nЯвное приведение типа используется для того, чтобы не возникло переполнение при перемножении переменных типа \u003Ci\u003Eint\u003C\u002Fi\u003E. Однако, здесь явное приведение типа не защищает от переполнения. В начале переменные будут перемножены, и только потом 32-битный результат умножения будет расширен до типа \u003Ca href=\"https:\u002F\u002Fwww.viva64.com\u002Fru\u002Ft\u002F0044\u002F\"\u003E\u003Ci\u003Esize_t\u003C\u002Fi\u003E\u003C\u002Fa\u003E.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cb\u003EФрагмент N35: Неудачный Copy-Paste\u003C\u002Fb\u003E\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"cpp\"\u003EInstruction *InstCombiner::visitFCmpInst(FCmpInst &amp;I) {\n  ....\n  if (!match(Op0, m_PosZeroFP()) &amp;&amp; isKnownNeverNaN(Op0, &amp;TLI)) {\n    I.setOperand(0, ConstantFP::getNullValue(Op0-\u003EgetType()));\n    return &amp;I;\n  }\n  if (!match(Op1, m_PosZeroFP()) &amp;&amp; isKnownNeverNaN(Op1, &amp;TLI)) {\n    I.setOperand(1, ConstantFP::getNullValue(Op0-\u003EgetType()));        \u002F\u002F &lt;=\n    return &amp;I;\n  }\n  ....\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003Ca href=\"https:\u002F\u002Fwww.viva64.com\u002Fru\u002Fw\u002Fv778\u002F\"\u003EV778\u003C\u002Fa\u003E [CWE-682] Two similar code fragments were found. Perhaps, this is a typo and 'Op1' variable should be used instead of 'Op0'. InstCombineCompares.cpp 5507\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nЭта новая интересная диагностика выявляет ситуации, когда фрагмент кода был скопирован, и в нём начали менять некоторые имена, но в одном месте не поправили.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nОбратите внимание, что во втором блоке меняли \u003Ci\u003EOp0\u003C\u002Fi\u003E на \u003Ci\u003EOp1\u003C\u002Fi\u003E. Но в одном месте не поправили. Скорее всего, должно было быть написано так:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"cpp\"\u003Eif (!match(Op1, m_PosZeroFP()) &amp;&amp; isKnownNeverNaN(Op1, &amp;TLI)) {\n  I.setOperand(1, ConstantFP::getNullValue(Op1-\u003EgetType()));\n  return &amp;I;\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003Cb\u003EФрагмент N36: Путаница в переменных\u003C\u002Fb\u003E\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"cpp\"\u003Estruct Status {\n  unsigned Mask;\n  unsigned Mode;\n\n  Status() : Mask(0), Mode(0){};\n\n  Status(unsigned Mask, unsigned Mode) : Mask(Mask), Mode(Mode) {\n    Mode &amp;= Mask;\n  };\n  ....\n};\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nПредупреждение PVS-Studio: \u003Ca href=\"https:\u002F\u002Fwww.viva64.com\u002Fru\u002Fw\u002Fv1001\u002F\"\u003EV1001\u003C\u002Fa\u003E [CWE-563] The 'Mode' variable is assigned but is not used by the end of the function. SIModeRegister.cpp 48\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nОчень опасно давать аргументам функций те же самые имена, что и членам класса. Очень легко запутаться. Перед нами как раз такой случай. Это выражение не имеет смысла:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"cpp\"\u003EMode &amp;= Mask;\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nМеняется аргумент функции. И всё. Этот аргумент больше никак не используется. Скорее всего, надо было написать так:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"cpp\"\u003EStatus(unsigned Mask, unsigned Mode) : Mask(Mask), Mode(Mode) {\n  this-\u003EMode &amp;= Mask;\n};\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003Cb\u003EФрагмент N37: Путаница в переменных\u003C\u002Fb\u003E\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"cpp\"\u003Eclass SectionBase {\n  ....\n  uint64_t Size = 0;\n  ....\n};\n\nclass SymbolTableSection : public SectionBase {\n  ....\n};\n\nvoid SymbolTableSection::addSymbol(Twine Name, uint8_t Bind, uint8_t Type,\n                                   SectionBase *DefinedIn, uint64_t Value,\n                                   uint8_t Visibility, uint16_t Shndx,\n                                   uint64_t Size) {\n  ....\n  Sym.Value = Value;\n  Sym.Visibility = Visibility;\n  Sym.Size = Size;\n  Sym.Index = Symbols.size();\n  Symbols.emplace_back(llvm::make_unique&lt;Symbol\u003E(Sym));\n  Size += this-\u003EEntrySize;\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nПредупреждение PVS-Studio: V1001 [CWE-563] The 'Size' variable is assigned but is not used by the end of the function. Object.cpp 424\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nСитуация аналогична предыдущей. Должно быть написано:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"cpp\"\u003Ethis-\u003ESize += this-\u003EEntrySize;\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003Cb\u003EФрагмент N38-N47: Указатель забыли проверить\u003C\u002Fb\u003E\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nРанее мы рассматривали примеры срабатывания диагностики \u003Ca href=\"https:\u002F\u002Fwww.viva64.com\u002Fru\u002Fw\u002Fv595\u002F\"\u003EV595\u003C\u002Fa\u003E. Её суть в том, что указатель в начале разыменовывается, а только потом проверяется. Молодая диагностика \u003Ca href=\"https:\u002F\u002Fwww.viva64.com\u002Fru\u002Fw\u002Fv1004\u002F\"\u003EV1004\u003C\u002Fa\u003E является обратной ей по смыслу, но также обнаруживает очень много ошибок. Она выявляет ситуации, когда указатель в начале проверяли, а затем забыли это сделать. Рассмотрим такие случаи, найденные внутри LLVM.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"cpp\"\u003Eint getGEPCost(Type *PointeeType, const Value *Ptr,\n               ArrayRef&lt;const Value *\u003E Operands) {\n  ....\n  if (Ptr != nullptr) {                                            \u002F\u002F &lt;=\n    assert(....);\n    BaseGV = dyn_cast&lt;GlobalValue\u003E(Ptr-\u003EstripPointerCasts());\n  }\n  bool HasBaseReg = (BaseGV == nullptr);\n\n  auto PtrSizeBits = DL.getPointerTypeSizeInBits(Ptr-\u003EgetType());  \u002F\u002F &lt;=\n  ....\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nПредупреждение PVS-Studio: V1004 [CWE-476] The 'Ptr' pointer was used unsafely after it was verified against nullptr. Check lines: 729, 738. TargetTransformInfoImpl.h 738\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nПеременная \u003Ci\u003EPtr \u003C\u002Fi\u003E может быть равна \u003Ci\u003Enullptr\u003C\u002Fi\u003E, о чём свидетельствует проверка:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"cpp\"\u003Eif (Ptr != nullptr)\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nОднако, ниже этот указатель разыменовывается уже без предварительной проверки:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"cpp\"\u003Eauto PtrSizeBits = DL.getPointerTypeSizeInBits(Ptr-\u003EgetType());\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nРассмотрим другой аналогичный случай.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"cpp\"\u003Ellvm::DISubprogram *CGDebugInfo::getFunctionFwdDeclOrStub(GlobalDecl GD,\n                                                          bool Stub) {\n  ....\n  auto *FD = dyn_cast&lt;FunctionDecl\u003E(GD.getDecl());\n  SmallVector&lt;QualType, 16\u003E ArgTypes;\n  if (FD)                                                                \u002F\u002F &lt;=\n    for (const ParmVarDecl *Parm : FD-\u003Eparameters())\n      ArgTypes.push_back(Parm-\u003EgetType());\n  CallingConv CC = FD-\u003EgetType()-\u003EcastAs&lt;FunctionType\u003E()-\u003EgetCallConv(); \u002F\u002F &lt;=\n  ....\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nПредупреждение PVS-Studio: V1004 [CWE-476] The 'FD' pointer was used unsafely after it was verified against nullptr. Check lines: 3228, 3231. CGDebugInfo.cpp 3231\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nОбратите внимание на указатель \u003Ci\u003EFD\u003C\u002Fi\u003E. Уверен, проблема хорошо видна, и специальных пояснений не требуется.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nИ ещё:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"cpp\"\u003Estatic void computePolynomialFromPointer(Value &amp;Ptr, Polynomial &amp;Result,\n                                         Value *&amp;BasePtr,\n                                         const DataLayout &amp;DL) {\n  PointerType *PtrTy = dyn_cast&lt;PointerType\u003E(Ptr.getType());\n  if (!PtrTy) {                                                   \u002F\u002F &lt;=\n    Result = Polynomial();\n    BasePtr = nullptr;\n  }\n  unsigned PointerBits =\n      DL.getIndexSizeInBits(PtrTy-\u003EgetPointerAddressSpace());     \u002F\u002F &lt;=\n  ....\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nПредупреждение PVS-Studio: V1004 [CWE-476] The 'PtrTy' pointer was used unsafely after it was verified against nullptr. Check lines: 960, 965. InterleavedLoadCombinePass.cpp 965\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nКак защититься от таких ошибок? Будьте внимательней на Code-Review и используйте для регулярной проверки кода статический анализатор PVS-Studio.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nПриводить другие фрагменты кода с ошибками данного вида смысла нет. Оставлю в статье только список предупреждений:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cul\u003E\r\n\u003Cli\u003EV1004 [CWE-476] The 'Expr' pointer was used unsafely after it was verified against nullptr. Check lines: 1049, 1078. DebugInfoMetadata.cpp 1078\u003C\u002Fli\u003E\r\n\u003Cli\u003EV1004 [CWE-476] The 'PI' pointer was used unsafely after it was verified against nullptr. Check lines: 733, 753. LegacyPassManager.cpp 753\u003C\u002Fli\u003E\r\n\u003Cli\u003EV1004 [CWE-476] The 'StatepointCall' pointer was used unsafely after it was verified against nullptr. Check lines: 4371, 4379. Verifier.cpp 4379\u003C\u002Fli\u003E\r\n\u003Cli\u003EV1004 [CWE-476] The 'RV' pointer was used unsafely after it was verified against nullptr. Check lines: 2263, 2268. TGParser.cpp 2268\u003C\u002Fli\u003E\r\n\u003Cli\u003EV1004 [CWE-476] The 'CalleeFn' pointer was used unsafely after it was verified against nullptr. Check lines: 1081, 1096. SimplifyLibCalls.cpp 1096\u003C\u002Fli\u003E\r\n\u003Cli\u003EV1004 [CWE-476] The 'TC' pointer was used unsafely after it was verified against nullptr. Check lines: 1819, 1824. Driver.cpp 1824\u003C\u002Fli\u003E\r\n\u003C\u002Ful\u003E\u003Cbr\u002F\u003E\r\n\u003Cb\u003EФрагмент N48-N60: Не критично, но дефект (возможна утечка памяти)\u003C\u002Fb\u003E\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"cpp\"\u003Estd::unique_ptr&lt;IRMutator\u003E createISelMutator() {\n  ....\n  std::vector&lt;std::unique_ptr&lt;IRMutationStrategy\u003E\u003E Strategies;\n  Strategies.emplace_back(\n      new InjectorIRStrategy(InjectorIRStrategy::getDefaultOps()));\n  ....\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nПредупреждение PVS-Studio: \u003Ca href=\"https:\u002F\u002Fwww.viva64.com\u002Fru\u002Fw\u002Fv1023\u002F\"\u003EV1023\u003C\u002Fa\u003E [CWE-460] A pointer without owner is added to the 'Strategies' container by the 'emplace_back' method. A memory leak will occur in case of an exception. llvm-isel-fuzzer.cpp 58\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nДля добавлении элемента в конец контейнера типа \u003Ci\u003Estd::vector&lt;std::unique_ptr&lt;X\u003E\u003E\u003C\u002Fi\u003E нельзя просто написать \u003Ci\u003Exxx.push_back(new X)\u003C\u002Fi\u003E, так как нет неявного преобразования из \u003Ci\u003EX*\u003C\u002Fi\u003E в \u003Ci\u003Estd::unique_ptr&lt;X\u003E\u003C\u002Fi\u003E.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nРаспространенным решением является написание \u003Ci\u003Exxx.emplace_back(new X)\u003C\u002Fi\u003E, так как он компилируется: метод \u003Ci\u003Eemplace_back\u003C\u002Fi\u003E конструирует элемент непосредственно из аргументов и поэтому может использовать явные конструкторы.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nЭто небезопасно. Если вектор полон, то происходит перевыделение памяти. Операция перевыделения памяти может закончиться неудачей, в результате чего будет сгенерировано исключение \u003Ci\u003Estd::bad_alloc\u003C\u002Fi\u003E. В этом случае указатель будет потерян, и созданный объект никогда не будет удален.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nБезопасным решением является создание \u003Ci\u003Eunique_ptr\u003C\u002Fi\u003E, который будет владеть указателем до того, как вектор попытается перевыделить память:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"cpp\"\u003Exxx.push_back(std::unique_ptr&lt;X\u003E(new X))\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nНачиная с C++14, можно использовать 'std::make_unique':\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"cpp\"\u003Exxx.push_back(std::make_unique&lt;X\u003E())\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nДанный вид дефекта не критичен для LLVM. Если не удастся выделить память, то работа компилятора будет просто остановлена. Однако, для приложений с долгим \u003Ca href=\"https:\u002F\u002Fru.wikipedia.org\u002Fwiki\u002F%D0%90%D0%BF%D1%82%D0%B0%D0%B9%D0%BC\"\u003Eаптаймом\u003C\u002Fa\u003E, которые не могут просто так завершаться, если не удалось выделить память, это может быть настоящей неприятной ошибкой.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nИтак, хотя данный код не представляет практической опасности для LLVM, я посчитал полезным рассказать о данном паттерне ошибок и что анализатор PVS-Studio научился его выявлять.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nДругие предупреждения данного типа:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cul\u003E\r\n\u003Cli\u003EV1023 [CWE-460] A pointer without owner is added to the 'Passes' container by the 'emplace_back' method. A memory leak will occur in case of an exception. PassManager.h 546\u003C\u002Fli\u003E\r\n\u003Cli\u003EV1023 [CWE-460] A pointer without owner is added to the 'AAs' container by the 'emplace_back' method. A memory leak will occur in case of an exception. AliasAnalysis.h 324\u003C\u002Fli\u003E\r\n\u003Cli\u003EV1023 [CWE-460] A pointer without owner is added to the 'Entries' container by the 'emplace_back' method. A memory leak will occur in case of an exception. DWARFDebugFrame.cpp 519\u003C\u002Fli\u003E\r\n\u003Cli\u003EV1023 [CWE-460] A pointer without owner is added to the 'AllEdges' container by the 'emplace_back' method. A memory leak will occur in case of an exception. CFGMST.h 268\u003C\u002Fli\u003E\r\n\u003Cli\u003EV1023 [CWE-460] A pointer without owner is added to the 'VMaps' container by the 'emplace_back' method. A memory leak will occur in case of an exception. SimpleLoopUnswitch.cpp 2012\u003C\u002Fli\u003E\r\n\u003Cli\u003EV1023 [CWE-460] A pointer without owner is added to the 'Records' container by the 'emplace_back' method. A memory leak will occur in case of an exception. FDRLogBuilder.h 30\u003C\u002Fli\u003E\r\n\u003Cli\u003EV1023 [CWE-460] A pointer without owner is added to the 'PendingSubmodules' container by the 'emplace_back' method. A memory leak will occur in case of an exception. ModuleMap.cpp 810\u003C\u002Fli\u003E\r\n\u003Cli\u003EV1023 [CWE-460] A pointer without owner is added to the 'Objects' container by the 'emplace_back' method. A memory leak will occur in case of an exception. DebugMap.cpp 88\u003C\u002Fli\u003E\r\n\u003Cli\u003EV1023 [CWE-460] A pointer without owner is added to the 'Strategies' container by the 'emplace_back' method. A memory leak will occur in case of an exception. llvm-isel-fuzzer.cpp 60\u003C\u002Fli\u003E\r\n\u003Cli\u003EV1023 [CWE-460] A pointer without owner is added to the 'Modifiers' container by the 'emplace_back' method. A memory leak will occur in case of an exception. llvm-stress.cpp 685\u003C\u002Fli\u003E\r\n\u003Cli\u003EV1023 [CWE-460] A pointer without owner is added to the 'Modifiers' container by the 'emplace_back' method. A memory leak will occur in case of an exception. llvm-stress.cpp 686\u003C\u002Fli\u003E\r\n\u003Cli\u003EV1023 [CWE-460] A pointer without owner is added to the 'Modifiers' container by the 'emplace_back' method. A memory leak will occur in case of an exception. llvm-stress.cpp 688\u003C\u002Fli\u003E\r\n\u003Cli\u003EV1023 [CWE-460] A pointer without owner is added to the 'Modifiers' container by the 'emplace_back' method. A memory leak will occur in case of an exception. llvm-stress.cpp 689\u003C\u002Fli\u003E\r\n\u003Cli\u003EV1023 [CWE-460] A pointer without owner is added to the 'Modifiers' container by the 'emplace_back' method. A memory leak will occur in case of an exception. llvm-stress.cpp 690\u003C\u002Fli\u003E\r\n\u003Cli\u003EV1023 [CWE-460] A pointer without owner is added to the 'Modifiers' container by the 'emplace_back' method. A memory leak will occur in case of an exception. llvm-stress.cpp 691\u003C\u002Fli\u003E\r\n\u003Cli\u003EV1023 [CWE-460] A pointer without owner is added to the 'Modifiers' container by the 'emplace_back' method. A memory leak will occur in case of an exception. llvm-stress.cpp 692\u003C\u002Fli\u003E\r\n\u003Cli\u003EV1023 [CWE-460] A pointer without owner is added to the 'Modifiers' container by the 'emplace_back' method. A memory leak will occur in case of an exception. llvm-stress.cpp 693\u003C\u002Fli\u003E\r\n\u003Cli\u003EV1023 [CWE-460] A pointer without owner is added to the 'Modifiers' container by the 'emplace_back' method. A memory leak will occur in case of an exception. llvm-stress.cpp 694\u003C\u002Fli\u003E\r\n\u003Cli\u003EV1023 [CWE-460] A pointer without owner is added to the 'Operands' container by the 'emplace_back' method. A memory leak will occur in case of an exception. GlobalISelEmitter.cpp 1911\u003C\u002Fli\u003E\r\n\u003Cli\u003EV1023 [CWE-460] A pointer without owner is added to the 'Stash' container by the 'emplace_back' method. A memory leak will occur in case of an exception. GlobalISelEmitter.cpp 2100\u003C\u002Fli\u003E\r\n\u003Cli\u003EV1023 [CWE-460] A pointer without owner is added to the 'Matchers' container by the 'emplace_back' method. A memory leak will occur in case of an exception. GlobalISelEmitter.cpp 2702\u003C\u002Fli\u003E\r\n\u003C\u002Ful\u003E\u003Cbr\u002F\u003E\r\n\u003Ch2\u003EЗаключение\u003C\u002Fh2\u003E\u003Cbr\u002F\u003E\r\nВсего я выписал 60 предупреждений, после чего остановился. Есть ли другие дефекты, которые обнаруживает в LLVM анализатор PVS-Studio? Да, есть. Однако, когда я выписывал фрагменты кода для статьи, наступил поздний вечер, вернее, даже ночь, и я решил, что пора закругляться.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nНадеюсь, вам было интересно, и вы захотите попробовать анализатор PVS-Studio.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nВы можете скачать анализатор и получить триальный ключ на \u003Ca href=\"https:\u002F\u002Fwww.viva64.com\u002Fru\u002Fpvs-studio-download\u002F\"\u003Eэтой странице\u003C\u002Fa\u003E.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nСамое главное, используйте статический анализ регулярно. \u003Cb\u003EРазовые проверки\u003C\u002Fb\u003E, выполняемыми нами с целью популяризации методологии статического анализа и PVS-Studio не являются нормальным сценарием.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nУдачи в улучшении качества и надёжности кода!\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cp\u003E\u003Ca href=\"https:\u002F\u002Fhabr.com\u002Fen\u002Fcompany\u002Fpvs-studio\u002Fblog\u002F450002\u002F\"\u003E\u003Cimg src=\"\u002Fimg\u002Fimage-loader.svg\" align=\"left\" data-src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fpost_images\u002Fc78\u002F30f\u002F70c\u002Fc7830f70c5577c3d6704f254d7cad6a3.png\"\u002F\u003E\u003C\u002Fa\u003E\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nЕсли хотите поделиться этой статьей с англоязычной аудиторией, то прошу использовать ссылку на перевод: Andrey Karpov. \u003Ca href=\"https:\u002F\u002Fhabr.com\u002Fen\u002Fcompany\u002Fpvs-studio\u002Fblog\u002F450002\u002F\"\u003EFinding Bugs in LLVM 8 with PVS-Studio\u003C\u002Fa\u003E.\u003C\u002Fdiv\u003E","tags":[{"titleHtml":"c++"},{"titleHtml":"clang"},{"titleHtml":"llvm"},{"titleHtml":"compiler"},{"titleHtml":"pvs-studio"},{"titleHtml":"open source"},{"titleHtml":"devops"},{"titleHtml":"bugs"},{"titleHtml":"баги"},{"titleHtml":"компиляторы"},{"titleHtml":"качество кода"},{"titleHtml":"статический анализ кода"}],"metadata":{"stylesUrls":[],"scriptUrls":[],"shareImageUrl":"https:\u002F\u002Fhabr.com\u002Fshare\u002Fpublication\u002F450008\u002F63d71ef8c5bfaaa3818dde5b3df1c543\u002F","shareImageWidth":1200,"shareImageHeight":630,"vkShareImageUrl":"https:\u002F\u002Fhabr.com\u002Fshare\u002Fpublication\u002F450008\u002F63d71ef8c5bfaaa3818dde5b3df1c543\u002F?format=vk","schemaJsonLd":"{\"@context\":\"http:\\\u002F\\\u002Fschema.org\",\"@type\":\"Article\",\"mainEntityOfPage\":{\"@type\":\"WebPage\",\"@id\":\"https:\\\u002F\\\u002Fhabr.com\\\u002Fru\\\u002Fcompany\\\u002Fpvs-studio\\\u002Fblog\\\u002F450008\\\u002F\"},\"headline\":\"﻿Находим баги в LLVM 8 с помощью анализатора PVS-Studio\",\"datePublished\":\"2019-04-29T16:52:32+03:00\",\"dateModified\":\"2019-04-30T00:31:49+03:00\",\"author\":{\"@type\":\"Person\",\"name\":\"Andrey Karpov\"},\"publisher\":{\"@type\":\"Organization\",\"name\":\"Habr\",\"logo\":{\"@type\":\"ImageObject\",\"url\":\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fwebt\\\u002Fa_\\\u002Flk\\\u002F9m\\\u002Fa_lk9mjkccjox-zccjrpfolmkmq.png\"}},\"description\":\"Прошло более двух лет с момента последней проверки кода проекта LLVM с помощью нашего анализатора PVS-Studio. Давайте убедимся, что анализатор PVS-Studio по-пре...\",\"url\":\"https:\\\u002F\\\u002Fhabr.com\\\u002Fru\\\u002Fcompany\\\u002Fpvs-studio\\\u002Fblog\\\u002F450008\\\u002F#post-content-body\",\"about\":[\"c_pvs-studio\",\"h_open_source\",\"h_cpp\",\"h_compilers\",\"h_devops\",\"f_develop\",\"f_admin\"],\"image\":[\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fpost_images\\\u002F2f2\\\u002F8d4\\\u002F5bf\\\u002F2f28d45bf369270d9330bfbe2ea78f00.png\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fpost_images\\\u002Fd5d\\\u002F183\\\u002Fd4e\\\u002Fd5d183d4e2d3107bc512e52d893fda25.png\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fpost_images\\\u002F8a2\\\u002Ff86\\\u002F58f\\\u002F8a2f8658fdacb0dde918807666d1cd39.png\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fpost_images\\\u002Fc78\\\u002F30f\\\u002F70c\\\u002Fc7830f70c5577c3d6704f254d7cad6a3.png\"]}","metaDescription":"Прошло более двух лет с момента последней проверки кода проекта LLVM с помощью нашего анализатора PVS-Studio. Давайте убедимся, что анализатор PVS-Studio по-прежнему является лидирующим инструментом...","mainImageUrl":null,"amp":false},"polls":[],"commentsEnabled":true,"rulesRemindEnabled":false,"votesEnabled":true,"status":"published","plannedPublishTime":null,"checked":null,"isEditorial":false}},"articlesIds":{},"isLoading":false,"pagesCount":{},"route":{},"reasonsList":null,"view":"cards","lastVisitedRoute":{},"ssrCommentsArticleIds":[""],"karma":{}},"authorContribution":{"authors":{}},"betaTest":{"currentAnnouncement":null,"announcements":{},"announcementCards":null,"announcementComments":{},"announcementCommentThreads":{},"announcementCommentingStatuses":{},"archivedList":[]},"authorStatistics":{"articleRefs":{},"articleIds":{},"pagesCount":{},"route":{},"viewsCount":[],"maxStatsCount":{}},"career":{"seoLandings":[],"hubs":""},"comments":{"articleComments":{},"searchCommentsResults":null,"previewComment":null,"pagesCount":null,"commentAccess":{},"scrollParents":{},"pageArticleComments":{"lastViewedComment":0,"postId":null,"lastCommentTimestamp":"","moderated":[],"moderatedIds":[],"commentRoute":""}},"companies":{"companyRefs":{"pvs-studio":{"alias":"pvs-studio","imageUrl":"\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fcompany\u002F95a\u002F244\u002F327\u002F95a244327fc36477b6048c0f8b67df8b.png","titleHtml":"PVS-Studio","descriptionHtml":"Статический анализ кода для C, C++, C# и Java","relatedData":null,"statistics":{"postsCount":640,"newsCount":0,"vacanciesCount":0,"employeesCount":32,"careerRating":null,"subscribersCount":22691,"rating":256.33,"invest":null},"foundationDate":{"year":"2008","month":null,"day":null},"location":{"city":{"id":"448142","title":"Тула"},"region":{"id":"2013","title":"Тульская обл."},"country":{"id":"168","title":"Россия"}},"siteUrl":"https:\u002F\u002Fpvs-studio.com\u002F","staffNumber":"31–50 человек","registrationDate":"2013-05-06T12:33:02+00:00","representativeUser":null,"contacts":[{"title":"Сайт","url":"https:\u002F\u002Fpvs-studio.com\u002F"},{"title":"Facebook","url":"https:\u002F\u002Ffacebook.com\u002FStaticCodeAnalyzer"},{"title":"Twitter","url":"https:\u002F\u002Ftwitter.com\u002FCode_Analysis"},{"title":"Instagram","url":"https:\u002F\u002Finstagram.com\u002Fpvsstudio_rus"},{"title":"Telegram","url":"https:\u002F\u002Ftelegram.me\u002Fpvsstudio_rus"}],"settings":{"analyticsSettings":[{"type":"ga","trackingId":"UA-58546680-1"}],"branding":null,"status":"active"},"metadata":{"titleHtml":"PVS-Studio, Тула - Статический анализ кода для C, C++, C# и Java с 2008 год","title":"PVS-Studio, Тула - Статический анализ кода для C, C++, C# и Java с 2008 год","keywords":["C++","C#",".NET","Open source","Информационная безопасность"],"descriptionHtml":"640 статей от авторов компании PVS-Studio","description":"640 статей от авторов компании PVS-Studio"},"aDeskSettings":null,"careerAlias":null,"maxCustomTrackerLinks":0}},"companyIds":{},"companyTopIds":{},"pagesCount":{},"companyProfiles":{},"companiesCategories":[],"companiesCategoriesTotalCount":0,"companiesWidgets":{},"companiesWorkers":{},"companiesFans":{},"route":{},"isLoading":false,"companyWorkersLoading":false,"companyFansLoading":false,"vacancies":{}},"companiesContribution":{"hubs":{},"flows":{},"companyRefs":{}},"companyHubsContribution":{"contributionRefs":{"hubRefs":{},"hubIds":{}}},"conversation":{"messages":[],"respondent":null,"isLoadMore":false},"conversations":{"conversations":[],"unreadCount":0,"pagesCount":0,"isLoadMore":false},"desktopState":{"desktopFl":null,"desktopHl":null,"isChecked":false,"isLoginDemanded":false},"dfp":{"slotsDict":{}},"docs":{"menu":{},"articles":{},"mainMenu":[],"loading":{"main":false,"dropdown":false,"article":false}},"feature":{"isProbablyVisible":"true"},"flows":{"flows":[{"alias":"develop","id":1,"route":{"name":"FLOW_PAGE","params":{"flowName":"develop"}}},{"alias":"admin","id":6,"route":{"name":"FLOW_PAGE","params":{"flowName":"admin"}}},{"alias":"design","id":2,"route":{"name":"FLOW_PAGE","params":{"flowName":"design"}}},{"alias":"management","id":3,"route":{"name":"FLOW_PAGE","params":{"flowName":"management"}}},{"alias":"marketing","id":4,"route":{"name":"FLOW_PAGE","params":{"flowName":"marketing"}}},{"alias":"popsci","id":7,"route":{"name":"FLOW_PAGE","params":{"flowName":"popsci"}}}]},"global":{"isPwa":false,"device":"desktop","isHabrCom":true},"hubs":{"hubRefs":{},"hubIds":{},"pagesCount":{},"isLoading":false,"route":{}},"hubsBlock":{"hubRefs":{},"hubIds":{}},"i18n":{"fl":"ru","hl":"ru"},"info":{"infoPage":{},"isLoading":true},"location":{"urlStruct":{"protocol":null,"slashes":null,"auth":null,"host":null,"port":null,"hostname":null,"hash":null,"search":null,"query":{},"pathname":null,"path":null,"href":""},"searchQuery":null},"me":{"user":null,"ppgDemanded":false,"karmaResetInfo":{"canReincarnate":null,"wasReincarnated":null,"currentScore":null},"notes":null},"mostReadingList":{"mostReadingListIds":[],"mostReadingListRefs":null,"promoPost":null},"pinnedPost":{"pinnedPost":null},"ppa":{"articles":{},"card":null,"transactions":null,"totalTransactions":null,"isAccessible":null},"projectsBlocks":{"activeBlocks":{}},"pullRefresh":{"shouldRefresh":false},"sandbox":{"articleIds":[],"articleRefs":{},"pagesCount":null,"route":{},"lastVisitedRoute":{},"isLoading":false},"settingsOther":{"inputs":{"uiLang":{"errors":[],"ref":null,"value":""},"articlesLangEnglish":{"errors":[],"ref":null,"value":false},"articlesLangRussian":{"errors":[],"ref":null,"value":false},"agreement":{"errors":[],"ref":null,"value":false},"email":{"errors":[],"ref":null,"value":true},"digest":{"errors":[],"ref":null,"value":true}}},"similarList":{"similarListIds":[],"similarListRefs":null},"ssr":{"error":null,"isDataLoaded":false,"isDataLoading":false,"isHydrationFailed":false,"isServer":false},"userHubsContribution":{"contributionRefs":{"hubRefs":{},"hubIds":{}}},"userInvites":{"availableInvites":0,"usedInvitesIds":[],"usedInvitesRefs":{},"usedInvitesPagesCount":0,"unusedInvitesIds":[],"unusedInvitesRefs":{},"unusedInvitesPagesCount":0},"users":{"authorRefs":{},"authorIds":{},"pagesCount":{},"authorProfiles":{},"userHubs":{},"userInvitations":{},"authorFollowers":{},"authorFollowed":{},"karmaStats":[],"statistics":null,"isLoading":false,"authorFollowersLoading":false,"authorFollowedLoading":false,"userHubsLoading":false,"userInvitationsLoading":false,"route":{}},"viewport":{"prevScrollY":{},"scrollY":0,"width":0},"tracker":{"items":{},"pagesCache":{},"markedViewedSilently":{},"markedRead":{},"unreadCounters":{"applications":null,"system":null,"mentions":null,"subscribers":null,"posts_and_comments":null},"unviewedCounters":{"applications":null,"system":null,"mentions":null,"subscribers":null,"posts_and_comments":null}}};(function(){var s;(s=document.currentScript||document.scripts[document.scripts.length-1]).parentNode.removeChild(s);}());</script>
<script src="https://assets.habr.com/habr-web/js/chunk-vendors.c2c3fc9a.js" defer></script><script src="https://assets.habr.com/habr-web/js/app.c0af73e7.js" defer></script>



    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
        (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
        m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
    </script>
  
  <script type="text/javascript" >
    (function(m,e,t,r,i,k,a){m[i]=m[i]||function(){(m[i].a=m[i].a||[]).push(arguments)};
    m[i].l=1*new Date();k=e.createElement(t),a=e.getElementsByTagName(t)[0],k.async=1,k.src=r,a.parentNode.insertBefore(k,a)})
    (window, document, "script", "https://mc.yandex.ru/metrika/tag.js", "ym");

    ym(24049213, "init", {
      defer:true,
      trackLinks:true,
      accurateTrackBounce:true,
      webvisor:false,
    });
  </script>
  <noscript>
    <div>
      <img src="https://mc.yandex.ru/watch/24049213" style="position:absolute; left:-9999px;" alt="" />
    </div>
  </noscript>
  
    <script type="text/javascript">
      window.addEventListener('load', function () {
        setTimeout(() => {
          const img = new Image();
          img.src = 'https://vk.com/rtrg?p=VK-RTRG-421343-57vKE';
        }, 0);
      });
    </script>
  
</body>
</html>
