<!DOCTYPE html>
<html lang="ru" data-vue-meta="%7B%22lang%22:%7B%22ssr%22:%22ru%22%7D%7D">
<head >
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width,initial-scale=1.0,viewport-fit=cover">
  <title>Архитектура SPA-приложения биржи в 2019 году / Хабр</title>
  <style>
    /* cyrillic-ext */
    @font-face {
      font-family: 'Fira Sans';
      font-style: normal;
      font-weight: 500;
      font-display: swap;
      src: url(https://fonts.gstatic.com/s/firasans/v11/va9B4kDNxMZdWfMOD5VnZKveSxf6TF0.woff2) format('woff2');
      unicode-range: U+0460-052F, U+1C80-1C88, U+20B4, U+2DE0-2DFF, U+A640-A69F, U+FE2E-FE2F;
    }

    /* cyrillic */
    @font-face {
      font-family: 'Fira Sans';
      font-style: normal;
      font-weight: 500;
      font-display: swap;
      src: url(https://fonts.gstatic.com/s/firasans/v11/va9B4kDNxMZdWfMOD5VnZKveQhf6TF0.woff2) format('woff2');
      unicode-range: U+0400-045F, U+0490-0491, U+04B0-04B1, U+2116;
    }

    /* latin-ext */
    @font-face {
      font-family: 'Fira Sans';
      font-style: normal;
      font-weight: 500;
      font-display: swap;
      src: url(https://fonts.gstatic.com/s/firasans/v11/va9B4kDNxMZdWfMOD5VnZKveSBf6TF0.woff2) format('woff2');
      unicode-range: U+0100-024F, U+0259, U+1E00-1EFF, U+2020, U+20A0-20AB, U+20AD-20CF, U+2113, U+2C60-2C7F, U+A720-A7FF;
    }

    /* latin */
    @font-face {
      font-family: 'Fira Sans';
      font-style: normal;
      font-weight: 500;
      font-display: swap;
      src: url(https://fonts.gstatic.com/s/firasans/v11/va9B4kDNxMZdWfMOD5VnZKveRhf6.woff2) format('woff2');
      unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2122, U+2191, U+2193, U+2212, U+2215, U+FEFF, U+FFFD;
    }
  </style>
  <link rel="preload" href="https://assets.habr.com/habr-web/css/chunk-vendors.e7843cc0.css" as="style"><link rel="preload" href="https://assets.habr.com/habr-web/js/chunk-vendors.c2c3fc9a.js" as="script"><link rel="preload" href="https://assets.habr.com/habr-web/css/app.02ee25a4.css" as="style"><link rel="preload" href="https://assets.habr.com/habr-web/js/app.c0af73e7.js" as="script">
  <link rel="stylesheet" href="https://assets.habr.com/habr-web/css/chunk-vendors.e7843cc0.css"><link rel="stylesheet" href="https://assets.habr.com/habr-web/css/app.02ee25a4.css">
  <script>window.i18nFetch = new Promise((res, rej) => {
          const xhr = new XMLHttpRequest();
          xhr.open('GET', '/js/i18n/ru-compiled.85eb77f0b17c8235e7b64b9f81ea5ec2.json');
          xhr.responseType = 'json';
          xhr.onload = function(e) {
            if (this.status === 200) {
              res({ru: xhr.response});
            } else {
              rej(e);
            }
          };
          xhr.send();
        });</script>
  
  <script data-vue-meta="ssr" src="/js/ads.js" onload="window['zhY4i4nJ9K'] = true" data-vmid="checkad"></script><script data-vue-meta="ssr" type="application/ld+json" data-vmid="ldjson-schema">{"@context":"http:\/\/schema.org","@type":"Article","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/habr.com\/ru\/post\/450360\/"},"headline":"Архитектура SPA-приложения биржи в 2019 году","datePublished":"2019-05-02T22:27:53+03:00","dateModified":"2020-06-19T13:21:49+03:00","author":{"@type":"Person","name":"Дмитрий Казаков"},"publisher":{"@type":"Organization","name":"Habr","logo":{"@type":"ImageObject","url":"https:\/\/habrastorage.org\/webt\/a_\/lk\/9m\/a_lk9mjkccjox-zccjrpfolmkmq.png"}},"description":"Приветствую, хабровчане! Читаю данный ресурс со времени основания, но время на написание статьи появилось только сейчас, а значит пора поделиться своим опытом с...","url":"https:\/\/habr.com\/ru\/post\/450360\/#post-content-body","about":["h_webdev","h_javascript","h_reactjs","f_develop"],"image":["https:\/\/habrastorage.org\/webt\/py\/b5\/jf\/pyb5jfs2g07r-ypnnkoudkdxe7s.png","https:\/\/habrastorage.org\/webt\/mk\/7y\/8s\/mk7y8sh2cushkehhykrrufsvkre.png","https:\/\/habrastorage.org\/webt\/p6\/im\/fk\/p6imfkqh0-lf8zlr2apy_8zjqcm.png","https:\/\/habrastorage.org\/webt\/im\/jn\/_l\/imjn_lzweyq7yijk7ohnlafcpgo.png"]}</script>
  <script src="//www.googletagservices.com/tag/js/gpt.js" async></script>
  <style>.grecaptcha-badge{visibility: hidden;}</style>
  <meta name="habr-version" content="2.49.0">
  
  <meta data-vue-meta="ssr" property="fb:app_id" content="444736788986613"><meta data-vue-meta="ssr" property="fb:pages" content="472597926099084"><meta data-vue-meta="ssr" name="twitter:card" content="summary_large_image"><meta data-vue-meta="ssr" name="twitter:site" content="@habr_eng"><meta data-vue-meta="ssr" property="og:title" content="Архитектура SPA-приложения биржи в 2019 году" data-vmid="og:title"><meta data-vue-meta="ssr" name="twitter:title" content="Архитектура SPA-приложения биржи в 2019 году" data-vmid="twitter:title"><meta data-vue-meta="ssr" name="aiturec:title" content="Архитектура SPA-приложения биржи в 2019 году" data-vmid="aiturec:title"><meta data-vue-meta="ssr" name="description" content="Приветствую, хабровчане!
Читаю данный ресурс со времени основания, но время на написание статьи появилось только сейчас, а значит пора поделиться своим опытом с сообществом. Начинающим разработчикам,..." data-vmid="description"><meta data-vue-meta="ssr" itemprop="description" content="Приветствую, хабровчане!
Читаю данный ресурс со времени основания, но время на написание статьи появилось только сейчас, а значит пора поделиться своим опытом с сообществом. Начинающим разработчикам,..." data-vmid="description:itemprop"><meta data-vue-meta="ssr" property="og:description" content="Приветствую, хабровчане!
Читаю данный ресурс со времени основания, но время на написание статьи появилось только сейчас, а значит пора поделиться своим опытом с сообществом. Начинающим разработчикам,..." data-vmid="og:description"><meta data-vue-meta="ssr" name="twitter:description" content="Приветствую, хабровчане!
Читаю данный ресурс со времени основания, но время на написание статьи появилось только сейчас, а значит пора поделиться своим опытом с сообществом. Начинающим разработчикам,..." data-vmid="twitter:description"><meta data-vue-meta="ssr" property="aiturec:description" content="Приветствую, хабровчане!
Читаю данный ресурс со времени основания, но время на написание статьи появилось только сейчас, а значит пора поделиться своим опытом с сообществом. Начинающим разработчикам,..." data-vmid="aiturec:description"><meta data-vue-meta="ssr" itemprop="image" content="https://habr.com/share/publication/450360/0144674fee64238036a0c969749ef698/" data-vmid="image:itemprop"><meta data-vue-meta="ssr" property="og:image" content="https://habr.com/share/publication/450360/0144674fee64238036a0c969749ef698/" data-vmid="og:image"><meta data-vue-meta="ssr" property="aiturec:image" content="https://habr.com/share/publication/450360/0144674fee64238036a0c969749ef698/" data-vmid="aiturec:image"><meta data-vue-meta="ssr" name="twitter:image" content="https://habr.com/share/publication/450360/0144674fee64238036a0c969749ef698/" data-vmid="twitter:image"><meta data-vue-meta="ssr" property="vk:image" content="https://habr.com/share/publication/450360/0144674fee64238036a0c969749ef698/" data-vmid="vk:image"><meta data-vue-meta="ssr" property="aiturec:item_id" content="450360" data-vmid="aiturec:item_id"><meta data-vue-meta="ssr" property="aiturec:datetime" content="2019-05-02T19:27:53.000Z" data-vmid="aiturec:datetime"><meta data-vue-meta="ssr" property="og:type" content="article" data-vmid="og:type"><meta data-vue-meta="ssr" property="og:locale" content="ru_RU" data-vmid="og:locale"><meta data-vue-meta="ssr" property="og:image:width" content="1200" data-vmid="og:image:width"><meta data-vue-meta="ssr" property="og:image:height" content="630" data-vmid="og:image:height">
  <link data-vue-meta="ssr" href="https://habr.com/ru/rss/post/450360/?fl=ru" type="application/rss+xml" title="" rel="alternate" name="rss"><link data-vue-meta="ssr" href="https://habr.com/ru/post/450360/" rel="canonical" data-vmid="canonical"><link data-vue-meta="ssr" data-vmid="hreflang"><link data-vue-meta="ssr" image_src="image" href="https://habr.com/share/publication/450360/0144674fee64238036a0c969749ef698/" data-vmid="image:href">
  <meta name="apple-mobile-web-app-status-bar-style" content="#303b44">
  <meta name="msapplication-TileColor" content="#629FBC">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="mobile-web-app-capable" content="yes">
  <link
    rel="shortcut icon"
    type="image/png"
    sizes="16x16"
    href="https://assets.habr.com/habr-web/img/favicons/favicon-16.png"
  >
  <link
    rel="shortcut icon"
    type="image/png"
    sizes="32x32"
    href="https://assets.habr.com/habr-web/img/favicons/favicon-32.png"
  >
  <link
    rel="apple-touch-icon"
    type="image/png"
    sizes="76x76"
    href="https://assets.habr.com/habr-web/img/favicons/apple-touch-icon-76.png"
  >
  <link
    rel="apple-touch-icon"
    type="image/png"
    sizes="120x120"
    href="https://assets.habr.com/habr-web/img/favicons/apple-touch-icon-120.png"
  >
  <link
    rel="apple-touch-icon"
    type="image/png"
    sizes="152x152"
    href="https://assets.habr.com/habr-web/img/favicons/apple-touch-icon-152.png"
  >
  <link
    rel="apple-touch-icon"
    type="image/png"
    sizes="180x180"
    href="https://assets.habr.com/habr-web/img/favicons/apple-touch-icon-180.png"
  >
  <link
    rel="apple-touch-icon"
    type="image/png"
    sizes="256x256"
    href="https://assets.habr.com/habr-web/img/favicons/apple-touch-icon-256.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 320px) and (device-height: 568px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1136x640.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 375px) and (device-height: 812px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_2436x1125.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1792x828.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_828x1792.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 375px) and (device-height: 667px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1334x750.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1242x2668.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 414px) and (device-height: 736px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_2208x1242.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 375px) and (device-height: 812px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1125x2436.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 414px) and (device-height: 736px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1242x2208.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 1024px) and (device-height: 1366px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_2732x2048.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_2688x1242.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 834px) and (device-height: 1112px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_2224x1668.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 375px) and (device-height: 667px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_750x1334.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 1024px) and (device-height: 1366px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_2048x2732.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 834px) and (device-height: 1194px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_2388x1668.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 834px) and (device-height: 1112px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1668x2224.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 320px) and (device-height: 568px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_640x1136.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 834px) and (device-height: 1194px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1668x2388.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 768px) and (device-height: 1024px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_2048x1536.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 768px) and (device-height: 1024px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1536x2048.png"
  >
  <link
    rel="mask-icon"
    color="#77a2b6"
    href="https://assets.habr.com/habr-web/img/favicons/apple-touch-icon-120.svg"
  >
  <link
    crossorigin="use-credentials"
    href="/manifest.webmanifest"
    rel="manifest"
  >
</head>
<body>


<div id="app" data-server-rendered="true" data-async-called="true"><div class="tm-layout__wrapper"><!----> <div></div> <!----> <header class="tm-header"><div class="tm-page-width"><div class="tm-header__container"><!----> <span class="tm-header__logo-wrap"><a href="/ru/" class="tm-header__logo tm-header__logo_ru"><svg height="16" width="16" class="tm-svg-img tm-header__icon"><title>Хабр</title> <use xlink:href="/img/habr-logo-ru.svg#logo"></use></svg></a> <span class="tm-header__beta-sign" style="display:none;">β</span></span> <div class="tm-dropdown tm-header__projects"><div class="tm-dropdown__head"><button class="tm-header__dropdown-toggle"><svg height="16" width="16" class="tm-svg-img tm-header__icon tm-header__icon_dropdown"><title>Открыть список</title> <use xlink:href="/img/megazord-v24.ce74655c.svg#arrow-down"></use></svg></button></div> <!----></div> <a href="/ru/sandbox/start/" class="tm-header__become-author-btn">
            Как стать автором
          </a> <div class="tm-feature tm-header__feature tm-feature_variant-inline"><!----></div> <!----> <!----></div></div></header> <div class="tm-layout"><div class="tm-page-progress-bar"></div> <div data-menu-sticky="true" class="tm-base-layout__header tm-base-layout__header_is-sticky"><div class="tm-page-width"><div class="tm-base-layout__header-wrapper"><div class="tm-main-menu"><div class="tm-main-menu__section"><nav class="tm-main-menu__section-content"><!----> <a href="/ru/all/" class="tm-main-menu__item">
        Все потоки
      </a> <a href="/ru/flows/develop/" class="tm-main-menu__item">
          Разработка
        </a><a href="/ru/flows/admin/" class="tm-main-menu__item">
          Администрирование
        </a><a href="/ru/flows/design/" class="tm-main-menu__item">
          Дизайн
        </a><a href="/ru/flows/management/" class="tm-main-menu__item">
          Менеджмент
        </a><a href="/ru/flows/marketing/" class="tm-main-menu__item">
          Маркетинг
        </a><a href="/ru/flows/popsci/" class="tm-main-menu__item">
          Научпоп
        </a></nav></div></div> <div class="tm-header-user-menu tm-base-layout__user-menu"><a href="/ru/search/" class="tm-header-user-menu__item tm-header-user-menu__search"><svg height="24" width="24" class="tm-svg-img tm-header-user-menu__icon tm-header-user-menu__icon_search tm-header-user-menu__icon_dark"><title>Поиск</title> <use xlink:href="/img/megazord-v24.ce74655c.svg#search"></use></svg></a> <!----> <!----> <!----> <div class="tm-header-user-menu__item tm-header-user-menu__user_desktop"><div class="tm-dropdown"><div class="tm-dropdown__head"><svg height="24" width="24" data-test-id="menu-toggle-guest" class="tm-svg-img tm-header-user-menu__icon"><title>Профиль</title> <use xlink:href="/img/megazord-v24.ce74655c.svg#header-user"></use></svg> <!----></div> <!----></div> <!----></div> <!----></div></div></div></div> <!----> <div class="tm-page-width"></div> <main class="tm-layout__container"><div hl="ru" data-async-called="true" class="tm-page"><div class="tm-page-width"><!----> <div class="tm-page__wrapper"><div class="tm-page__main tm-page__main_has-sidebar"><div class="pull-down"><div class="pull-down__header" style="height:0px;"><div class="pull-down__content" style="bottom:10px;"><svg height="24" width="24" class="tm-svg-img pull-down__arrow"><title>Обновить</title> <use xlink:href="/img/megazord-v24.ce74655c.svg#pull-arrow"></use></svg></div></div> <div class="tm-article-presenter"> <div class="tm-article-presenter__body"><div class="tm-misprint-area"><div class="tm-misprint-area__wrapper"><article class="tm-article-presenter__content tm-article-presenter__content_narrow"><div class="tm-article-presenter__header"> <div class="tm-article-snippet tm-article-presenter__snippet"><div class="tm-article-snippet__meta-container"><div class="tm-article-snippet__meta"><span class="tm-user-info tm-article-snippet__author"><a href="/ru/users/DmitryKazakov8/" title="DmitryKazakov8" class="tm-user-info__userpic"><div class="tm-entity-image"><img alt="" height="24" loading="lazy" src="//habrastorage.org/r/w32/getpro/habr/avatars/0f6/1ce/43b/0f61ce43b0b1a750e5876fe59fe582c7.jpg" width="24" class="tm-entity-image__pic"></div></a> <span class="tm-user-info__user"><a href="/ru/users/DmitryKazakov8/" class="tm-user-info__username">
      DmitryKazakov8
    </a> </span></span> <span class="tm-article-snippet__datetime-published"><time datetime="2019-05-02T19:27:53.000Z" title="2019-05-02, 22:27">2  мая  2019 в 22:27</time></span></div> <!----></div> <h1 lang="ru" class="tm-article-snippet__title tm-article-snippet__title_h1"><span>Архитектура SPA-приложения биржи в 2019 году</span></h1> <div class="tm-article-snippet__hubs"><span class="tm-article-snippet__hubs-item"><a href="/ru/hub/webdev/" class="tm-article-snippet__hubs-item-link"><span>Разработка веб-сайтов</span> <span title="Профильный хаб" class="tm-article-snippet__profiled-hub">*</span></a></span><span class="tm-article-snippet__hubs-item"><a href="/ru/hub/javascript/" class="tm-article-snippet__hubs-item-link"><span>JavaScript</span> <span title="Профильный хаб" class="tm-article-snippet__profiled-hub">*</span></a></span><span class="tm-article-snippet__hubs-item"><a href="/ru/hub/reactjs/" class="tm-article-snippet__hubs-item-link"><span>ReactJS</span> <span title="Профильный хаб" class="tm-article-snippet__profiled-hub">*</span></a></span></div> <div class="tm-article-snippet__labels"><div class="tm-article-snippet__label"><span>
        Из песочницы
      </span></div><div class="tm-article-snippet__label"><span>
        Tutorial
      </span></div></div> <!----> <!----></div></div> <!----> <div data-gallery-root="" lang="ru" class="tm-article-body"><div id="post-content-body" class="article-formatted-body article-formatted-body_version-1"><div xmlns="http://www.w3.org/1999/xhtml"><p>Приветствую, хабровчане!</p><br/>
<p>Читаю данный ресурс со времени основания, но время на написание статьи появилось только сейчас, а значит пора поделиться своим опытом с сообществом. Начинающим разработчикам, рассчитываю, статья поможет улучшить качество проектирования, а опытным выступит в качестве чек-листа, чтобы не забыть важные элементы на этапе архитектуры. Для нетерпеливых — итоговый <a href="https://github.com/dkazakov8/habr_exchange" rel="nofollow">репозиторий</a> и <a href="https://dkazakov8.github.io/exchange_habr/dist/" rel="nofollow">демо</a>.</p><br/>
<a name="habracut"></a><br/>
<p>Допустим, вы устроились в «компанию мечты» — одну из бирж со свободным выбором технологий и ресурсами, чтобы сделать все «как надо». На данный момент все, что есть у компании — это</p><br/>
<h3>Задание от бизнеса</h3><br/>
<p>Разработать SPA-приложение для торгового интерфейса, в котором можно:</p><br/>
<ul>
<li>увидеть список торговых пар, сгруппированных по торгуемой валюте;</li>
<li>при нажатии на торговую пару увидеть информацию по текущей цене, изменении за 24 часа, «стакан заявок»;</li>
<li>изменить язык приложения на английский / русский;</li>
<li>изменить тему на темную / светлую.</li>
</ul><br/>
<p>Задание достаточно краткое, что позволит сосредоточиться именно на архитектуре, а не написании больших объемов бизнес-функционала. Итогом первоначальных усилий должен стать логичный и продуманных код, позволяющий приступить непосредственно к реализации бизнес-логики.</p><br/>
<p>Так как в ТЗ от заказчика нет технических требований, пусть будут комфортные для разработки:</p><br/>
<ul>
<li><b>кроссбраузерность</b>: 2 последние версии популярных браузеров (без IE);</li>
<li><b>ширина экрана</b>: >= 1240px;</li>
<li><b>дизайн</b>: по аналогии с другими биржами, т.к. дизайнера еще не наняли.</li>
</ul><br/>
<p>Теперь время определить используемые инструменты и библиотеки. Я буду руководствоваться принципами разработки «под ключ» и <a href="https://ru.wikipedia.org/wiki/KISS_(%D0%BF%D1%80%D0%B8%D0%BD%D1%86%D0%B8%D0%BF)" rel="nofollow">KISS</a>, то есть брать только те opensource библиотеки, для самостоятельной реализации которых потребовалось бы неадекватно много времени, включая время на обучение будущих коллег-разработчиков.</p><br/>
<ul>
<li><b>система управления версиями</b>: Git + Github;</li>
<li><b>backend</b>: <a href="https://www.coingecko.com/en/api" rel="nofollow">API</a> CoinGecko;</li>
<li><b>сборка / траниспиляция</b>: Webpack + Babel;</li>
<li><b>установщик пакетов</b>: Yarn (npm 6 некорректно обновлял зависимости);</li>
<li><b>контроль качества кода</b>: ESLint + Prettier + Stylelint;</li>
<li><b>view</b>: React (посмотрим, насколько удобны Hooks);</li>
<li><b>store</b>: MobX;</li>
<li><b>автотесты</b>: <a href="https://www.cypress.io/" rel="nofollow">Cypress.io</a> (комплексное решение на javascript вместо модульной сборки вроде Mocha/Karma+Chai+Sinon+Selenium+Webdriver/Protractor);</li>
<li><b>стили</b>: SCSS через PostCSS (гибкость настройки, дружит с Stylelint);</li>
<li><b>графики</b>: <a href="https://www.highcharts.com/blog/products/highstock/" rel="nofollow">HighStock</a> (настраивать намного проще, чем <a href="https://ru.tradingview.com/HTML5-stock-forex-bitcoin-charting-library/" rel="nofollow">TradingView</a>, но для реального приложения взял бы последний);</li>
<li><b>регистрация ошибок</b>: Sentry;</li>
<li><b>утилиты</b>: Lodash (экономия времени);</li>
<li><b>роутинг</b>: под ключ;</li>
<li><b>локализация</b>: под ключ;</li>
<li><b>работа с запросами</b>: под ключ;</li>
<li><b>метрики быстродействия</b>: под ключ;</li>
<li><b>типизация</b>: не в мою смену.</li>
</ul><br/>
<p>Таким образом, из библиотек в итоговом файле приложения окажутся только React, MobX, HighStock, Lodash и Sentry. Считаю это оправданным, так как они имеют отличную документацию, быстродействие и знакомы многим разработчикам.</p><br/>
<h3>Контроль качества кода</h3><br/>
<p>Я предпочитаю разбивать зависимости в <i>package.json</i> на смысловые части, поэтому первым шагом после инициации git-репозитория сгруппирую все, что касается стиля кода в папке <i>./eslint-custom</i>, указав в <i>package.json</i>:</p><br/>
<pre><code class="json">{
  "scripts": {
    "upd": "yarn install --no-lockfile"
  },
  "dependencies": {
    "eslint-custom": "file:./eslint-custom"
  }
}
</code></pre><br/>
<p>Обычный <code>yarn install</code> не проверит, изменились ли зависимости внутри <i>eslint-custom</i>, поэтому буду использовать <code>yarn upd</code>. В целом такая практика выглядит более универсальной, так как девопсам не придется менять рецепт деплоя, если разработчикам понадобится изменить метод установки пакетов.</p><br/>
<p>Файлом <i>yarn.lock</i> пользоваться нет смысла, так как все зависимости будут без «крышечек» semver (в виде <code>"react": "16.8.6"</code>). Опыт показал, что лучше вручную обновлять версии и тщательно их тестировать в рамках отдельных задач, чем полагаться на lock-файл, предоставляя авторам пакетов возможность сломать приложение минорным обновлением в любой момент (счастливчики, кто с этим не сталкивался).</p><br/>
<p>В пакете <i>eslint-custom</i> зависимости будут следующие:</p><br/>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title">eslint-custom/package.json</b>
                        <div class="spoiler_text"><pre><code class="json">{
  "name": "eslint-custom",
  "version": "1.0.0",
  "description": "Custom linter rules for this project",
  "license": "MIT",
  "dependencies": {
    "babel-eslint": "10.0.1",
    "eslint": "5.16.0",
    "eslint-config-prettier": "4.1.0",
    "eslint-plugin-import": "2.17.2",
    "eslint-plugin-prettier": "3.0.1",
    "eslint-plugin-react": "7.12.4",
    "eslint-plugin-react-hooks": "1.6.0",
    "prettier": "1.17.0",
    "prettier-eslint": "8.8.2",
    "stylelint": "10.0.1",
    "stylelint-config-prettier": "5.1.0",
    "stylelint-prettier": "1.0.6",
    "stylelint-scss": "3.6.0"
  }
}
</code></pre></div>
                    </div><br/>
<p>Чтобы связать три инструмента, понадобилось 5 вспомогательных пакетов (<i>eslint-plugin-prettier, eslint-config-prettier, stylelint-prettier, stylelint-config-prettier, prettier-eslint</i>) — такую цену приходится платить сегодня. Для максимального удобства не хватает только автоматической <a href="https://github.com/AlexJuarez/eslint-plugin-import-order-autofix" rel="nofollow">сортировки imports</a>, но, к сожалению, этот плагин при переформатировании файла теряет строки.</p><br/>
<p>Конфигурационные файлы для всех инструментов будут в формате <i>*.js</i> (<i>eslint.config.js</i>, <i>stylelint.config.js</i>), чтобы на них самих работало форматирование кода. Правила пусть будут в формате <i>*.yaml</i>, разбитые по смысловым модулям. Полные версии конфигураций и правил — в <a href="https://github.com/dkazakov8/habr_exchange/tree/master/eslint-custom" rel="nofollow">репозитории</a>.</p><br/>
<p>Осталось дописать команды в основной <i>package.json</i>...</p><br/>
<pre><code class="json">{
  "scripts": {
    "upd": "yarn install --no-lockfile",
    "format:js": "eslint --ignore-path .gitignore --ext .js -c ./eslint-custom/eslint.config.js --fix",
    "format:style": "stylelint --ignore-path .gitignore --config ./eslint-custom/stylelint.config.js  --fix"
  }
}
</code></pre><br/>
<p>… и настроить свой IDE на применение форматирования при сохранении текущего файла. Для гарантии при создании коммита необходимо использовать git-хук, который будет проверять и форматировать все файлы проекта. Почему не только те, которые присутствуют в коммите? Для принципа коллективной ответственности за всю кодовую базу, чтобы ни у кого не было соблазна обойти валидацию. Для этого же при создании коммита все предупреждения линтера будут считаться ошибками с помощью <code>--max-warnings=0</code>.</p><br/>
<pre><code class="json">{
  "husky": {
    "hooks": {
      "pre-commit": "npm run format:js -- --max-warnings=0 ./ &amp;&amp; npm run format:style ./**/*.scss"
    }
  }
}
</code></pre><br/>
<h3>Сборка / траниспиляция</h3><br/>
<p>Снова воспользуюсь модульным подходом и вынесу все настройки Webpack и Babel в папку ./webpack-custom. Конфиг будет опираться на следующую структуру файлов:</p><br/>
<pre><code class="pgsql">.
|-- webpack-custom
|   |-- config
|   |-- loaders
|   |-- plugins
|   |-- rules
|   |-- utils
|   `-- package.json
|   `-- webpack.config.js
</code></pre><br/>
<p>Грамотно настроенный сборщик предоставит:</p><br/>
<ul>
<li>возможность писать код, используя синтаксис и возможности последней EcmaScript спецификации, включая удобные proposals (здесь точно пригодятся декораторы классов и их свойств для MobX);</li>
<li>локальный сервер с Hot Reloading;</li>
<li>метрики производительности сборки;</li>
<li>проверку на цикличные зависимости;</li>
<li>анализ структуры и размера итогового файла;</li>
<li>оптимизацию и минификацию для production сборки;</li>
<li>интерпретацию модульных <i>*.scss</i> файлов и возможность вынесения готовых <i>*.css</i> файлов из бандла;</li>
<li>inline-вставку <i>*.svg</i> файлов;</li>
<li>полифиллы / стилевые префиксы для целевых браузеров;</li>
<li>решение проблемы с кэшированием файлов на production.</li>
</ul><br/>
<p>А также будет удобно конфигурироваться. Эту задачу решу с помощью двух <i>*.env</i> файлов-примеров:</p><br/>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title">.frontend.env.example</b>
                        <div class="spoiler_text"><pre><code class="plaintext">AGGREGATION_TIMEOUT=0
BUNDLE_ANALYZER=false
BUNDLE_ANALYZER_PORT=8889
CIRCULAR_CHECK=true
CSS_EXTRACT=false
DEV_SERVER_PORT=8080
HOT_RELOAD=true
NODE_ENV=development
SENTRY_URL=false
SPEED_ANALYZER=false
PUBLIC_URL=false

# https://webpack.js.org/configuration/devtool
DEV_TOOL=cheap-module-source-map
</code></pre></div>
                    </div><br/>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title">.frontend.env.prod.example</b>
                        <div class="spoiler_text"><pre><code class="plaintext">AGGREGATION_TIMEOUT=0
BUNDLE_ANALYZER=false
BUNDLE_ANALYZER_PORT=8889
CIRCULAR_CHECK=false
CSS_EXTRACT=true
DEV_SERVER_PORT=8080
HOT_RELOAD=false
NODE_ENV=production
SENTRY_URL=false
SPEED_ANALYZER=false
PUBLIC_URL=/habr_exchange/dist

# https://webpack.js.org/configuration/devtool
DEV_TOOL=false
</code></pre></div>
                    </div><br/>
<p>Таким образом, для запуска сборки нужно создать файл с названием <i>.frontend.env</i> и обязательным присутствием всех параметров. Данный подход решит сразу несколько проблем: не нужно делать раздельные конфигурационные файлы для Webpack и поддерживать их согласованность; локально можно настроить насколько это нужно определенному разработчику; девопсы при деплое будут лишь копировать файл для production-сборки (<code>cp .frontend.env.prod.example .frontend.env</code>), обогащая значениями из хранилища, соответственно frontend-разработчики имеют возможность управлять рецептом через переменные без задействования админов. Дополнительно можно будет сделать пример конфигурации для стендов (например, с source maps).</p><br/>
<p>Для отделения стилей в файлы при включенном <i>CSS_EXTRACT</i> буду использовать <a href="https://github.com/webpack-contrib/mini-css-extract-plugin" rel="nofollow">mini-css-extract-plugin</a> — он позволяет использовать Hot Reloading. То есть, если при локальной разработке включить <i>HOT_RELOAD</i> и <i>CSS_EXTRACT</i>, то при<br/>
изменении файлов стилей будут перезагружаться только они — но, к сожалению, все, а не только измененный файл. С выключенным же <i>CSS_EXTRACT</i> обновляться будет только измененный стилевой модуль.</p><br/>
<p>HMR для работы с React Hooks включается достаточно стандартно:</p><br/>
<ul>
<li><code>webpack.HotModuleReplacementPlugin</code> в plugins;</li>
<li><code>hot: true</code> в параметрах <i>webpack-dev-server</i>;</li>
<li><code>react-hot-loader/babel</code> в <i>babel-loader</i> plugins;</li>
<li><code>options.hmr: true</code> в <i>mini-css-extract-plugin</i>;</li>
<li><code>export default hot(App)</code> в главном компоненте приложения;</li>
<li><i>@hot-loader/react-dom</i> вместо обычного <i>react-dom</i> (удобно через <code>resolve.alias: { 'react-dom': '@hot-loader/react-dom' }</code>);</li>
</ul><br/>
<p>Текущая версия <i>react-hot-loader</i> не поддерживает мемоизацию компонентов с помощью <code>React.memo</code>, так что при написании декораторов для MobX надо будет учесть это для удобства локальной разработки. Еще одно вызванное этим неудобство — при включенной настройке <i>Highlight Updates</i> в React Developer Tools при любом взаимодействии с приложением обновляются все компоненты. Поэтому при локальной работе над оптимизацией производительности следует отключать настройку <i>HOT_RELOAD</i>.</p><br/>
<p>Оптимизация сборки в Webpack 4 выполняется автоматически при указании <code><a href="https://webpack.js.org/configuration/mode" rel="nofollow">mode</a>: 'development' | 'production'</code>. В данном случае положусь на стандартную оптимизацию (+ включение параметра <code>keep_fnames: true</code> в <i>terser-webpack-plugin</i> для сохранения названия компонентов), так как она уже качественно настроена.</p><br/>
<p>Отдельного внимания заслуживает разбиение на чанки и контроль клиентского кэширования. Для корректной работы нужно:</p><br/>
<ul>
<li>в output.filename для js и css файлов указать <code>isProduction ? '[name].[contenthash].js' : '[name].js'</code> (с расширением .css соответственно), чтобы название файла опиралось на его содержание;</li>
<li>в optimization изменить параметры на <code>chunkIds: 'named', moduleIds: 'hashed'</code>, чтобы внутренний счетчик модулей в webpack не менялся;</li>
<li>вынести runtime в отдельный чанк;</li>
<li>вынести группы кэширования в splitChunks (для данного приложения достаточно четырех точек — lodash, sentry, highcharts и vendor для остальных зависимостей из <i>node_modules</i>). Так как первые три будут обновляться редко, то они останутся в кэше браузера клиента максимально долго.</li>
</ul><br/>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title">webpack-custom/config/configOptimization.js</b>
                        <div class="spoiler_text"><pre><code class="javascript">/**
 * @docs: https://webpack.js.org/configuration/optimization
 *
 */

const TerserPlugin = require('terser-webpack-plugin');

module.exports = {
  runtimeChunk: {
    name: 'runtime',
  },
  chunkIds: 'named',
  moduleIds: 'hashed',
  mergeDuplicateChunks: true,
  splitChunks: {
    cacheGroups: {
      lodash: {
        test: module => module.context.indexOf('node_modules\\lodash') !== -1,
        name: 'lodash',
        chunks: 'all',
        enforce: true,
      },
      sentry: {
        test: module => module.context.indexOf('node_modules\\@sentry') !== -1,
        name: 'sentry',
        chunks: 'all',
        enforce: true,
      },
      highcharts: {
        test: module =>
          module.context.indexOf('node_modules\\highcharts') !== -1,
        name: 'highcharts',
        chunks: 'all',
        enforce: true,
      },
      vendor: {
        test: module => module.context.indexOf('node_modules') !== -1,
        priority: -1,
        name: 'vendor',
        chunks: 'all',
        enforce: true,
      },
    },
  },
  minimizer: [
    new TerserPlugin({
      terserOptions: {
        keep_fnames: true,
      },
    }),
  ],
};
</code></pre></div>
                    </div><br/>
<p>Для ускорения сборки в этом проекте использую <a href="https://github.com/webpack-contrib/thread-loader" rel="nofollow">thread-loader</a> — при параллелизации на 4 процесса он дал ускорение сборки на 90%, что лучше, чем у happypack при аналогичных настройках.</p><br/>
<p>Настройки для лоадеров, в том числе для babel, в отдельные файлы (вроде <i>.babelrc</i>) выносить, полагаю, излишне. А вот конфигурацию кроссбраузерности удобнее держать в параметре <code>browserslist</code> основного <i>package.json</i>, так как он используется также для autoprefixer'а стилей.</p><br/>
<p>Для удобства работы с Prettier сделал параметр <i>AGGREGATION_TIMEOUT</i>, который позволяет установить задержку между обнаружением изменений в файлах и пересборкой приложения в режиме dev-server. Так как я настроил переформатирование файлов при сохранении в IDE, то это вызывает 2 пересборки — первую на сохранение исходного файла, вторую на завершение форматирования. 2000 миллисекунд обычно достаточно, чтобы webpack дождался финальной версии файла.</p><br/>
<p>Остальная конфигурация особого внимания не заслуживает, так как раскрыта в сотнях обучающих материалов для начинающих, поэтому можно переходить к проектированию архитектуры приложения.</p><br/>
<h3>Стилевые темы</h3><br/>
<p>Раньше для создания тем приходилось делать несколько версий <i>*.css</i> файлов и перезагружать страницу при смене темы, загружая нужный набор стилей. Сейчас все легко решается с помощью <a href="https://developer.mozilla.org/ru/docs/Web/CSS/Using_CSS_custom_properties" rel="nofollow">Custom CSS Properties</a>. Данную технологию поддерживают все целевые браузеры текущего приложения, но есть и полифиллы для IE.</p><br/>
<p>Допустим, будет 2 темы — light и dark, наборы цветов для которых будут находиться в</p><br/>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title">styles/themes.scss</b>
                        <div class="spoiler_text"><pre><code class="plaintext">.light {
  --n0: rgb(255, 255, 255);
  --n100: rgb(186, 186, 186);
  --n10: rgb(249, 249, 249);
  --n10a3: rgba(249, 249, 249, 0.3);
  --n20: rgb(245, 245, 245);
  --n30: rgb(221, 221, 221);
  --n500: rgb(136, 136, 136);
  --n600: rgb(102, 102, 102);
  --n900: rgb(0, 0, 0);

  --b100: rgb(219, 237, 251);
  --b300: rgb(179, 214, 252);
  --b500: rgb(14, 123, 249);
  --b500a3: rgba(14, 123, 249, 0.3);
  --b900: rgb(32, 39, 57);

  --g400: rgb(71, 215, 141);
  --g500: rgb(61, 189, 125);
  --g500a1: rgba(61, 189, 125, 0.1);
  --g500a2: rgba(61, 189, 125, 0.2);

  --r400: rgb(255, 100, 100);
  --r500: rgb(255, 0, 0);
  --r500a1: rgba(255, 0, 0, 0.1);
  --r500a2: rgba(255, 0, 0, 0.2);
}

.dark {
  --n0: rgb(25, 32, 48);
  --n100: rgb(114, 126, 151);
  --n10: rgb(39, 46, 62);
  --n10a3: rgba(39, 46, 62, 0.3);
  --n20: rgb(25, 44, 74);
  --n30: rgb(67, 75, 111);
  --n500: rgb(117, 128, 154);
  --n600: rgb(255, 255, 255);
  --n900: rgb(255, 255, 255);

  --b100: rgb(219, 237, 251);
  --b300: rgb(39, 46, 62);
  --b500: rgb(14, 123, 249);
  --b500a3: rgba(14, 123, 249, 0.3);
  --b900: rgb(32, 39, 57);

  --g400: rgb(0, 220, 103);
  --g500: rgb(0, 197, 96);
  --g500a1: rgba(0, 197, 96, 0.1);
  --g500a2: rgba(0, 197, 96, 0.2);

  --r400: rgb(248, 23, 1);
  --r500: rgb(221, 23, 1);
  --r500a1: rgba(221, 23, 1, 0.1);
  --r500a2: rgba(221, 23, 1, 0.2);
}
</code></pre></div>
                    </div><br/>
<p>Для того, чтобы эти переменные применялись глобально, их нужно записать в <code>document.documentElement</code>, соответственно нужен небольшой парсер, чтобы преобразовать этот файл в javascript объект. Позже расскажу, почему так удобнее, чем сразу хранить в javascript.</p><br/>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title">webpack-custom/utils/sassVariablesLoader.js</b>
                        <div class="spoiler_text"><pre><code class="javascript">function convertSourceToJsObject(source) {
  const themesObject = {};
  const fullThemesArray = source.match(/\.([^}]|\s)*}/g) || [];

  fullThemesArray.forEach(fullThemeStr => {
    const theme = fullThemeStr
      .match(/\.\w+\s{/g)[0]
      .replace(/\W/g, '');
    themesObject[theme] = {};

    const variablesMatches =
      fullThemeStr.match(/--(.*:[^;]*)/g) || [];

    variablesMatches.forEach(varMatch => {
      const [key, value] = varMatch.split(': ');
      themesObject[theme][key] = value;
    });
  });

  return themesObject;
}

function checkThemesEquality(themes) {
  const themesArray = Object.keys(themes);

  themesArray.forEach(themeStr => {
    const themeObject = themes[themeStr];
    const otherThemesArray = themesArray.filter(t => t !== themeStr);

    Object.keys(themeObject).forEach(variableName => {
      otherThemesArray.forEach(otherThemeStr => {
        const otherThemeObject = themes[otherThemeStr];

        if (!otherThemeObject[variableName]) {
          throw new Error(
            `checkThemesEquality: theme ${otherThemeStr} has no variable ${variableName}`
          );
        }
      });
    });
  });
}

module.exports = function sassVariablesLoader(source) {
  const themes = convertSourceToJsObject(source);

  checkThemesEquality(themes);

  return `module.exports = ${JSON.stringify(themes)}`;
};
</code></pre></div>
                    </div><br/>
<p>Здесь же проверяется согласованность тем — то есть полное соответствие набора переменных, при различии которых сборка падает.</p><br/>
<p>При использовании этого лоадера получается вполне красивый объект с параметрами, и достаточно пары строк для утилиты смены темы:</p><br/>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title">src/utils/setTheme.js</b>
                        <div class="spoiler_text"><pre><code class="javascript">import themes from 'styles/themes.scss';

const root = document.documentElement;

export function setTheme(theme) {
  Object.entries(themes[theme]).forEach(([key, value]) => {
    root.style.setProperty(key, value);
  });
}
</code></pre></div>
                    </div><br/>
<p>Предпочитаю перевести эти css-переменные в стандартные для <i>*.scss</i>:</p><br/>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title">src/styles/constants.scss</b>
                        <div class="spoiler_text"><img src="/img/image-loader.svg" data-src="https://habrastorage.org/webt/py/b5/jf/pyb5jfs2g07r-ypnnkoudkdxe7s.png"/><br/>
</div>
                    </div><br/>
<p>IDE WebStorm, как видно на скриншоте, показывает цвета на панели слева и по клику на цвет открывает палитру, где можно его сменить. Новый цвет автоматически подставится в <i>themes.scss</i>, сработает Hot Reload и приложение моментально преобразится. Это именно тот уровень удобства разработки, который и ожидается в 2019 году.</p><br/>
<h3>Принципы организации кода</h3><br/>
<p>В данном проекте буду придерживаться дублирования названий папок компонентов, файлов и стилей, например:</p><p></p><pre><code class="pgsql">.
|-- components
|   |-- Chart
|   |   `-- Chart.js
|   |   `-- Chart.scss
|   |   `-- package.json
</code></pre><br/>
<p>Соответственно, <i>package.json</i> будет иметь содержание <code>{ "main": "Chart.js" }</code>. Для компонентов с множественными именованными экспортами (например, утилит) название главного файла будет начинаться с подчеркивания:</p><br/>
<pre><code class="pgsql">.
|-- utils
|   `-- _utils.js
|   `-- someUtil.js
|   `-- anotherUtil.js
|   `-- package.json
</code></pre><br/>
<p>А остальные файлы будут экспортироваться в виде:</p><br/>
<pre><code class="javascript">export * from './someUtil';
export * from './anotherUtil';
</code></pre><br/>
<p>Это позволит избавиться от дублирования названий файлов, чтобы не теряться в десятке открытых <i>index.js</i> / <i>style.scss</i>. Можно решить это и плагинами к IDE, но почему бы и не универсальным способом.</p><br/>
<p>Компоненты буду группировать постранично, кроме общих вроде Message / Link, а также по возможности использовать именованные экспорты (без <code>export default</code>) для поддержания однообразия названий, простоты рефакторинга и поиска по проекту.</p><br/>
<h3>Настройка рендеринга и хранилища MobX</h3><br/>
<p>Файл, который служит entry point для Webpack, будет выглядеть следующим образом:</p><br/>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title">src/app.js</b>
                        <div class="spoiler_text"><pre><code class="javascript">import './polyfill';
import './styles/reset.scss';
import './styles/global.scss';

import { initSentry, renderToDOM } from 'utils';
import { initAutorun } from './autorun';
import { store } from 'stores';

import App from 'components/App';

initSentry();
initAutorun(store);
renderToDOM(App);
</code></pre></div>
                    </div><br/>
<p>Так как при работе с observables в консоли выводится что-то вроде <code>Proxy {0: "btc", 1: "eth", 2: "usd", 3: "test", Symbol(mobx administration): ObservableArrayAdministration}</code>, в полифиллах сделаю утилиту для приведения в стандартный вид:</p><br/>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title">src/polyfill.js</b>
                        <div class="spoiler_text"><pre><code class="javascript">import { toJS } from 'mobx';

console.js = function consoleJsCustom(...args) {
  console.log(...args.map(arg => toJS(arg)));
};
</code></pre></div>
                    </div><br/>
<p>Также в основном файле подключаются глобальные стили и нормализация стилей для разных браузеров, при наличии ключа для Sentry в .env.frontend начинают логироваться ошибки, создается MobX хранилище, инициируется слежение за изменениями параметров с помощью autorun и обернутый в <i>react-hot-loader</i> компонент монтируется в DOM.</p><br/>
<p>Само хранилище будет представлять из себя не-observable класс, параметрами которого будут не-observable классы с observable параметрами. Таким образом подразумевается, что набор параметров не будет динамическим — следовательно, приложение будет более предсказуемым. Это одно из немногих мест, где пригодится JSDoc, чтобы включить автодополнение в IDE.</p><br/>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title">src/stores/RootStore.js</b>
                        <div class="spoiler_text"><pre><code class="javascript">import { I18nStore } from './I18nStore';
import { RatesStore } from './RatesStore';
import { GlobalStore } from './GlobalStore';
import { RouterStore } from './RouterStore';
import { CurrentTPStore } from './CurrentTPStore';
import { MarketsListStore } from './MarketsListStore';

/**
 * @name RootStore
 */
export class RootStore {
  constructor() {
    this.i18n = new I18nStore(this);
    this.rates = new RatesStore(this);
    this.global = new GlobalStore(this);
    this.router = new RouterStore(this);
    this.currentTP = new CurrentTPStore(this);
    this.marketsList = new MarketsListStore(this);
  }
}
</code></pre></div>
                    </div><br/>
<p>Пример MobX стора можно разобрать на примере GlobalStore, у которого будет на данный момент единственное назначение — хранить и устанавливать текущую стилевую тему.</p><br/>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title">src/stores/GlobalStore.js</b>
                        <div class="spoiler_text"><pre><code class="javascript">import { makeObservable, setTheme } from 'utils';
import themes from 'styles/themes.scss';

const themesList = Object.keys(themes);

@makeObservable
export class GlobalStore {
  /**
   * @param rootStore {RootStore}
   */
  constructor(rootStore) {
    this.rootStore = rootStore;

    setTheme(themesList[0]);
  }

  themesList = themesList;
  currentTheme = '';

  setTheme(theme) {
    this.currentTheme = theme;
    setTheme(theme);
  }
}
</code></pre></div>
                    </div><br/>
<p>Иногда параметрам и методом класса вручную с помощью декораторов устанавливают тип, например:</p><br/>
<pre><code class="javascript">export class GlobalStore {
  @observable
  currentTheme = '';

  @action.bound
  setTheme(theme) {
    this.currentTheme = theme;
    setTheme(theme);
  }
}
</code></pre><br/>
<p>Но смысла в этом не вижу, так как старый Proposal декораторов класса поддерживает их автоматическую трансформацию, поэтому достаточно следующей утилиты:</p><br/>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title">src/utils/makeObservable.js</b>
                        <div class="spoiler_text"><pre><code class="javascript">import { action, computed, decorate, observable } from 'mobx';

export function makeObservable(target) {
  /**
   * Для методов - биндим контекст this + все изменения сторов
   * выполняем в одной транзакции
   *
   * Для геттеров - оборачиваем в computed
   *
   */

  const classPrototype = target.prototype;
  const methodsAndGetters = Object.getOwnPropertyNames(classPrototype).filter(
    methodName => methodName !== 'constructor'
  );

  for (const methodName of methodsAndGetters) {
    const descriptor = Object.getOwnPropertyDescriptor(
      classPrototype,
      methodName
    );

    descriptor.value = decorate(classPrototype, {
      [methodName]:
        typeof descriptor.value === 'function' ? action.bound : computed,
    });
  }

  return (...constructorArguments) => {
    /**
     * Параметры, за исключением rootStore, трансформируем в
     * observable
     *
     */

    const store = new target(...constructorArguments);
    const staticProperties = Object.keys(store);

    staticProperties.forEach(propName => {
      if (propName === 'rootStore') {
        return false;
      }

      const descriptor = Object.getOwnPropertyDescriptor(store, propName);

      Object.defineProperty(
        store,
        propName,
        observable(store, propName, descriptor)
      );
    });

    return store;
  };
}
</code></pre></div>
                    </div><br/>
<p>Для использования необходимо откорректировать плагины в <i>loaderBabel.js</i>: <code>['@babel/plugin-proposal-decorators', { legacy: true }], ['@babel/plugin-proposal-class-properties', { loose: true }]</code>, а в настройках ESLint соответственно выставить <code>parserOptions.ecmaFeatures.legacyDecorators: true</code>. Без этих настроек в target декоратора передается только дескриптор класса без прототипа, и, несмотря на тщательное исследование <a href="https://tc39.github.io/proposal-decorators/" rel="nofollow">текущей версии Proposal</a>, я не нашел способа обернуть методы и статические свойства.</p><br/>
<p>В целом настройка хранилища закончена, но хорошо бы еще раскрыть потенциал MobX autorun. Для этого как нельзя лучше подойдут задачи типа «дождаться ответа от сервера авторизации» или «загрузить переводы с сервера», после чего записать ответы в стор и непосредственно отрендерить приложение в DOM. Поэтому забегу немного в будущее и создам стор с локализацией:</p><br/>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title">src/stores/I18nStore.js</b>
                        <div class="spoiler_text"><pre><code class="javascript">import { makeObservable } from 'utils';
import ru from 'localization/ru.json';
import en from 'localization/en.json';

const languages = {
  ru,
  en,
};

const languagesList = Object.keys(languages);

@makeObservable
export class I18nStore {
  /**
   * @param rootStore {RootStore}
   */
  constructor(rootStore) {
    this.rootStore = rootStore;

    setTimeout(() => {
      this.setLocalization('ru');
    }, 500);
  }

  i18n = {};
  languagesList = languagesList;
  currentLanguage = '';

  setLocalization(language) {
    this.currentLanguage = language;
    this.i18n = languages[language];
    this.rootStore.global.shouldAppRender = true;
  }
}
</code></pre></div>
                    </div><br/>
<p>Как видно, есть некие файлы <i>*.json</i> с переводами, а в конструкторе класса эмулируется асинхронная загрузка с помощью setTimeout. При его выполнении в недавно созданном GlobalStore проставляется маркер <code>this.rootStore.global.shouldAppRender = true</code>.</p><br/>
<p>Таким образом, из <i>app.js</i> нужно перенести функцию рендеринга в файл <i>autorun.js</i>:</p><br/>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title">src/autorun.js</b>
                        <div class="spoiler_text"><pre><code class="javascript">/* eslint-disable no-unused-vars */

import { autorun } from 'mobx';

import { renderToDOM } from 'utils';
import App from 'components/App';

const loggingEnabled = true;

function logReason(autorunName, reaction) {
  if (!loggingEnabled || reaction.observing.length === 0) {
    return false;
  }

  const logString = reaction.observing.reduce(
    (str, { name, value }) => `${str}${name} changed to ${value}; `,
    ''
  );

  console.log(`autorun-${autorunName}`, logString);
}

/**
 * @param store {RootStore}
 */
export function initAutorun(store) {
  autorun(reaction => {
    if (store.global.shouldAppRender) {
      renderToDOM(App);
    }

    logReason('shouldAppRender', reaction);
  });
}
</code></pre></div>
                    </div><br/>
<p>В функции <i>initAutorun</i> может быть сколько угодно <i>autorun</i> конструкций с коллбэками, которые сработают только при собственной инициации и изменении переменной внутри конкретного коллбэка. В данном случае в консоль будет выведено <code>autorun-shouldAppRender GlobalStore@3.shouldAppRender changed to true;</code>, и вызван рендеринг приложения в DOM. Мощный инструмент, позволяющий логировать все изменения в сторе и соответственно на них реагировать.</p><br/>
<h3>Локализация и React Hooks</h3><br/>
<p>Перевод на другие языки — одна из самых объемных задач, в небольших компаниях зачастую недооцененная в десятки раз, а в крупных — излишне переусложненная. От ее реализации зависит, сколько нервов и времени не будет потрачено впустую сразу у нескольких отделов в компании. Затрону в статье только клиентскую часть с заделом на будущую интеграцию с другими системами.</p><br/>
<p>Для удобства разработки фронтенда необходимо иметь возможность:</p><br/>
<ul>
<li>задавать семантичные имена для констант;</li>
<li>вставлять динамические переменные;</li>
<li>указывать единственное / множественное число;</li>
<li>легко подключать локализацию куда угодно — функцией или реакт-компонентом;</li>
<li>не думать о пересечении названий параметров в разных компонентах;</li>
<li>при деплое собирать список всех добавленных / измененных параметров;</li>
<li>отлаживать локально;</li>
<li>(желательно) склонять по родам;</li>
<li>(желательно) со стороны бэка получать сообщения только в виде констант, для всех из них имея маппер на текущий язык.</li>
</ul><br/>
<p>Под эти условия подходит, к примеру, следующая схема: в каждом компоненте с текстами будет лежать файл <i>messages.js</i> с базовыми значениями для разработки (которые в идеале никогда не увидит клиент) в виде обычного объекта с параметрами. Вставка в компонент будет происходить однострочно с помощью хука. Полное название параметра будет формироваться автоматически по пути к файлу в проекте (при необходимости можно легко обфусцировать / сократить), что исключит пересечение названий. Функции преобразования текста (вставка переменных, склонений, чисел) выполняются последовательно. Должно получиться удобно.</p><br/>
<p>Так как уже есть стор с локализацией, в котором лежит <i>currentLanguage</i> и объект <i>i18n</i> с потенциально присутствующими переводами, можно написать хук, который будет получать оттуда тексты.</p><br/>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title">src/components/TestLocalization.js</b>
                        <div class="spoiler_text"><pre><code class="javascript">import React from 'react';

import { observer } from 'utils';
import { useLocalization } from 'hooks';

const messages = {
  hello: 'У вас {count} {count: сообщение,сообщения,сообщений}',
};

function TestLocalization() {
  const getLn = useLocalization(__filename, messages);

  return &lt;div>{getLn(messages.hello, { count: 1 })}&lt;/div>;
}

export const TestLocalizationConnected = observer(TestLocalization);
</code></pre></div>
                    </div><br/>
<p>Сам функциональный компонент имеет имя по названию файла, а на экспорт идет подключенный к MobX-стору автоматически обновляемый компонент с суффиксом, к примеру, Connected. Возможно, стоит внести подобное правило именования в ESLint, чтобы явно отличать подключенные к стору компоненты.</p><br/>
<p>Декоратор observer представляет собой обертку над <code>mobx-react-lite/useObserver</code>, которая при выключенном <i>HOT_RELOAD</i> оптимизирует обновление компонентов с помощью <i>React.memo</i> (в прошлом <i>PureMixin</i> / <i>PureComponent</i>), а при включенном просто оборачивает в <i>useObserver</i> все содержимое компонента:</p><br/>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title">src/utils/observer.js</b>
                        <div class="spoiler_text"><pre><code class="javascript">import { useObserver } from 'mobx-react-lite';
import React from 'react';

function copyStaticProperties(base, target) {
  const hoistBlackList = {
    $$typeof: true,
    render: true,
    compare: true,
    type: true,
  };

  Object.keys(base).forEach(key => {
    if (base.hasOwnProperty(key) &amp;&amp; !hoistBlackList[key]) {
      Object.defineProperty(
        target,
        key,
        Object.getOwnPropertyDescriptor(base, key)
      );
    }
  });
}

export function observer(baseComponent, options) {
  const baseComponentName = baseComponent.displayName || baseComponent.name;

  function wrappedComponent(props, ref) {
    return useObserver(function applyObserver() {
      return baseComponent(props, ref);
    }, baseComponentName);
  }
  wrappedComponent.displayName = baseComponentName;

  let memoComponent = null;
  if (HOT_RELOAD === 'true') {
    memoComponent = wrappedComponent;
  } else if (options.forwardRef) {
    memoComponent = React.memo(React.forwardRef(wrappedComponent));
  } else {
    memoComponent = React.memo(wrappedComponent);
  }

  copyStaticProperties(baseComponent, memoComponent);
  memoComponent.displayName = baseComponentName;

  return memoComponent;
}
</code></pre></div>
                    </div><br/>
<p>Внимания заслуживает только передача <code>displayName</code> на каждом этапе, чтобы в React-инспекторе были красивые названия элементов (на stack trace ошибок не влияет).</p><br/>
<p>Теперь нужен хук для вставки RootStore:</p><br/>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title">src/hooks/useStore.js</b>
                        <div class="spoiler_text"><pre><code class="javascript">import React from 'react';
import { store } from 'stores';

const storeContext = React.createContext(store);

/**
 * @returns {RootStore}
 *
 */
export function useStore() {
  return React.useContext(storeContext);
}
</code></pre></div>
                    </div><br/>
<p>Который можно легко использовать в любом компоненте, обернутом в observer:</p><br/>
<pre><code class="javascript">import React from 'react';

import { observer } from 'utils';
import { useStore } from 'hooks';

function TestComponent() {
  const store = useStore();

  return &lt;div>{store.i18n.currentLanguage}&lt;/div>;
}

export const TestComponentConnected = observer(TestComponent);
</code></pre><br/>
<p>Возвращаясь к созданному выше компоненту TestLocalization — осталось лишь сделать хук useLocalization:</p><br/>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title">src/hooks/useLocalization.js</b>
                        <div class="spoiler_text"><pre><code class="javascript">import _ from 'lodash';

import { declOfNum } from 'utils';

import { useStore } from './useStore';

const showNoTextMessage = false;

function replaceDynamicParams(values, formattedMessage) {
  if (!_.isPlainObject(values)) {
    return formattedMessage;
  }

  let messageWithValues = formattedMessage;

  Object.entries(values).forEach(([paramName, value]) => {
    messageWithValues = formattedMessage.replace(`{${paramName}}`, value);
  });

  return messageWithValues;
}

function replacePlurals(values, formattedMessage) {
  if (!_.isPlainObject(values)) {
    return formattedMessage;
  }

  let messageWithPlurals = formattedMessage;

  Object.entries(values).forEach(([paramName, value]) => {
    const pluralPattern = new RegExp(`{${paramName}:\\s([^}]*)}`);
    const pluralMatch = formattedMessage.match(pluralPattern);

    if (pluralMatch &amp;&amp; pluralMatch[1]) {
      messageWithPlurals = formattedMessage.replace(
        pluralPattern,
        declOfNum(value, pluralMatch[1].split(','))
      );
    }
  });

  return messageWithPlurals;
}

export function useLocalization(filename, messages) {
  const {
    i18n: { i18n, currentLanguage },
  } = useStore();

  return function getLn(text, values) {
    const key = _.findKey(messages, message => message === text);
    const localizedText = _.get(i18n, [filename, key]);

    if (!localizedText &amp;&amp; showNoTextMessage) {
      console.error(
        `useLocalization: no localization for lang '${currentLanguage}' in ${filename} ${key}`
      );
    }

    let formattedMessage = localizedText || text;
    formattedMessage = replaceDynamicParams(values, formattedMessage);
    formattedMessage = replacePlurals(values, formattedMessage);

    return formattedMessage;
  };
}
</code></pre></div>
                    </div><br/>
<p>Функции <i>replaceDynamicParams</i> и <i>replacePlurals</i> написаны для конкретного примера — вместо них можно использовать любой шаблонизатор для конкретных языков проекта и поддерживающий, например, строки с включенными объектами, массивы, форматирование дат, склонение имен и городов и т.п.</p><br/>
<p>Данный хук принимает в себя системную константу от Webpack — <i>__filename</i> — и объект с сообщениями, а возвращает функцию, которая непосредственно сходит в стор за значением. При желании можно включить отображение сообщений об отсутствии переводов, хотя при разработке это не нужно — переводы будут приходить на стенды из системы локализации, соответственно локально их все равно не будет, а отобразится значение по умолчанию. Но если все же включить, то сейчас в консоли отобразится:</p><br/>
<pre><code class="javascript">useLocalization: no localization for lang 'ru' in src\components\TestLocalization\TestLocalization.js hello
</code></pre><br/>
<p>Если же добавить локализацию для данного поля в <i>ru.json</i>:</p><br/>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title">src/localization/ru.json</b>
                        <div class="spoiler_text"><pre><code class="json">{
  "src\\components\\TestLocalization\\TestLocalization.js": {
    "hello": "У вас {count} {count: сообщение,сообщения,сообщений}"
  }
}
</code></pre></div>
                    </div><br/>
<p>То все заработает, как и ожидалось. А при добавлении в файл <i>src/localization/en.json</i> аналогичного перевода заработает и смена языков «на лету» с помощью метода <i>setLocalization</i> из I18nStore.</p><br/>
<p>Можно сделать и «привычный» в экосистеме React компонент Message:</p><br/>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title">src/components/Message/Message.js</b>
                        <div class="spoiler_text"><pre><code class="javascript">import React from 'react';

import { observer } from 'utils';
import { useLocalization } from 'hooks';

function Message(props) {
  const { filename, messages, text, values } = props;

  const getLn = useLocalization(filename, messages);

  return getLn(text, values);
}

const ConnectedMessage = observer(Message);

export function init(filename, messages) {
  return function MessageHoc(props) {
    const fullProps = { filename, messages, ...props };

    return &lt;ConnectedMessage {...fullProps} />;
  };
}
</code></pre></div>
                    </div><br/>
<p>Так как нужно каждый раз передавать переменную __filename (либо каждый раз уникальный id как в страшном сне разработчика), то импорт этого компонента будет немного необычным, однако использование стандартным:</p><br/>
<pre><code class="javascript">const Message = require('components/Message').init(
  __filename,
  messages
);

&lt;Message text={messages.hello} values={{ count: 1 }} />
</code></pre><br/>
<p>Из особенностей — при использовании в компоненте хука <i>useLocalization</i> и смене языка обновится весь компонент (так как он подписывается на изменение <i>currentLanguage</i>, а при использовании компонента Message — только сам текст. Однако это редкая операция, да и затраты на перерендеринг приложения при смене языка копеечные, поэтому я бы пользовался напрямую хуком.</p><br/>
<p>В завершение темы можно подумать, как удобнее в будущем состыковать этот подход с системой локализации (под ней подразумеваю административное приложение, в котором переводчики узнают о недостатках переводов, делают свои предложения в виде черновиков, менеджер / тестировщик проводят проверку на стенде и прикрепляют определенные черновики к релизам приложения в production). Так как в текущей схеме уникальные id параметров привязаны к пути к файлу, то можно при деплое на стенд пробегаться по всем <i>messages.js</i> и формировать <i>*.json</i> файл со списком всех переменных, привязанный к выкладываемой ветке. Затем этот файл автоматически загружать в систему локализации и дожидаться от переводчиков подходящих переводов (а в системе им подсветятся недостающие / удаленные), после чего осуществлять выкладку в production. Семантичность названий параметров и указание на файлы, в которых были правки, очень поможет переводчикам.</p><br/>
<p>В целом в связке MobX + Hooks клиентская локализация выглядит удобно. Для перевода констант и сообщений, приходящих с backend, нужно будет написать функцию, работающую непосредственно в сторе, с однотипным механизмом.</p><br/>
<h3>Работа с API</h3><br/>
<p>Ключевой момент при работе с любыми сторонними данными (с backend, из открытых источников или от пользователя) — это надежная валидация, которая даст уверенность, что фронтенд будет работать предсказуемо. Также полезно иметь централизованный список всех возможных запросов, с описанными передаваемыми и приходящими параметрами. Я бы реализовал это так:</p><br/>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title">src/stores/CurrentTPStore.js</b>
                        <div class="spoiler_text"><pre><code class="javascript">import _ from 'lodash';

import { makeObservable } from 'utils';
import { apiRoutes, request } from 'api';

@makeObservable
export class CurrentTPStore {
  /**
   * @param rootStore {RootStore}
   */
  constructor(rootStore) {
    this.rootStore = rootStore;
  }

  id = '';
  symbol = '';
  fullName = '';
  currency = '';
  tradedCurrency = '';
  low24h = 0;
  high24h = 0;
  lastPrice = 0;
  marketCap = 0;
  change24h = 0;
  change24hPercentage = 0;

  fetchSymbol(params) {
    const { tradedCurrency, id } = params;
    const { marketsList } = this.rootStore;

    const requestParams = {
      id,
      localization: false,
      community_data: false,
      developer_data: false,
      tickers: false,
    };

    return request(apiRoutes.symbolInfo, requestParams)
      .then(data => this.fetchSymbolSuccess(data, tradedCurrency))
      .catch(this.fetchSymbolError);
  }
  fetchSymbolSuccess(data, tradedCurrency) {
    const {
      id,
      symbol,
      name,
      market_data: {
        high_24h,
        low_24h,
        price_change_24h_in_currency,
        price_change_percentage_24h_in_currency,
        market_cap,
        current_price,
      },
    } = data;

    this.id = id;
    this.symbol = symbol;
    this.fullName = name;
    this.currency = symbol;
    this.tradedCurrency = tradedCurrency;
    this.lastPrice = current_price[tradedCurrency];
    this.high24h = high_24h[tradedCurrency];
    this.low24h = low_24h[tradedCurrency];
    this.change24h = price_change_24h_in_currency[tradedCurrency];
    this.change24hPercentage =
      price_change_percentage_24h_in_currency[tradedCurrency];
    this.marketCap = market_cap[tradedCurrency];

    return Promise.resolve();
  }
  fetchSymbolError(error) {
    console.error(error);
  }
}
</code></pre></div>
                    </div><br/>
<p>К примеру, есть стор, содержащий информацию об открытой торговой паре. Для получения данных вызывается метод <i>fetchSymbol</i>, в который передается id необходимой валюты и валюта, к которой идет торговля. Далее выполняется запрос через утилиту, при успехе — в единой транзакции обновляются данные в сторе (так как все методы автоматически оборачиваются в <code>@action.bound</code>), а при ошибке она логируется в Sentry благодаря декоратору в функции инициализации:</p><br/>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title">src/utils/initSentry.js</b>
                        <div class="spoiler_text"><pre><code class="javascript">import * as Sentry from '@sentry/browser';

export function initSentry() {
  if (SENTRY_URL !== 'false') {
    Sentry.init({
      dsn: SENTRY_URL,
    });

    const originalErrorLogger = console.error;
    console.error = function consoleErrorCustom(...args) {
      Sentry.captureException(...args);

      return originalErrorLogger(...args);
    };
  }
}
</code></pre></div>
                    </div><br/>
<p>Данный запрос наиболее показателен, так как использует сразу весь функционал валидации запросов:</p><br/>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title">src/api/_api.js</b>
                        <div class="spoiler_text"><pre><code class="javascript">import _ from 'lodash';

import {
  omitParam,
  validateRequestParams,
  makeRequestUrl,
  makeRequest,
  validateResponse,
} from 'api/utils';

export function request(route, params) {
  return Promise.resolve()
    .then(validateRequestParams(route, params))
    .then(makeRequestUrl(route, params))
    .then(makeRequest)
    .then(validateResponse(route, params));
}

export const apiRoutes = {
  symbolInfo: {
    url: params => `https://api.coingecko.com/api/v3/coins/${params.id}`,
    params: {
      id: omitParam,
      localization: _.isBoolean,
      community_data: _.isBoolean,
      developer_data: _.isBoolean,
      tickers: _.isBoolean,
    },
    responseObject: {
      id: _.isString,
      name: _.isString,
      symbol: _.isString,
      genesis_date: v => _.isString(v) || _.isNil(v),
      last_updated: _.isString,
      country_origin: _.isString,

      coingecko_rank: _.isNumber,
      coingecko_score: _.isNumber,
      community_score: _.isNumber,
      developer_score: _.isNumber,
      liquidity_score: _.isNumber,
      market_cap_rank: _.isNumber,
      block_time_in_minutes: _.isNumber,
      public_interest_score: _.isNumber,

      image: _.isPlainObject,
      links: _.isPlainObject,
      description: _.isPlainObject,
      market_data: _.isPlainObject,
      localization(value, requestParams) {
        if (requestParams.localization === false) {
          return true;
        }

        return _.isPlainObject(value);
      },
      community_data(value, requestParams) {
        if (requestParams.community_data === false) {
          return true;
        }

        return _.isPlainObject(value);
      },
      developer_data(value, requestParams) {
        if (requestParams.developer_data === false) {
          return true;
        }

        return _.isPlainObject(value);
      },
      public_interest_stats: _.isPlainObject,

      tickers(value, requestParams) {
        if (requestParams.tickers === false) {
          return true;
        }

        return _.isArray(value);
      },
      categories: _.isArray,
      status_updates: _.isArray,
    },
  },
};
</code></pre></div>
                    </div><br/>
<p>Схема работы функции request следующая:</p><br/>
<ol>
<li>принимает объект из apiRoutes и параметры для запроса;</li>
<li>проверяет соответствие параметров запроса схеме, описанной в route.params, при этом опуская валидирующие функции, заданные с помощью <i>omitParam</i>;</li>
<li>формирует итоговый URL запроса исходя из <code>route.url</code> — если это функция, то передает в нее параметры запроса, если строка — то просто добавляет get-параметры к URL;</li>
<li>выполняет запрос с помощью fetch, возвращая преобразованный в объект JSON;</li>
<li>проверяет соответствие параметров ответа схеме, описанной в <code>route.responseObject</code> либо <code>route.responseArray</code> (если ожидается ответ в виде массива). Первым аргументом в функцию валидации передается значение, а вторым — исходные параметры запроса, чтобы иметь возможность динамической валидации;</li>
<li>при любом несовпадении параметров запроса / ответа / адреса запроса / статуса ответа выбрасывается исключение с понятным сообщением, которое ловится в методе стора (в данном случае <i>fetchSymbolError</i>) и логируется.</li>
</ol><br/>
<p>Подобная схема позволяет быть полностью уверенным в получаемых данных и оперативно реагировать на залогированные ошибки. Например, так выглядит сообщение в Sentry, если не совпал тип одной из переменных в response:</p><br/>
<p><img src="/img/image-loader.svg" data-src="https://habrastorage.org/webt/mk/7y/8s/mk7y8sh2cushkehhykrrufsvkre.png"/></p><br/>
<p>Впоследствии необходимо будет внедрить глубокую валидацию ответа — на отзывчивость приложения выполнение простой функции несколько тысяч раз влияет слабо (при необходимости валидацию можно выполнять в отдельном потоке), но многократно повышает стабильность.</p><br/>
<h3>Роутинг и отказоустойчивость</h3><br/>
<p>Тема еще более объемная, и заслуживает отдельной статьи соразмерной с данной, но проговорить принципы и сделать минимальную реализацию можно. Так, для хорошего роутера нужны:</p><br/>
<ul>
<li>единое хранилище всех роутов с возможностью использовать элементы в ссылках;</li>
<li>динамические параметры в pathname и search;</li>
<li>валидация динамических параметров регулярным выражением / функцией;</li>
<li>двусторонняя синхронизация location и состояния приложения в сторах;</li>
<li>возможность вызова асинхронных функций в beforeEnter, с передачей в компонент параметра isLoading, пока происходит выполнение;</li>
<li>возможность указать стратегию отказоустойчивости в случаях: не совпала маска, не найден подходящий роут, не найден компонент, исключение в beforeEnter, исключение при асинхронных загрузках данных;</li>
<li>поддержка событий перехода назад / вперед в браузере;</li>
<li>возможность полного / частичного отката до состояния перед переходом на роут;</li>
<li>поддержка анимации переходов между состояниями.</li>
</ul><br/>
<p>Для начала сделаю только «скелет», который позволит разблокировать развитие продукта и беспрепятственно начать писать компоненты и бизнес-логику, так как полнофункциональный роутинг — задача не на одну неделю. Для начала понадобятся файлы с конфигурацией роутов:</p><br/>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title">src/routes.js</b>
                        <div class="spoiler_text"><pre><code class="javascript">export const routes = {
  marketDetailed: {
    name: 'marketDetailed',
    path: '/market/:market/:pair',
    masks: {
      pair: /^[a-zA-Z]{3,5}-[a-zA-Z]{3}$/,
      market: /^[a-zA-Z]{3,4}$/,
    },
    beforeEnter(route, store) {
      const {
        params: { pair, market },
      } = route;
      const [symbol, tradedCurrency] = pair.split('-');
      const prevMarket = store.marketsList.currentMarket;

      function optimisticallyUpdate() {
        store.marketsList.currentMarket = market;
      }

      return Promise.resolve()
        .then(optimisticallyUpdate)
        .then(store.marketsList.fetchSymbolsList)
        .then(store.rates.fetchRates)
        .then(() => store.marketsList.fetchMarketList(market, prevMarket))
        .then(() =>
          store.currentTP.fetchSymbol({
            symbol,
            tradedCurrency,
          })
        )
        .catch(error => {
          console.error(error);
        });
    },
  },
  error404: {
    name: 'error404',
    path: '/error404',
  },
};
</code></pre></div>
                    </div><br/>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title">src/routeComponents.js</b>
                        <div class="spoiler_text"><pre><code class="javascript">import { MarketDetailed } from 'pages/MarketDetailed';
import { Error404 } from 'pages/Error404';

export const routeComponents = {
  marketDetailed: MarketDetailed,
  error404: Error404,
};
</code></pre></div>
                    </div><br/>
<p>Компоненты, соответствующие роутам, вынесены в отдельный файл для защиты от цикличной зависимости — если в компонентах использовать удобные конструкторы ссылок вида <code>&lt;Link route={routes.marketDetailed}></code>, то возникнет цикличный импорт. Webpack в некоторых случаях умеет справляться с этим, но лучше не полагаться на удачу.</p><br/>
<p>Теперь необходим стор, который двусторонне свяжет location и подходящий роут из списка выше.</p><br/>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title">src/stores/RouterStore.js</b>
                        <div class="spoiler_text"><pre><code class="javascript">import _ from 'lodash';

import { makeObservable } from 'utils';
import { routes } from 'routes';

@makeObservable
export class RouterStore {
  /**
   * @param rootStore {RootStore}
   */
  constructor(rootStore) {
    this.rootStore = rootStore;
    this.currentRoute = this._fillRouteSchemaFromUrl();

    window.addEventListener('popstate', () => {
      this.currentRoute = this._fillRouteSchemaFromUrl();
    });
  }

  currentRoute = null;

  _fillRouteSchemaFromUrl() {
    const pathnameArray = window.location.pathname.split('/');
    const routeName = this._getRouteNameMatchingUrl(pathnameArray);

    if (!routeName) {
      const currentRoute = routes.error404;
      window.history.pushState(null, null, currentRoute.path);

      return currentRoute;
    }

    const route = routes[routeName];
    const routePathnameArray = route.path.split('/');

    const params = {};

    routePathnameArray.forEach((pathParam, i) => {
      const urlParam = pathnameArray[i];

      if (pathParam.indexOf(':') === 0) {
        const paramName = pathParam.replace(':', '');
        params[paramName] = urlParam;
      }
    });

    return Object.assign({}, route, { params, isLoading: true });
  }

  _getRouteNameMatchingUrl(pathnameArray) {
    return _.findKey(routes, route => {
      const routePathnameArray = route.path.split('/');

      if (routePathnameArray.length !== pathnameArray.length) {
        return false;
      }

      for (let i = 0; i &lt; routePathnameArray.length; i++) {
        const pathParam = routePathnameArray[i];
        const urlParam = pathnameArray[i];

        if (pathParam.indexOf(':') !== 0) {
          if (pathParam !== urlParam) {
            return false;
          }
        } else {
          const paramName = pathParam.replace(':', '');
          const paramMask = _.get(route.masks, paramName);

          if (paramMask &amp;&amp; !paramMask.test(urlParam)) {
            return false;
          }
        }
      }

      return true;
    });
  }

  replaceDynamicParams(route, params) {
    return Object.entries(params).reduce((pathname, [paramName, value]) => {
      return pathname.replace(`:${paramName}`, value);
    }, route.path);
  }

  goTo(route, params) {
    if (route.name === this.currentRoute.name) {
      if (_.isEqual(this.currentRoute.params, params)) {
        return false;
      }

      this.currentRoute.isLoading = true;
      this.currentRoute.params = params;

      const newPathname = this.replaceDynamicParams(this.currentRoute, params);

      window.history.pushState(null, null, newPathname);

      return false;
    }

    const newPathname = this.replaceDynamicParams(route, params);

    window.history.pushState(null, null, newPathname);

    this.currentRoute = this._fillRouteSchemaFromUrl();
  }
}
</code></pre></div>
                    </div><br/>
<p>Схема работает достаточно просто — в конструкторе стора осуществляется поиск подходящего роута из <i>routes.js</i> и проверка всех динамических параметров по маске. Если роут не найдет или параметр не соответствует маске — происходит редирект на страницу с ошибкой 404. Разумеется, при развитии роутера нужно включить возможность «найти максимально похожий роут и перейти на него с дефолтными параметрами», и эту же стратегию использовать, если данные все же прошли маску, но некорректные — например, пользователь попробовал запросить данные по торговой паре 'test-test'.</p><br/>
<p>Далее в <i>currentRoute</i> записывается подходящий роут, обогащенный объектом <i>params</i> (значения переменных из URL) и <code>isLoading: true</code>. Теперь свою работу может начать React-компонент Router:</p><br/>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title">src/components/Router.js</b>
                        <div class="spoiler_text"><pre><code class="javascript">import React from 'react';
import _ from 'lodash';

import { useStore } from 'hooks';
import { observer } from 'utils';
import { routeComponents } from 'routeComponents';

function getRouteComponent(route, isLoading) {
  const Component = routeComponents[route.name];

  if (!Component) {
    console.error(
      `getRouteComponent: component for ${
        route.name
      } is not defined in routeComponents`
    );

    return null;
  }

  return &lt;Component isLoading={isLoading} />;
}

function useBeforeEnter() {
  const store = useStore();
  const { currentRoute } = store.router;

  React.useEffect(() => {
    if (currentRoute.isLoading) {
      const beforeEnter = _.get(currentRoute, 'beforeEnter');

      if (_.isFunction(beforeEnter)) {
        Promise.resolve()
          .then(() => beforeEnter(currentRoute, store))
          .then(() => {
            currentRoute.isLoading = false;
          })
          .catch(error => console.error(error));
      } else {
        currentRoute.isLoading = false;
      }
    }
  });

  return currentRoute.isLoading;
}

function Router() {
  const {
    router: { currentRoute },
  } = useStore();
  const isLoading = useBeforeEnter();

  return getRouteComponent(currentRoute, isLoading);
}

export const RouterConnected = observer(Router);
</code></pre></div>
                    </div><br/>
<p>Когда рендерится этот компонент, хранилище уже давно инициализировалось и нашло подходящий роут, поэтому смысла проверять на <code>currentRoute == null</code> нет. Основная идея компонента — если у текущего роута параметр <code>isLoading === true</code>, то передавать этот параметр в компонент и менять его на false только после того, как полностью выполнится <code>route.beforeEnter</code> (если есть). Вместо описанной в принципах роутинга необходимости применять стратегии отказоустойчивости здесь постыдный <code>console.error</code>, как напоминание о том, что работы еще предстоит море.</p><br/>
<p>Следующий вопрос, который предстоит решить — где и когда запрашивать данные, необходимые для страницы. В React-сообществе распространены 2 подхода:</p><br/>
<ol>
<li>компоненты в цикле componentWillMount / componentDidMount / useEffect сами определяют, какие методы у сторов вызвать, чтобы получить данные. В этом случае они могут работать модульно — показывать внутри себя анимированные лоадеры, при ошибке одного из запросов показывать заглушку и кнопку «перезагрузить». Слабое место — когда нескольким компонентам нужны одинаковые данные — исправляется вынесением общих запросов на уровень общего родителя;</li>
<li>глобальный компонент страницы (либо роут) в едином месте делает все запросы за данными, которые нужны потомкам. Преимущество — возможность использовать общую стратегию отказоустойчивости — особенно полезно, когда абсолютно все данные и компоненты на странице должны работать. Слабое место — невозможность обновить данные конкретного компонента / виджета — решается настройкой real-time обновления по запросам, на которые страница подписывается / отписывается в едином месте.</li>
</ol><br/>
<p>Можно удобно реализовать любой из этих подходов, но для торгового интерфейса все же выберу второй — раньше у бирж встречал модульность (когда работает все, кроме графика, или работает только график без балансов и списка торговых пар и т.п.), но со временем они тоже отказались от этого подхода.</p><br/>
<p>Поэтому все запросы буду делать в методе <i>beforeEnter</i>, по схеме: «оптимистичное обновление», последовательные запросы за данными (в будущем, конечно, необходимо использовать параллельные с возможностью прерывания), при различных ошибках — различные стратегии исправления (блокирование всей страницы с перезапросом всех данных несколько раз — если сервер отвечает 500 ошибками; откат до предыдущего состояния приложения если сервер отвечает некорректными данными; нотификация о том, что определенный блок с данными сейчас недоступен; редирект на роут с дефолтными параметрами и т.п.). В данном «скелете» приложения это все не реализовано, так как для самого продукта на этапе MVP пользы принесет мало.</p><br/>
<p>Последним элементом роутинга будет компонент для создания ссылок:</p><br/>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title">src/components/Link.js</b>
                        <div class="spoiler_text"><pre><code class="javascript">import React from 'react';
import _ from 'lodash';

import { useStore } from 'hooks';
import { observer } from 'utils';

function checkRouteParamsWithMasks(route, params) {
  if (route.masks) {
    Object.entries(route.masks).forEach(([paramName, paramMask]) => {
      const value = _.get(params, paramName);

      if (paramMask &amp;&amp; !paramMask.test(value)) {
        console.error(
          `checkRouteParamsWithMasks: wrong param for ${paramName} in Link to ${
            route.name
          }: ${value}`
        );
      }
    });
  }
}

function Link(props) {
  const store = useStore();
  const { currentRoute } = store.router;
  const { route, params, children, onClick, ...otherProps } = props;

  checkRouteParamsWithMasks(route, params);

  const filledPath = store.router.replaceDynamicParams(route, params);

  return (
    &lt;a
      href={filledPath}
      onClick={e => {
        e.preventDefault();

        if (currentRoute.isLoading) {
          return false;
        }

        store.router.goTo(route, params);

        if (onClick) {
          onClick();
        }
      }}
      {...otherProps}
    >
      {children}
    &lt;/a>
  );
}

export const LinkConnected = observer(Link);
</code></pre></div>
                    </div><br/>
<p>Этот компонент принимает параметр <i>route</i>, валидирует переданные динамические <i>params</i> (если есть) на этапе создания ссылки (чтобы фронтенд сам себя не смог поломать при клике) и заполняет <i>href</i> заполненным адресом. Кроме этого, если у текущего роута все еще загружаются данные в методе <i>beforeEnter</i>, переход по ссылке блокируется. Можно показывать нотификацию из разряда «подождите, идет загрузка», либо откладывать переход до завершения текущей загрузки, либо прерывать все запросы и форсированно переходить на новую страницу — в зависимости от потребности.</p><br/>
<h3>Метрики</h3><br/>
<p>Касательно бизнес-метрик (переходы на страницы, клики по кнопкам, отправка заполненных форм, количество возникновения ошибок, поведение пользователя на странице) в общем случае достаточно Яндекс.Вебвизор или аналога с автоматическим сбором. Для приложения биржи не нужна система замера сложнодостижимых целей вроде заполнения многостраничных форм и выполнения комплекса действий.</p><br/>
<p>А вот отзывчивость приложения — время полной отрисовки страницы и длительность запросов за данными, включая валидацию — измерять необходимо, чтобы иметь возможность сделать эффективную точечную оптимизацию. Измерить длительность запросов можно было бы такой утилитой:</p><br/>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title">src/api/utils/metrics.js</b>
                        <div class="spoiler_text"><pre><code class="javascript">import _ from 'lodash';

let metricsArray = [];
let sendMetricsCallback = null;

export function startMetrics(route, apiRoutes) {
  return function promiseCallback(data) {
    clearTimeout(sendMetricsCallback);
    const apiRouteName = _.findKey(apiRoutes, route);

    metricsArray.push({
      id: apiRouteName,
      time: new Date().getTime(),
    });

    return data;
  };
}

export function stopMetrics(route, apiRoutes) {
  return function promiseCallback(data) {
    const apiRouteName = _.findKey(apiRoutes, route);
    const metricsData = _.find(metricsArray, ['id', apiRouteName]);

    metricsData.time = new Date().getTime() - metricsData.time;

    clearTimeout(sendMetricsCallback);
    sendMetricsCallback = setTimeout(() => {
      console.log('Metrics sent:', metricsArray);
      metricsArray = [];
    }, 2000);

    return data;
  };
}
</code></pre></div>
                    </div><br/>
<p>И включив эти две middleware в функцию <i>request</i>:</p><br/>
<pre><code class="javascript">export function request(route, params) {
  return Promise.resolve()
    .then(startMetrics(route, apiRoutes))
    .then(validateRequestParams(route, params))
    .then(makeRequestUrl(route, params))
    .then(makeRequest)
    .then(validateResponse(route, params))
    .then(stopMetrics(route, apiRoutes))
    .catch(error => {
      stopMetrics(route, apiRoutes)();

      throw error;
    });
}
</code></pre><br/>
<p>Таким образом, длительность запросов аггрегируется, если перерыв между ними составил более 2 секунд, и отправится в некую систему мониторинга (в данном случае в консоль) единым массивом. Часто замеры производительности производится только на сервере — от поступления запроса до отдачи результата, но эта практика дает однобокую статистику — в реальности у клиента запрос может выполняться в разы дольше, и нужно собирать детализированную (в идеале) статистику по каждому этапу запроса, исходя из клиентского опыта.</p><br/>
<p>Теперь можно приступать к кодированию бизнес-логики и компонентов — в этом <a href="https://dkazakov8.github.io/exchange_habr/dist/" rel="nofollow">демо</a> полностью реализовал первоначальное задание заказчика.</p><br/>
<h3>Интеграционные тесты</h3><br/>
<p>Про принципы и значение end-to-end тестирования информации много, в том числе в <a href="https://docs.cypress.io/guides/overview/why-cypress.html" rel="nofollow">документации</a> к выбранному инструменту Cypress. С точки зрения разработки в них важны: легкость развертывания; удобство поддержки и развития, в том числе для тестировщиков; легкость встраивания в Continious Integration.</p><br/>
<p>Так как данный инструмент состоит всего из одного пакета и написан на javascript с похожим на Chai / Sinon синтаксисом, обычно проблем с развитием инструментария не возникает. Однако не радует долгая установка самого пакета, поэтому устанавливать желательно в отдельную папку, в моем случае — ./tests, в <i>package.json</i> которого будет единственная зависимость — <code>"dependencies": { "cypress": "3.2.0" }</code></p><br/>
<p>После установки инструмент сам создаст структуру папок с многочисленными примерами для обучения. Для максимального удобства нужно синхронизировать возможности встроенного в него Webpack и общей конфигурации проекта:</p><br/>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title">tests/cypress/plugins/index.js</b>
                        <div class="spoiler_text"><pre><code class="javascript">const webpack = require('../../../node_modules/@cypress/webpack-preprocessor');
const webpackConfig = require('../../../webpack-custom/webpack.config');

module.exports = on => {
  const options = webpack.defaultOptions;

  options.webpackOptions.module = webpackConfig.module;
  options.webpackOptions.resolve = webpackConfig.resolve;

  on('file:preprocessor', webpack(options));
};
</code></pre></div>
                    </div><br/>
<p>Для этого потребовалась установка всего лишь одного пакета в основной проект. Синхронизировать достаточно лишь <i>module</i> (для использования идентичного синтаксиса) и <i>resolve</i> (чтобы работали все алиасы и импорты файлов как в основном проекте). В плагинах ESLint для корректного распознавания глобальных переменных (вроде <i>describe</i>, <i>cy</i>) нужен дополнительный плагин <i>eslint-plugin-cypress</i>. На этом настройка закончена, и вот так может выглядеть проверочный тест:</p><br/>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title">tests/cypress/integration/mixed.js</b>
                        <div class="spoiler_text"><pre><code class="javascript">describe('Market Listing good scenarios', () => {
  it('Lots of mixed tests', () => {
    cy.visit('/market/usd/bch-usd');
    cy.location('pathname').should('equal', '/market/usd/bch-usd');

    // Проверка ответа на запрос, хотя для этого уже есть валидаторы
    cy.wait('@symbolsList')
      .its('response.body')
      .should(data => {
        expect(data).to.be.an('array');
      });

    // Дожидаемся всех запросов
    cy.wait('@rates');
    cy.wait('@marketsList');
    cy.wait('@symbolInfo');
    cy.wait('@chartData');

    // Проверяем переход на другую торгуемую валюту
    cy.get('#marketTab-eth').click();
    cy.location('pathname').should('equal', '/market/eth/bch-usd');
    cy.wait('@rates');
    cy.wait('@marketsList');

    // Проверяем изменение локализации
    cy.contains('Рынки');
    cy.get('#langSwitcher-en').click();
    cy.contains('Markets list');

    // Проверяем изменение темы
    cy.get('body').should('have.class', 'light');
    cy.get('#themeSwitcher-dark').click();
    cy.get('body').should('have.class', 'dark');
  });
});
</code></pre></div>
                    </div><br/>
<p>Так как на текущий момент Cypress не поддерживает протокол fetch, можно применить полифилл, и заодно указать роуты для запросов:</p><br/>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title">tests/cypress/support/index.js</b>
                        <div class="spoiler_text"><pre><code class="javascript">import { apiRoutes } from 'api';

let polyfill = null;

before(() => {
  const polyfillUrl = 'https://unpkg.com/unfetch/dist/unfetch.umd.js';
  cy.request(polyfillUrl).then(response => {
    polyfill = response.body;
  });
});

Cypress.on('window:before:load', window => {
  delete window.fetch;
  window.eval(polyfill);
  window.fetch = window.unfetch;
});

before(() => {
  cy.server();
  cy.route(`${apiRoutes.symbolsList.url}**`).as('symbolsList');
  cy.route(`${apiRoutes.rates.url}**`).as('rates');
  cy.route(`${apiRoutes.marketsList.url}**`).as('marketsList');
  cy.route(`${apiRoutes.symbolInfo.url({ id: 'bitcoin-cash' })}**`).as(
    'symbolInfo'
  );
  cy.route(`${apiRoutes.chartData.url}**`).as('chartData');
});
</code></pre></div>
                    </div><br/>
<p>Собственно все, можно создавать удобные команды и обучать тестировщиков.</p><br/>
<h3>Всего лишь, так просто?</h3><br/>
<p>Да, на этом шаге создана неблокирующая бизнес-разработку архитектура. Можно написать небольшую документацию по использованию и заложенным принципам, составить стандарты кодирования и приема качества, и привлечь коллег-разработчиков для кодирования компонентов / бизнес-логики / стилей.</p><br/>
<p>А в это время, честно отдавая себе отчет, что по описанным принципам работа сделана едва ли на половину, месяц-два добрабатывать, тщательно покрывая юнит-тестами утилиты перед тем, как переходить к следующим этапам архитектуры (real-time взаимодействие, подключение serviceWorker, интеграция в CI, кроссбраузерность и полифиллы, гибкое управление правами отображения и функционирования элементов, настройка бизнес-метрик, мобильная версия, автоматизация рутинных задач и т.п.).</p><br/>
<p>Размеры итоговых файлов (с Gzip) вполне адекватны:</p><br/>
<p><img src="/img/image-loader.svg" data-src="https://habrastorage.org/webt/p6/im/fk/p6imfkqh0-lf8zlr2apy_8zjqcm.png"/></p><br/>
<p>И структура компонентов в React Developer Tools выглядит очень приятно:</p><br/>
<p><img src="/img/image-loader.svg" data-src="https://habrastorage.org/webt/im/jn/_l/imjn_lzweyq7yijk7ohnlafcpgo.png"/></p><br/>
<p>В целом работать в связке React Hooks + MobX понравилось намного больше, чем с Redux. Надеюсь, мой взгляд на архитектуру приложения поможет избежать лишних затрат времени. Если же выпустить продукт хотя бы без одного из описанных элементов, велика вероятность, что он понадобится в то время, когда внедрение займет месяцы и будет сопряжено со сложным рефакторингом. Лучше спроектировать это на этапе создания архитектуры. Всем интересной разработки!</p><br/>
<p><a href="https://github.com/dkazakov8/habr_exchange" rel="nofollow">Весь код</a></p><br/>
<br/>
<h3>Update 13.07.2019</h3><br/>
<p>Благодарю сообщество за конструктивные комментарии и письма, после использования описанной выше архитектуры назрел довольно большой список доработок, которыми рад поделиться:</p><br/>
<p>1. Отсутствие <i>yarn.lock</i> приводило к разным хешам после сборки, как и использование <code>yarn install --force</code>, но проблема легко решилась скриптом <code>"upd": "yarn install &amp;&amp; yarn add file:./eslint-custom &amp;&amp; yarn add file:./webpack-custom"</code>. В данном случае обновляются зависимости только у не влияющих на итоговую сборку ESLint и Webpack.</p><br/>
<p>2. Пути к папкам в webpack-custom/config/configOptimization.js, описаны не кроссплатформенно, и вместо</p><br/>
<pre><code class="javascript">lodash: {
  test: module => module.context.indexOf('node_modules\\lodash') !== -1,
  name: 'lodash',
  chunks: 'all',
  enforce: true,
}
</code></pre><br/>
<p>должно быть</p><br/>
<pre><code class="javascript">lodash: {
  test: /node_modules[\\/]lodash/,
  name: 'lodash',
  chunks: 'all',
  enforce: true,
}
</code></pre><br/>
<p>3. При работе с локализацией передавать каждый раз параметры в <code>useLocalization(__filename, messages)</code> утомительно, выход — переделать параметры в объекты вида</p><br/>
<pre><code class="javascript">const messages = {
  hello: {
    value: 'У вас {count} {count: сообщение,сообщения,сообщений}',
    name: "src/components/TestLocalization/TestLocalization.hello",
  }
};
</code></pre><br/>
<p>например, с помощью функции</p><br/>
<pre><code class="javascript">const messagesDefault = {
  hello: 'У вас {count} {count: сообщение,сообщения,сообщений}',
};

export const messages = Object.keys(messagesDefault).reduce((acc, key) => {
  acc[key] = {
   value: messagesDefault[key],
   name: __dirname.toLowerCase().replace(/\\\\/g, '/') + '.' + key,
  };

  return acc;
}, {});
</code></pre><br/>
<p>Но так как в IDE в таком случае перестает работать автодополнение, это преобразование можно выполнять в лоадере Webpack:</p><br/>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title">webpack-custom/utils/messagesLoader.js</b>
                        <div class="spoiler_text"><pre><code class="javascript">module.exports = function messagesLoader(source) {
  if (source.indexOf('export const messages = messagesDefault;') !== -1) {
    return source.replace(
      'export const messages = messagesDefault;',
      `
  export const messages = Object.keys(messagesDefault).reduce((acc, key) => {
    acc[key] = {
      value: messagesDefault[key],
      name: __dirname.toLowerCase().replace(/\\\\/g, '/') + '.' + key,
    };
    return acc;
  }, {});
    `
    );
  }

  return source;
};
</code></pre></div>
                    </div><br/>
<p>Соответственно, файлы <i>messages.js</i> теперь имеют содержание:</p><br/>
<pre><code class="javascript">const messagesDefault = {
  someText: 'Завершить',
};

export const messages = messagesDefault;
</code></pre><br/>
<p>Также для повышения удобства работы с текстами очень пригодилась утилита, вызываемая в <i>app.js</i>, которая пробегается по всем файлам <i>messages.js</i> и показывает, каких ключей не хватает в <i>*.json</i> файлах локализации:</p><br/>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title">src/utils/checkLocalization.js</b>
                        <div class="spoiler_text"><pre><code class="javascript">import _ from 'lodash';

import ru from 'localization/ru.json';

const showNoTextMessage = true;

export function checkLocalization() {
  const context = require.context('../', true, /messages\.js/);
  const messagesFiles = context.keys();
  const notLocalizedObject = {};

  messagesFiles.forEach(path => {
    const fileExports = context(path);
    const { messages } = fileExports;
    _.values(messages).forEach(({ name, value }) => {
      if (ru[name] == null) {
        notLocalizedObject[name] = value;
      }
    });
  });

  if (showNoTextMessage &amp;&amp; _.size(notLocalizedObject) > 0) {
    console.log(
      'No localization for lang ru:',
      JSON.stringify(notLocalizedObject, null, 2)
    );
  }
}
</code></pre></div>
                    </div><br/>
<p>Таким образом, в консоли всплывет сообщение вида</p><br/>
<pre><code class="plaintext">No localization for lang ru: {
  "src/components/TestLocalization/TestLocalization.hello": "У вас {count} {count: сообщение,сообщения,сообщений}"
}
</code></pre><br/>
<p>которое нужно просто скопировать в соответствующий <i>*.json</i> файл — разумеется, только если в проекте нет отдельной системы для работы с переводами, а тексты лежат в репозитории.</p><br/>
<p>3. Валидаторы для АПИ в виде функций Lodash вроде <code>someResponseParam: _.isString</code> хотя и работают, но не расширяемы и не дают возможность вывести текст ошибки в удобном виде. Поэтому лучше обернуть их в кастомный объект:</p><br/>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title">src/utils/validateObjects.js</b>
                        <div class="spoiler_text"><pre><code class="javascript">import _ from 'lodash';

import { createError } from './createError';
import { errorsNames } from 'const';

export const validators = {
  isArray(v) {
    return _.isArray(v);
  },
  isString(v) {
    return _.isString(v);
  },
  isNumber(v) {
    return _.isNumber(v);
  },
  isBoolean(v) {
    return _.isBoolean(v);
  },
  isPlainObject(v) {
    return _.isPlainObject(v);
  },

  isArrayNotRequired(v) {
    return _.isArray(v) || _.isNil(v);
  },
  isStringNotRequired(v) {
    return _.isString(v) || _.isNil(v);
  },
  isNumberNotRequired(v) {
    return _.isNumber(v) || _.isNil(v);
  },
  isBooleanNotRequired(v) {
    return _.isBoolean(v) || _.isNil(v);
  },
  isPlainObjectNotRequired(v) {
    return _.isPlainObject(v) || _.isNil(v);
  },

  omitParam() {
    return true;
  },
};

validators.isArray.notRequired = validators.isArrayNotRequired;
validators.isString.notRequired = validators.isStringNotRequired;
validators.isNumber.notRequired = validators.isNumberNotRequired;
validators.isBoolean.notRequired = validators.isBooleanNotRequired;
validators.isPlainObject.notRequired = validators.isPlainObjectNotRequired;

export function validateObjects(
  { validatorsObject, targetObject, prefix },
  otherArg
) {
  if (!_.isPlainObject(validatorsObject)) {
    throw new Error(`validateObjects: validatorsObject is not an object`);
  }

  if (!_.isPlainObject(targetObject)) {
    throw new Error(`validateObjects: targetObject is not an object`);
  }

  Object.entries(validatorsObject).forEach(([paramName, validator]) => {
    const paramValue = targetObject[paramName];

    if (!validator(paramValue, otherArg)) {
      const validatorName = _.findKey(validators, v => v === validator);
      throw createError(
        errorsNames.VALIDATION,
        `${prefix || ''}${paramName}${
          _.isString(validatorName) ? ` [${validatorName}]` : ''
        }`
      );
    }
  });
}
</code></pre></div>
                    </div><br/>
<p>Такая небольшая обертка позволяет включать название валидатора в текст ошибки — например, <code>с сервера пришел некорректный параметр someResponseParam [isString]</code>, сразу давая понять, какой тип был ожидаем. Также можно указать <code>someResponseParam: validators.isString.notRequired</code>, что сделает параметр необязательным. В реальном проекте в дополнение к этим валидаторам понадобились динамические, которые выбирают тип ответа в зависимости от отправленных параметров, а также проверки массивов вида <code>someResponseArray: arrayShape({ someParam: isString })</code>, которые без проблем интегрируются в подобную схему.</p><br/>
<p>5. Роутинг, как и ожидалось, потребовалось значительно развить. Основное изменение — поддержка анимированных переходов между страницами (добавление к <code>body</code> классов <code>isEntering</code>, <code>isLeaving</code> с соответствующей задержкой) и запрет перехода на другие страницы в виде функции beforeLeave (аналог Prompt из <i>react-router</i>), в которой можно выводить предупреждения и блокировать переход при возврате false-значения в промисе, например</p><br/>
<pre><code class="javascript">somePage: {
  path: '/some-page',
  beforeLeave(store) {
    return store.modals.raiseConfirm('Вы действительно хотите покинуть страницу?');
  },
}
</code></pre><br/>
<p>В целом получилось крайне удобно, когда роуты сами ходят за данными и могут многократно редиректить на другие без рендеринга каких-либо компонентов. Например, на одной из страниц использовалась следующая цепочка:</p><br/>
<p> — при заходе на <code>/some/long/auth/path</code> ее beforeEnter редиректит на алиас <code>/auth</code><br/>
 — beforeEnter роута <code>/auth</code> проверяет авторизацию, и если человек авторизован — то редиректит на <code>/profile</code><br/>
 — beforeEnter роута <code>/profile</code> делает запрос за данными, и если видит, что у пользователя не заполнено имя, редиректит на <code>/profile/edit</code></p><br/>
<p>Эти редиректы проходят быстро и незаметно, при необходимости можно не сохранять их в истории браузера — то есть вместо <code>window.history.pushState</code> использовать <code>location.replace</code>. При этом зоны ответственности четко разграничены, и любое комбинирование редиректов линейно приведет к единственно верному адресу страницы. В этом подход «ходить за данными в роутере» на голову выше подхода «ходить за данными в componentDidMount компонента», если иметь в виду критически важные для отображения запросы, а не загрузку словаря для селекта при его первичном рендере.</p><br/>
<p>6. Классическая задача по отображению лоадера в кнопках при отправке запроса (например, при сабмите форм) элегантно решилась одним декоратором:</p><br/>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title">src/utils/withState.js</b>
                        <div class="spoiler_text"><pre><code class="javascript">export function withState(target, fnName, fnDescriptor) {
  const original = fnDescriptor.value;

  fnDescriptor.value = function fnWithState(...args) {
    if (this.executions[fnName]) {
      return Promise.resolve();
    }

    return Promise.resolve()
      .then(() => {
        this.executions[fnName] = true;
      })
      .then(() => original.apply(this, args))
      .then(data => {
        this.executions[fnName] = false;
        return data;
      })
      .catch(error => {
        this.executions[fnName] = false;
        throw error;
      });
  };

  return fnDescriptor;
}
</code></pre></div>
                    </div><br/>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title">src/stores/CurrentTPStore.js</b>
                        <div class="spoiler_text"><pre><code class="javascript">import _ from 'lodash';

import { makeObservable, withState } from 'utils';
import { apiRoutes, request } from 'api';

@makeObservable
export class CurrentTPStore {
  /**
   * @param rootStore {RootStore}
   */
  constructor(rootStore) {
    this.rootStore = rootStore;
    this.executions = {};
  }

  @withState
  fetchSymbol() {
    return request(apiRoutes.symbolInfo)
      .then(this.fetchSymbolSuccess)
      .catch(this.fetchSymbolError);
  }
  fetchSymbolSuccess(data) {
    return Promise.resolve();
  }
  fetchSymbolError(error) {
    console.error(error);
  }
}
</code></pre></div>
                    </div><br/>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title">src/components/TestComponent.js</b>
                        <div class="spoiler_text"><pre><code class="javascript">import React from 'react';

import { observer } from 'utils';
import { useStore } from 'hooks';

function TestComponent() {
  const store = useStore();
  const { currentTP: { executions } } = store;

  return &lt;div>{executions.fetchSymbol ? 'Загружается...' : 'Загружен'}&lt;/div>;
}

export const TestComponentConnected = observer(TestComponent);
</code></pre></div>
                    </div><br/>
<p>Такой подход освобождает от создания и обновления дополнительных параметров, по сути лишних.</p><br/>
<p>Второй репозиторий с обновленным кодом создавать не буду, так как изменений много, и итоговый код уже не будет соответствовать статье. Лучше потрачу это время на новую статью — интерес к приведенному стеку оказался высок, и есть множество сложных тем, в которых, возможно, мой опыт будет кому-то полезен.</p></div></div> <!----> <!----></div> <div class="tm-article-presenter__meta"><div class="tm-separated-list tm-article-presenter__meta-list"><span class="tm-separated-list__title">Теги:</span> <ul class="tm-separated-list__list"><li class="tm-separated-list__item"><a href="/ru/search/?target_type=posts&amp;order=relevance&amp;q=%5Bjavascript%5D" class="tm-tags-list__link">javascript</a></li><li class="tm-separated-list__item"><a href="/ru/search/?target_type=posts&amp;order=relevance&amp;q=%5Breact%5D" class="tm-tags-list__link">react</a></li><li class="tm-separated-list__item"><a href="/ru/search/?target_type=posts&amp;order=relevance&amp;q=%5Bmobx%5D" class="tm-tags-list__link">mobx</a></li><li class="tm-separated-list__item"><a href="/ru/search/?target_type=posts&amp;order=relevance&amp;q=%5Bcypress%5D" class="tm-tags-list__link">cypress</a></li><li class="tm-separated-list__item"><a href="/ru/search/?target_type=posts&amp;order=relevance&amp;q=%5Bwebpack%204%5D" class="tm-tags-list__link">webpack 4</a></li></ul></div> <div class="tm-separated-list tm-article-presenter__meta-list"><span class="tm-separated-list__title">Хабы:</span> <ul class="tm-separated-list__list"><li class="tm-separated-list__item"><a href="/ru/hub/webdev/" class="tm-hubs-list__link">
    Разработка веб-сайтов
  </a></li><li class="tm-separated-list__item"><a href="/ru/hub/javascript/" class="tm-hubs-list__link">
    JavaScript
  </a></li><li class="tm-separated-list__item"><a href="/ru/hub/reactjs/" class="tm-hubs-list__link">
    ReactJS
  </a></li></ul></div></div></article></div> <!----></div> <div class="tm-article-sticky-panel"><div class="tm-data-icons tm-article-sticky-panel__icons"><div class="tm-article-rating tm-data-icons__item"><div class="tm-votes-meter tm-article-rating__votes-switcher"><svg height="16" width="16" class="tm-svg-img tm-votes-meter__icon tm-votes-meter__icon_medium"><title>Всего голосов 32: ↑26 и ↓6</title> <use xlink:href="/img/megazord-v24.ce74655c.svg#counter-rating"></use></svg> <span title="Всего голосов 32: ↑26 и ↓6" class="tm-votes-meter__value tm-votes-meter__value_positive tm-votes-meter__value_medium">+20</span></div> <DIV class="v-portal" style="display:none;"></DIV></div> <!----> <span title="Количество просмотров" class="tm-icon-counter tm-data-icons__item"><svg height="16" width="16" class="tm-svg-img tm-icon-counter__icon"><title>Просмотры</title> <use xlink:href="/img/megazord-v24.ce74655c.svg#counter-views"></use></svg> <span class="tm-icon-counter__value">14K</span></span> <button title="Добавить в закладки" type="button" class="bookmarks-button tm-data-icons__item"><span title="Добавить в закладки" class="tm-svg-icon__wrapper bookmarks-button__icon"><svg height="16" width="16" class="tm-svg-img tm-svg-icon"><title>Добавить в закладки</title> <use xlink:href="/img/megazord-v24.ce74655c.svg#counter-favorite"></use></svg></span> <span title="Количество пользователей, добавивших публикацию в закладки" class="bookmarks-button__counter">
    155
  </span></button> <!----> <div title="Поделиться" class="tm-sharing tm-data-icons__item"><button type="button" class="tm-sharing__button"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" class="tm-sharing__icon"><path fill="currentColor" d="M10.33.275l9.047 7.572a.2.2 0 010 .306l-9.048 7.572a.2.2 0 01-.328-.153V11c-8 0-9.94 6-9.94 6S-1 5 10 5V.428a.2.2 0 01.328-.153z"></path></svg></button> <!----></div> <DIV class="v-portal" style="display:none;"></DIV></div> </div></div> <!----> <!----> <div class="tm-article-presenter__footer"><div class="tm-article-blocks"><!----> <section class="tm-block tm-block_spacing-bottom"><!----> <div class="tm-block__body tm-block__body_variant-balanced"><div class="tm-article-author"> <div class="tm-user-card tm-article-author__user-card tm-user-card_variant-article"><div class="tm-user-card__info-container"><div class="tm-user-card__header"><div class="tm-user-card__header-data"><a href="/ru/users/DmitryKazakov8/" class="tm-user-card__userpic tm-user-card__userpic_size-40"><div class="tm-entity-image"><img alt="" src="//habrastorage.org/getpro/habr/avatars/0f6/1ce/43b/0f61ce43b0b1a750e5876fe59fe582c7.jpg" class="tm-entity-image__pic"></div></a> <div class="tm-user-card__meta"><div title=" 34 голоса " class="tm-karma tm-user-card__karma"><div class="tm-karma__votes tm-karma__votes_positive">
    28
  </div> <div class="tm-karma__text">
    Карма
  </div></div> <div title="Рейтинг пользователя" class="tm-rating tm-user-card__rating"><div class="tm-rating__header"> <div class="tm-rating__counter">0</div></div> <div class="tm-rating__text">
    Рейтинг
  </div></div></div></div></div> <div class="tm-user-card__info tm-user-card__info_variant-article"><div class="tm-user-card__title tm-user-card__title_variant-article"><span class="tm-user-card__name tm-user-card__name_variant-article">Дмитрий Казаков</span> <a href="/ru/users/DmitryKazakov8/" class="tm-user-card__nickname tm-user-card__nickname_variant-article">
          @DmitryKazakov8
        </a> <!----></div> <p class="tm-user-card__short-info tm-user-card__short-info_variant-article">Front-end архитектор</p></div></div> <div class="tm-user-card__buttons tm-user-card__buttons_variant-article"><!----> <!----> <!----> <!----> <!----></div></div> <div class="tm-article-author__user-contacts"><a href="https://github.com/dkazakov8/" rel="noopener" target="_blank" class="tm-article-author__contact">
      Github
    </a></div></div> <DIV class="v-portal" style="display:none;"></DIV></div> <!----></section> <div class="tm-article-blocks__comments"><div class="tm-article-page-comments"><div class="tm-article-comments-counter-link tm-article-comments-counter-button"><a href="/ru/post/450360/comments/" class="tm-article-comments-counter-link__link tm-article-comments-counter-link__link_button-style"><svg height="16" width="16" class="tm-svg-img tm-article-comments-counter-link__icon tm-article-comments-counter-link__icon_contrasted"><title>Комментарии</title> <use xlink:href="/img/megazord-v24.ce74655c.svg#counter-comments"></use></svg> <span class="tm-article-comments-counter-link__value tm-article-comments-counter-link__value_contrasted">
       Комментарии 26 
    </span></a> <!----></div></div></div> <div class="tm-ad-banner__container tm-page-article__banner"><!----> <div id="articleBottomBanner" class="tm-ad-banner"></div></div> <!----> <!----> <!----> <!----> </div></div></div></div></div> <div class="tm-page__sidebar"><div class="tm-layout-sidebar"><div class="tm-layout-sidebar__ads tm-layout-sidebar__ads_initial"><div class="tm-ad-banner__container tm-layout-sidebar__banner"><!----> <div id="sidebarBanner" class="tm-ad-banner"></div></div></div> <div class="tm-sexy-sidebar tm-sexy-sidebar_initial" style="margin-top:0px;"><!----> <!----></div></div></div></div></div></div></main> <!----></div> <div class="tm-footer-menu"><div class="tm-page-width"><div class="tm-footer-menu__container"><div class="tm-footer-menu__block"><h3 class="tm-footer-menu__block-title">
          Ваш аккаунт
        </h3> <div class="tm-footer-menu__block-content"><ul class="tm-footer-menu__list"><li class="tm-footer-menu__list-item"><a href="/kek/v1/auth/habrahabr/?back=/ru/post/450360/&amp;hl=ru" rel="nofollow" target="_self">
                Войти
              </a></li><li class="tm-footer-menu__list-item"><a href="/kek/v1/auth/habrahabr-register/?back=/ru/post/450360/&amp;hl=ru" rel="nofollow" target="_self">
                Регистрация
              </a></li></ul></div></div><div class="tm-footer-menu__block"><h3 class="tm-footer-menu__block-title">
          Разделы
        </h3> <div class="tm-footer-menu__block-content"><ul class="tm-footer-menu__list"><li class="tm-footer-menu__list-item"><a href="/ru/" class="footer-menu__item-link router-link-active">
                Публикации
              </a></li><li class="tm-footer-menu__list-item"><a href="/ru/news/" class="footer-menu__item-link">
                Новости
              </a></li><li class="tm-footer-menu__list-item"><a href="/ru/hubs/" class="footer-menu__item-link">
                Хабы
              </a></li><li class="tm-footer-menu__list-item"><a href="/ru/companies/" class="footer-menu__item-link">
                Компании
              </a></li><li class="tm-footer-menu__list-item"><a href="/ru/users/" class="footer-menu__item-link">
                Авторы
              </a></li><li class="tm-footer-menu__list-item"><a href="/ru/sandbox/" class="footer-menu__item-link">
                Песочница
              </a></li></ul></div></div><div class="tm-footer-menu__block"><h3 class="tm-footer-menu__block-title">
          Информация
        </h3> <div class="tm-footer-menu__block-content"><ul class="tm-footer-menu__list"><li class="tm-footer-menu__list-item"><a href="/ru/docs/help/" class="footer-menu__item-link">
                Устройство сайта
              </a></li><li class="tm-footer-menu__list-item"><a href="/ru/docs/authors/codex/" class="footer-menu__item-link">
                Для авторов
              </a></li><li class="tm-footer-menu__list-item"><a href="/ru/docs/companies/corpblogs/" class="footer-menu__item-link">
                Для компаний
              </a></li><li class="tm-footer-menu__list-item"><a href="/ru/docs/docs/transparency/" class="footer-menu__item-link">
                Документы
              </a></li><li class="tm-footer-menu__list-item"><a href="https://account.habr.com/info/agreement" target="_blank">
                Соглашение
              </a></li><li class="tm-footer-menu__list-item"><a href="https://account.habr.com/info/confidential/" target="_blank">
                Конфиденциальность
              </a></li></ul></div></div><div class="tm-footer-menu__block"><h3 class="tm-footer-menu__block-title">
          Услуги
        </h3> <div class="tm-footer-menu__block-content"><ul class="tm-footer-menu__list"><li class="tm-footer-menu__list-item"><a href="https://docs.google.com/presentation/d/e/2PACX-1vQLwRfQmXibiUlWaRg-BAc38s7oM3lJiaPju7qmdJsp8ysIvZ_G-Npem0njJLMozE2bPHMpDqiI5hhy/pub?start=false&amp;loop=false&amp;delayms=60000&amp;slide=id.g91a03369cd_4_297" target="_blank">
                Реклама
              </a></li><li class="tm-footer-menu__list-item"><a href="https://habrastorage.org/storage/stuff/habr/service_price.pdf" target="_blank">
                Тарифы
              </a></li><li class="tm-footer-menu__list-item"><a href="https://docs.google.com/presentation/d/e/2PACX-1vQJJds8-Di7BQSP_guHxICN7woVYoN5NP_22ra-BIo4bqnTT9FR6fB-Ku2P0AoRpX0Ds-LRkDeAoD8F/pub?start=false&amp;loop=false&amp;delayms=60000" target="_blank">
                Контент
              </a></li><li class="tm-footer-menu__list-item"><a href="https://tmtm.timepad.ru/" target="_blank">
                Семинары
              </a></li><li class="tm-footer-menu__list-item"><a href="/ru/megaprojects/" class="footer-menu__item-link">
                Мегапроекты
              </a></li></ul></div></div></div></div></div> <div class="tm-footer"><div class="tm-page-width"><div class="tm-footer__container"><!----> <div class="tm-footer__social"><a href="https://www.facebook.com/habrahabr.ru" rel="nofollow noopener noreferrer" target="_blank" class="tm-svg-icon__wrapper tm-social-icons__icon"><svg height="16" width="16" class="tm-svg-img tm-svg-icon"><title>Facebook</title> <use xlink:href="/img/social-icons-sprite.svg#social-logo-facebook"></use></svg></a><a href="https://twitter.com/habr_com" rel="nofollow noopener noreferrer" target="_blank" class="tm-svg-icon__wrapper tm-social-icons__icon"><svg height="16" width="16" class="tm-svg-img tm-svg-icon"><title>Twitter</title> <use xlink:href="/img/social-icons-sprite.svg#social-logo-twitter"></use></svg></a><a href="https://vk.com/habr" rel="nofollow noopener noreferrer" target="_blank" class="tm-svg-icon__wrapper tm-social-icons__icon"><svg height="16" width="16" class="tm-svg-img tm-svg-icon"><title>VK</title> <use xlink:href="/img/social-icons-sprite.svg#social-logo-vkontakte"></use></svg></a><a href="https://telegram.me/habr_com" rel="nofollow noopener noreferrer" target="_blank" class="tm-svg-icon__wrapper tm-social-icons__icon"><svg height="16" width="16" class="tm-svg-img tm-svg-icon"><title>Telegram</title> <use xlink:href="/img/social-icons-sprite.svg#social-logo-telegram"></use></svg></a><a href="https://www.youtube.com/channel/UCd_sTwKqVrweTt4oAKY5y4w" rel="nofollow noopener noreferrer" target="_blank" class="tm-svg-icon__wrapper tm-social-icons__icon"><svg height="16" width="16" class="tm-svg-img tm-svg-icon"><title>Youtube</title> <use xlink:href="/img/social-icons-sprite.svg#social-logo-youtube"></use></svg></a><a href="https://zen.yandex.ru/habr" rel="nofollow noopener noreferrer" target="_blank" class="tm-svg-icon__wrapper tm-social-icons__icon"><svg height="16" width="16" class="tm-svg-img tm-svg-icon"><title>Яндекс Дзен</title> <use xlink:href="/img/social-icons-sprite.svg#social-logo-zen"></use></svg></a></div> <DIV class="v-portal" style="display:none;"></DIV> <button class="tm-footer__link"><!---->
        Настройка языка
      </button> <a href="/ru/about" class="tm-footer__link">
        О сайте
      </a> <a href="/ru/feedback/" class="tm-footer__link">
        Техническая поддержка
      </a> <!----> <a href="/berserk-mode-nope" class="tm-footer__link">
        Вернуться на старую версию
      </a> <div class="tm-footer-copyright"><span class="tm-copyright"><span class="tm-copyright__years">© 2006–2021 </span> <span class="tm-copyright__name">«<a href="https://company.habr.com/" rel="noopener" target="_blank" class="tm-copyright__link">Habr</a>»</span></span></div></div></div></div> <!----> <!----></div> <div class="vue-portal-target"></div></div>
<script>window.__INITIAL_STATE__={"adblock":{"hasAcceptableAdsFilter":false,"hasAdblock":false},"articlesList":{"articlesList":{"450360":{"id":"450360","timePublished":"2019-05-02T19:27:53+00:00","isCorporative":false,"lang":"ru","titleHtml":"Архитектура SPA-приложения биржи в 2019 году","leadData":{"textHtml":"\u003Cp\u003EПриветствую, хабровчане!\u003C\u002Fp\u003E\u003Cbr\u003E\r\n\u003Cp\u003EЧитаю данный ресурс со времени основания, но время на написание статьи появилось только сейчас, а значит пора поделиться своим опытом с сообществом. Начинающим разработчикам, рассчитываю, статья поможет улучшить качество проектирования, а опытным выступит в качестве чек-листа, чтобы не забыть важные элементы на этапе архитектуры. Для нетерпеливых — итоговый \u003Ca href=\"https:\u002F\u002Fgithub.com\u002Fdkazakov8\u002Fhabr_exchange\" rel=\"nofollow\"\u003Eрепозиторий\u003C\u002Fa\u003E и \u003Ca href=\"https:\u002F\u002Fdkazakov8.github.io\u002Fexchange_habr\u002Fdist\u002F\" rel=\"nofollow\"\u003Eдемо\u003C\u002Fa\u003E.\u003C\u002Fp\u003E\u003Cbr\u003E","imageUrl":null,"buttonTextHtml":"Читать дальше &rarr;","image":null},"editorVersion":"1.0","postType":"article","postLabels":[{"type":"sandbox","data":null},{"type":"tutorial","data":null}],"author":{"scoreStats":{"score":28,"votesCount":34},"rating":0,"relatedData":null,"contacts":[{"title":"Github","url":"https:\u002F\u002Fgithub.com\u002Fdkazakov8\u002F","value":"dkazakov8"}],"authorContacts":[{"title":"Github","url":"https:\u002F\u002Fgithub.com\u002Fdkazakov8\u002F","value":"dkazakov8"}],"paymentDetails":{"paymentYandexMoney":null,"paymentPayPalMe":null,"paymentWebmoney":null},"id":"2021967","alias":"DmitryKazakov8","fullname":"Дмитрий Казаков","avatarUrl":"\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Favatars\u002F0f6\u002F1ce\u002F43b\u002F0f61ce43b0b1a750e5876fe59fe582c7.jpg","speciality":"Front-end архитектор"},"statistics":{"commentsCount":26,"favoritesCount":155,"readingCount":14353,"score":20,"votesCount":32},"hubs":[{"relatedData":null,"id":"91","alias":"webdev","type":"collective","title":"Разработка веб-сайтов","titleHtml":"Разработка веб-сайтов","isProfiled":true},{"relatedData":null,"id":"357","alias":"javascript","type":"collective","title":"JavaScript","titleHtml":"JavaScript","isProfiled":true},{"relatedData":null,"id":"19327","alias":"reactjs","type":"collective","title":"ReactJS","titleHtml":"ReactJS","isProfiled":true}],"flows":[{"id":"1","alias":"develop","title":"Разработка"}],"relatedData":null,"textHtml":"\u003Cdiv xmlns=\"http:\u002F\u002Fwww.w3.org\u002F1999\u002Fxhtml\"\u003E\u003Cp\u003EПриветствую, хабровчане!\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EЧитаю данный ресурс со времени основания, но время на написание статьи появилось только сейчас, а значит пора поделиться своим опытом с сообществом. Начинающим разработчикам, рассчитываю, статья поможет улучшить качество проектирования, а опытным выступит в качестве чек-листа, чтобы не забыть важные элементы на этапе архитектуры. Для нетерпеливых — итоговый \u003Ca href=\"https:\u002F\u002Fgithub.com\u002Fdkazakov8\u002Fhabr_exchange\" rel=\"nofollow\"\u003Eрепозиторий\u003C\u002Fa\u003E и \u003Ca href=\"https:\u002F\u002Fdkazakov8.github.io\u002Fexchange_habr\u002Fdist\u002F\" rel=\"nofollow\"\u003Eдемо\u003C\u002Fa\u003E.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Ca name=\"habracut\"\u003E\u003C\u002Fa\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EДопустим, вы устроились в «компанию мечты» — одну из бирж со свободным выбором технологий и ресурсами, чтобы сделать все «как надо». На данный момент все, что есть у компании — это\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Ch3\u003EЗадание от бизнеса\u003C\u002Fh3\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EРазработать SPA-приложение для торгового интерфейса, в котором можно:\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cul\u003E\r\n\u003Cli\u003Eувидеть список торговых пар, сгруппированных по торгуемой валюте;\u003C\u002Fli\u003E\r\n\u003Cli\u003Eпри нажатии на торговую пару увидеть информацию по текущей цене, изменении за 24 часа, «стакан заявок»;\u003C\u002Fli\u003E\r\n\u003Cli\u003Eизменить язык приложения на английский \u002F русский;\u003C\u002Fli\u003E\r\n\u003Cli\u003Eизменить тему на темную \u002F светлую.\u003C\u002Fli\u003E\r\n\u003C\u002Ful\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EЗадание достаточно краткое, что позволит сосредоточиться именно на архитектуре, а не написании больших объемов бизнес-функционала. Итогом первоначальных усилий должен стать логичный и продуманных код, позволяющий приступить непосредственно к реализации бизнес-логики.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EТак как в ТЗ от заказчика нет технических требований, пусть будут комфортные для разработки:\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cul\u003E\r\n\u003Cli\u003E\u003Cb\u003Eкроссбраузерность\u003C\u002Fb\u003E: 2 последние версии популярных браузеров (без IE);\u003C\u002Fli\u003E\r\n\u003Cli\u003E\u003Cb\u003Eширина экрана\u003C\u002Fb\u003E: \u003E= 1240px;\u003C\u002Fli\u003E\r\n\u003Cli\u003E\u003Cb\u003Eдизайн\u003C\u002Fb\u003E: по аналогии с другими биржами, т.к. дизайнера еще не наняли.\u003C\u002Fli\u003E\r\n\u003C\u002Ful\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EТеперь время определить используемые инструменты и библиотеки. Я буду руководствоваться принципами разработки «под ключ» и \u003Ca href=\"https:\u002F\u002Fru.wikipedia.org\u002Fwiki\u002FKISS_(%D0%BF%D1%80%D0%B8%D0%BD%D1%86%D0%B8%D0%BF)\" rel=\"nofollow\"\u003EKISS\u003C\u002Fa\u003E, то есть брать только те opensource библиотеки, для самостоятельной реализации которых потребовалось бы неадекватно много времени, включая время на обучение будущих коллег-разработчиков.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cul\u003E\r\n\u003Cli\u003E\u003Cb\u003Eсистема управления версиями\u003C\u002Fb\u003E: Git + Github;\u003C\u002Fli\u003E\r\n\u003Cli\u003E\u003Cb\u003Ebackend\u003C\u002Fb\u003E: \u003Ca href=\"https:\u002F\u002Fwww.coingecko.com\u002Fen\u002Fapi\" rel=\"nofollow\"\u003EAPI\u003C\u002Fa\u003E CoinGecko;\u003C\u002Fli\u003E\r\n\u003Cli\u003E\u003Cb\u003Eсборка \u002F траниспиляция\u003C\u002Fb\u003E: Webpack + Babel;\u003C\u002Fli\u003E\r\n\u003Cli\u003E\u003Cb\u003Eустановщик пакетов\u003C\u002Fb\u003E: Yarn (npm 6 некорректно обновлял зависимости);\u003C\u002Fli\u003E\r\n\u003Cli\u003E\u003Cb\u003Eконтроль качества кода\u003C\u002Fb\u003E: ESLint + Prettier + Stylelint;\u003C\u002Fli\u003E\r\n\u003Cli\u003E\u003Cb\u003Eview\u003C\u002Fb\u003E: React (посмотрим, насколько удобны Hooks);\u003C\u002Fli\u003E\r\n\u003Cli\u003E\u003Cb\u003Estore\u003C\u002Fb\u003E: MobX;\u003C\u002Fli\u003E\r\n\u003Cli\u003E\u003Cb\u003Eавтотесты\u003C\u002Fb\u003E: \u003Ca href=\"https:\u002F\u002Fwww.cypress.io\u002F\" rel=\"nofollow\"\u003ECypress.io\u003C\u002Fa\u003E (комплексное решение на javascript вместо модульной сборки вроде Mocha\u002FKarma+Chai+Sinon+Selenium+Webdriver\u002FProtractor);\u003C\u002Fli\u003E\r\n\u003Cli\u003E\u003Cb\u003Eстили\u003C\u002Fb\u003E: SCSS через PostCSS (гибкость настройки, дружит с Stylelint);\u003C\u002Fli\u003E\r\n\u003Cli\u003E\u003Cb\u003Eграфики\u003C\u002Fb\u003E: \u003Ca href=\"https:\u002F\u002Fwww.highcharts.com\u002Fblog\u002Fproducts\u002Fhighstock\u002F\" rel=\"nofollow\"\u003EHighStock\u003C\u002Fa\u003E (настраивать намного проще, чем \u003Ca href=\"https:\u002F\u002Fru.tradingview.com\u002FHTML5-stock-forex-bitcoin-charting-library\u002F\" rel=\"nofollow\"\u003ETradingView\u003C\u002Fa\u003E, но для реального приложения взял бы последний);\u003C\u002Fli\u003E\r\n\u003Cli\u003E\u003Cb\u003Eрегистрация ошибок\u003C\u002Fb\u003E: Sentry;\u003C\u002Fli\u003E\r\n\u003Cli\u003E\u003Cb\u003Eутилиты\u003C\u002Fb\u003E: Lodash (экономия времени);\u003C\u002Fli\u003E\r\n\u003Cli\u003E\u003Cb\u003Eроутинг\u003C\u002Fb\u003E: под ключ;\u003C\u002Fli\u003E\r\n\u003Cli\u003E\u003Cb\u003Eлокализация\u003C\u002Fb\u003E: под ключ;\u003C\u002Fli\u003E\r\n\u003Cli\u003E\u003Cb\u003Eработа с запросами\u003C\u002Fb\u003E: под ключ;\u003C\u002Fli\u003E\r\n\u003Cli\u003E\u003Cb\u003Eметрики быстродействия\u003C\u002Fb\u003E: под ключ;\u003C\u002Fli\u003E\r\n\u003Cli\u003E\u003Cb\u003Eтипизация\u003C\u002Fb\u003E: не в мою смену.\u003C\u002Fli\u003E\r\n\u003C\u002Ful\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EТаким образом, из библиотек в итоговом файле приложения окажутся только React, MobX, HighStock, Lodash и Sentry. Считаю это оправданным, так как они имеют отличную документацию, быстродействие и знакомы многим разработчикам.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Ch3\u003EКонтроль качества кода\u003C\u002Fh3\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EЯ предпочитаю разбивать зависимости в \u003Ci\u003Epackage.json\u003C\u002Fi\u003E на смысловые части, поэтому первым шагом после инициации git-репозитория сгруппирую все, что касается стиля кода в папке \u003Ci\u003E.\u002Feslint-custom\u003C\u002Fi\u003E, указав в \u003Ci\u003Epackage.json\u003C\u002Fi\u003E:\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"json\"\u003E{\n  \"scripts\": {\n    \"upd\": \"yarn install --no-lockfile\"\n  },\n  \"dependencies\": {\n    \"eslint-custom\": \"file:.\u002Feslint-custom\"\n  }\n}\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EОбычный \u003Ccode\u003Eyarn install\u003C\u002Fcode\u003E не проверит, изменились ли зависимости внутри \u003Ci\u003Eeslint-custom\u003C\u002Fi\u003E, поэтому буду использовать \u003Ccode\u003Eyarn upd\u003C\u002Fcode\u003E. В целом такая практика выглядит более универсальной, так как девопсам не придется менять рецепт деплоя, если разработчикам понадобится изменить метод установки пакетов.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EФайлом \u003Ci\u003Eyarn.lock\u003C\u002Fi\u003E пользоваться нет смысла, так как все зависимости будут без «крышечек» semver (в виде \u003Ccode\u003E\"react\": \"16.8.6\"\u003C\u002Fcode\u003E). Опыт показал, что лучше вручную обновлять версии и тщательно их тестировать в рамках отдельных задач, чем полагаться на lock-файл, предоставляя авторам пакетов возможность сломать приложение минорным обновлением в любой момент (счастливчики, кто с этим не сталкивался).\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EВ пакете \u003Ci\u003Eeslint-custom\u003C\u002Fi\u003E зависимости будут следующие:\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cdiv class=\"spoiler\" role=\"button\" tabindex=\"0\"\u003E\n                        \u003Cb class=\"spoiler_title\"\u003Eeslint-custom\u002Fpackage.json\u003C\u002Fb\u003E\n                        \u003Cdiv class=\"spoiler_text\"\u003E\u003Cpre\u003E\u003Ccode class=\"json\"\u003E{\n  \"name\": \"eslint-custom\",\n  \"version\": \"1.0.0\",\n  \"description\": \"Custom linter rules for this project\",\n  \"license\": \"MIT\",\n  \"dependencies\": {\n    \"babel-eslint\": \"10.0.1\",\n    \"eslint\": \"5.16.0\",\n    \"eslint-config-prettier\": \"4.1.0\",\n    \"eslint-plugin-import\": \"2.17.2\",\n    \"eslint-plugin-prettier\": \"3.0.1\",\n    \"eslint-plugin-react\": \"7.12.4\",\n    \"eslint-plugin-react-hooks\": \"1.6.0\",\n    \"prettier\": \"1.17.0\",\n    \"prettier-eslint\": \"8.8.2\",\n    \"stylelint\": \"10.0.1\",\n    \"stylelint-config-prettier\": \"5.1.0\",\n    \"stylelint-prettier\": \"1.0.6\",\n    \"stylelint-scss\": \"3.6.0\"\n  }\n}\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003C\u002Fdiv\u003E\n                    \u003C\u002Fdiv\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EЧтобы связать три инструмента, понадобилось 5 вспомогательных пакетов (\u003Ci\u003Eeslint-plugin-prettier, eslint-config-prettier, stylelint-prettier, stylelint-config-prettier, prettier-eslint\u003C\u002Fi\u003E) — такую цену приходится платить сегодня. Для максимального удобства не хватает только автоматической \u003Ca href=\"https:\u002F\u002Fgithub.com\u002FAlexJuarez\u002Feslint-plugin-import-order-autofix\" rel=\"nofollow\"\u003Eсортировки imports\u003C\u002Fa\u003E, но, к сожалению, этот плагин при переформатировании файла теряет строки.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EКонфигурационные файлы для всех инструментов будут в формате \u003Ci\u003E*.js\u003C\u002Fi\u003E (\u003Ci\u003Eeslint.config.js\u003C\u002Fi\u003E, \u003Ci\u003Estylelint.config.js\u003C\u002Fi\u003E), чтобы на них самих работало форматирование кода. Правила пусть будут в формате \u003Ci\u003E*.yaml\u003C\u002Fi\u003E, разбитые по смысловым модулям. Полные версии конфигураций и правил — в \u003Ca href=\"https:\u002F\u002Fgithub.com\u002Fdkazakov8\u002Fhabr_exchange\u002Ftree\u002Fmaster\u002Feslint-custom\" rel=\"nofollow\"\u003Eрепозитории\u003C\u002Fa\u003E.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EОсталось дописать команды в основной \u003Ci\u003Epackage.json\u003C\u002Fi\u003E...\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"json\"\u003E{\n  \"scripts\": {\n    \"upd\": \"yarn install --no-lockfile\",\n    \"format:js\": \"eslint --ignore-path .gitignore --ext .js -c .\u002Feslint-custom\u002Feslint.config.js --fix\",\n    \"format:style\": \"stylelint --ignore-path .gitignore --config .\u002Feslint-custom\u002Fstylelint.config.js  --fix\"\n  }\n}\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003E… и настроить свой IDE на применение форматирования при сохранении текущего файла. Для гарантии при создании коммита необходимо использовать git-хук, который будет проверять и форматировать все файлы проекта. Почему не только те, которые присутствуют в коммите? Для принципа коллективной ответственности за всю кодовую базу, чтобы ни у кого не было соблазна обойти валидацию. Для этого же при создании коммита все предупреждения линтера будут считаться ошибками с помощью \u003Ccode\u003E--max-warnings=0\u003C\u002Fcode\u003E.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"json\"\u003E{\n  \"husky\": {\n    \"hooks\": {\n      \"pre-commit\": \"npm run format:js -- --max-warnings=0 .\u002F &amp;&amp; npm run format:style .\u002F**\u002F*.scss\"\n    }\n  }\n}\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003Ch3\u003EСборка \u002F траниспиляция\u003C\u002Fh3\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EСнова воспользуюсь модульным подходом и вынесу все настройки Webpack и Babel в папку .\u002Fwebpack-custom. Конфиг будет опираться на следующую структуру файлов:\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"pgsql\"\u003E.\n|-- webpack-custom\n|   |-- config\n|   |-- loaders\n|   |-- plugins\n|   |-- rules\n|   |-- utils\n|   `-- package.json\n|   `-- webpack.config.js\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EГрамотно настроенный сборщик предоставит:\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cul\u003E\r\n\u003Cli\u003Eвозможность писать код, используя синтаксис и возможности последней EcmaScript спецификации, включая удобные proposals (здесь точно пригодятся декораторы классов и их свойств для MobX);\u003C\u002Fli\u003E\r\n\u003Cli\u003Eлокальный сервер с Hot Reloading;\u003C\u002Fli\u003E\r\n\u003Cli\u003Eметрики производительности сборки;\u003C\u002Fli\u003E\r\n\u003Cli\u003Eпроверку на цикличные зависимости;\u003C\u002Fli\u003E\r\n\u003Cli\u003Eанализ структуры и размера итогового файла;\u003C\u002Fli\u003E\r\n\u003Cli\u003Eоптимизацию и минификацию для production сборки;\u003C\u002Fli\u003E\r\n\u003Cli\u003Eинтерпретацию модульных \u003Ci\u003E*.scss\u003C\u002Fi\u003E файлов и возможность вынесения готовых \u003Ci\u003E*.css\u003C\u002Fi\u003E файлов из бандла;\u003C\u002Fli\u003E\r\n\u003Cli\u003Einline-вставку \u003Ci\u003E*.svg\u003C\u002Fi\u003E файлов;\u003C\u002Fli\u003E\r\n\u003Cli\u003Eполифиллы \u002F стилевые префиксы для целевых браузеров;\u003C\u002Fli\u003E\r\n\u003Cli\u003Eрешение проблемы с кэшированием файлов на production.\u003C\u002Fli\u003E\r\n\u003C\u002Ful\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EА также будет удобно конфигурироваться. Эту задачу решу с помощью двух \u003Ci\u003E*.env\u003C\u002Fi\u003E файлов-примеров:\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cdiv class=\"spoiler\" role=\"button\" tabindex=\"0\"\u003E\n                        \u003Cb class=\"spoiler_title\"\u003E.frontend.env.example\u003C\u002Fb\u003E\n                        \u003Cdiv class=\"spoiler_text\"\u003E\u003Cpre\u003E\u003Ccode class=\"plaintext\"\u003EAGGREGATION_TIMEOUT=0\nBUNDLE_ANALYZER=false\nBUNDLE_ANALYZER_PORT=8889\nCIRCULAR_CHECK=true\nCSS_EXTRACT=false\nDEV_SERVER_PORT=8080\nHOT_RELOAD=true\nNODE_ENV=development\nSENTRY_URL=false\nSPEED_ANALYZER=false\nPUBLIC_URL=false\n\n# https:\u002F\u002Fwebpack.js.org\u002Fconfiguration\u002Fdevtool\nDEV_TOOL=cheap-module-source-map\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003C\u002Fdiv\u003E\n                    \u003C\u002Fdiv\u003E\u003Cbr\u002F\u003E\r\n\u003Cdiv class=\"spoiler\" role=\"button\" tabindex=\"0\"\u003E\n                        \u003Cb class=\"spoiler_title\"\u003E.frontend.env.prod.example\u003C\u002Fb\u003E\n                        \u003Cdiv class=\"spoiler_text\"\u003E\u003Cpre\u003E\u003Ccode class=\"plaintext\"\u003EAGGREGATION_TIMEOUT=0\nBUNDLE_ANALYZER=false\nBUNDLE_ANALYZER_PORT=8889\nCIRCULAR_CHECK=false\nCSS_EXTRACT=true\nDEV_SERVER_PORT=8080\nHOT_RELOAD=false\nNODE_ENV=production\nSENTRY_URL=false\nSPEED_ANALYZER=false\nPUBLIC_URL=\u002Fhabr_exchange\u002Fdist\n\n# https:\u002F\u002Fwebpack.js.org\u002Fconfiguration\u002Fdevtool\nDEV_TOOL=false\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003C\u002Fdiv\u003E\n                    \u003C\u002Fdiv\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EТаким образом, для запуска сборки нужно создать файл с названием \u003Ci\u003E.frontend.env\u003C\u002Fi\u003E и обязательным присутствием всех параметров. Данный подход решит сразу несколько проблем: не нужно делать раздельные конфигурационные файлы для Webpack и поддерживать их согласованность; локально можно настроить насколько это нужно определенному разработчику; девопсы при деплое будут лишь копировать файл для production-сборки (\u003Ccode\u003Ecp .frontend.env.prod.example .frontend.env\u003C\u002Fcode\u003E), обогащая значениями из хранилища, соответственно frontend-разработчики имеют возможность управлять рецептом через переменные без задействования админов. Дополнительно можно будет сделать пример конфигурации для стендов (например, с source maps).\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EДля отделения стилей в файлы при включенном \u003Ci\u003ECSS_EXTRACT\u003C\u002Fi\u003E буду использовать \u003Ca href=\"https:\u002F\u002Fgithub.com\u002Fwebpack-contrib\u002Fmini-css-extract-plugin\" rel=\"nofollow\"\u003Emini-css-extract-plugin\u003C\u002Fa\u003E — он позволяет использовать Hot Reloading. То есть, если при локальной разработке включить \u003Ci\u003EHOT_RELOAD\u003C\u002Fi\u003E и \u003Ci\u003ECSS_EXTRACT\u003C\u002Fi\u003E, то при\u003Cbr\u002F\u003E\r\nизменении файлов стилей будут перезагружаться только они — но, к сожалению, все, а не только измененный файл. С выключенным же \u003Ci\u003ECSS_EXTRACT\u003C\u002Fi\u003E обновляться будет только измененный стилевой модуль.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EHMR для работы с React Hooks включается достаточно стандартно:\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cul\u003E\r\n\u003Cli\u003E\u003Ccode\u003Ewebpack.HotModuleReplacementPlugin\u003C\u002Fcode\u003E в plugins;\u003C\u002Fli\u003E\r\n\u003Cli\u003E\u003Ccode\u003Ehot: true\u003C\u002Fcode\u003E в параметрах \u003Ci\u003Ewebpack-dev-server\u003C\u002Fi\u003E;\u003C\u002Fli\u003E\r\n\u003Cli\u003E\u003Ccode\u003Ereact-hot-loader\u002Fbabel\u003C\u002Fcode\u003E в \u003Ci\u003Ebabel-loader\u003C\u002Fi\u003E plugins;\u003C\u002Fli\u003E\r\n\u003Cli\u003E\u003Ccode\u003Eoptions.hmr: true\u003C\u002Fcode\u003E в \u003Ci\u003Emini-css-extract-plugin\u003C\u002Fi\u003E;\u003C\u002Fli\u003E\r\n\u003Cli\u003E\u003Ccode\u003Eexport default hot(App)\u003C\u002Fcode\u003E в главном компоненте приложения;\u003C\u002Fli\u003E\r\n\u003Cli\u003E\u003Ci\u003E@hot-loader\u002Freact-dom\u003C\u002Fi\u003E вместо обычного \u003Ci\u003Ereact-dom\u003C\u002Fi\u003E (удобно через \u003Ccode\u003Eresolve.alias: { 'react-dom': '@hot-loader\u002Freact-dom' }\u003C\u002Fcode\u003E);\u003C\u002Fli\u003E\r\n\u003C\u002Ful\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EТекущая версия \u003Ci\u003Ereact-hot-loader\u003C\u002Fi\u003E не поддерживает мемоизацию компонентов с помощью \u003Ccode\u003EReact.memo\u003C\u002Fcode\u003E, так что при написании декораторов для MobX надо будет учесть это для удобства локальной разработки. Еще одно вызванное этим неудобство — при включенной настройке \u003Ci\u003EHighlight Updates\u003C\u002Fi\u003E в React Developer Tools при любом взаимодействии с приложением обновляются все компоненты. Поэтому при локальной работе над оптимизацией производительности следует отключать настройку \u003Ci\u003EHOT_RELOAD\u003C\u002Fi\u003E.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EОптимизация сборки в Webpack 4 выполняется автоматически при указании \u003Ccode\u003E\u003Ca href=\"https:\u002F\u002Fwebpack.js.org\u002Fconfiguration\u002Fmode\" rel=\"nofollow\"\u003Emode\u003C\u002Fa\u003E: 'development' | 'production'\u003C\u002Fcode\u003E. В данном случае положусь на стандартную оптимизацию (+ включение параметра \u003Ccode\u003Ekeep_fnames: true\u003C\u002Fcode\u003E в \u003Ci\u003Eterser-webpack-plugin\u003C\u002Fi\u003E для сохранения названия компонентов), так как она уже качественно настроена.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EОтдельного внимания заслуживает разбиение на чанки и контроль клиентского кэширования. Для корректной работы нужно:\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cul\u003E\r\n\u003Cli\u003Eв output.filename для js и css файлов указать \u003Ccode\u003EisProduction ? '[name].[contenthash].js' : '[name].js'\u003C\u002Fcode\u003E (с расширением .css соответственно), чтобы название файла опиралось на его содержание;\u003C\u002Fli\u003E\r\n\u003Cli\u003Eв optimization изменить параметры на \u003Ccode\u003EchunkIds: 'named', moduleIds: 'hashed'\u003C\u002Fcode\u003E, чтобы внутренний счетчик модулей в webpack не менялся;\u003C\u002Fli\u003E\r\n\u003Cli\u003Eвынести runtime в отдельный чанк;\u003C\u002Fli\u003E\r\n\u003Cli\u003Eвынести группы кэширования в splitChunks (для данного приложения достаточно четырех точек — lodash, sentry, highcharts и vendor для остальных зависимостей из \u003Ci\u003Enode_modules\u003C\u002Fi\u003E). Так как первые три будут обновляться редко, то они останутся в кэше браузера клиента максимально долго.\u003C\u002Fli\u003E\r\n\u003C\u002Ful\u003E\u003Cbr\u002F\u003E\r\n\u003Cdiv class=\"spoiler\" role=\"button\" tabindex=\"0\"\u003E\n                        \u003Cb class=\"spoiler_title\"\u003Ewebpack-custom\u002Fconfig\u002FconfigOptimization.js\u003C\u002Fb\u003E\n                        \u003Cdiv class=\"spoiler_text\"\u003E\u003Cpre\u003E\u003Ccode class=\"javascript\"\u003E\u002F**\n * @docs: https:\u002F\u002Fwebpack.js.org\u002Fconfiguration\u002Foptimization\n *\n *\u002F\n\nconst TerserPlugin = require('terser-webpack-plugin');\n\nmodule.exports = {\n  runtimeChunk: {\n    name: 'runtime',\n  },\n  chunkIds: 'named',\n  moduleIds: 'hashed',\n  mergeDuplicateChunks: true,\n  splitChunks: {\n    cacheGroups: {\n      lodash: {\n        test: module =\u003E module.context.indexOf('node_modules\\\\lodash') !== -1,\n        name: 'lodash',\n        chunks: 'all',\n        enforce: true,\n      },\n      sentry: {\n        test: module =\u003E module.context.indexOf('node_modules\\\\@sentry') !== -1,\n        name: 'sentry',\n        chunks: 'all',\n        enforce: true,\n      },\n      highcharts: {\n        test: module =\u003E\n          module.context.indexOf('node_modules\\\\highcharts') !== -1,\n        name: 'highcharts',\n        chunks: 'all',\n        enforce: true,\n      },\n      vendor: {\n        test: module =\u003E module.context.indexOf('node_modules') !== -1,\n        priority: -1,\n        name: 'vendor',\n        chunks: 'all',\n        enforce: true,\n      },\n    },\n  },\n  minimizer: [\n    new TerserPlugin({\n      terserOptions: {\n        keep_fnames: true,\n      },\n    }),\n  ],\n};\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003C\u002Fdiv\u003E\n                    \u003C\u002Fdiv\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EДля ускорения сборки в этом проекте использую \u003Ca href=\"https:\u002F\u002Fgithub.com\u002Fwebpack-contrib\u002Fthread-loader\" rel=\"nofollow\"\u003Ethread-loader\u003C\u002Fa\u003E — при параллелизации на 4 процесса он дал ускорение сборки на 90%, что лучше, чем у happypack при аналогичных настройках.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EНастройки для лоадеров, в том числе для babel, в отдельные файлы (вроде \u003Ci\u003E.babelrc\u003C\u002Fi\u003E) выносить, полагаю, излишне. А вот конфигурацию кроссбраузерности удобнее держать в параметре \u003Ccode\u003Ebrowserslist\u003C\u002Fcode\u003E основного \u003Ci\u003Epackage.json\u003C\u002Fi\u003E, так как он используется также для autoprefixer'а стилей.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EДля удобства работы с Prettier сделал параметр \u003Ci\u003EAGGREGATION_TIMEOUT\u003C\u002Fi\u003E, который позволяет установить задержку между обнаружением изменений в файлах и пересборкой приложения в режиме dev-server. Так как я настроил переформатирование файлов при сохранении в IDE, то это вызывает 2 пересборки — первую на сохранение исходного файла, вторую на завершение форматирования. 2000 миллисекунд обычно достаточно, чтобы webpack дождался финальной версии файла.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EОстальная конфигурация особого внимания не заслуживает, так как раскрыта в сотнях обучающих материалов для начинающих, поэтому можно переходить к проектированию архитектуры приложения.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Ch3\u003EСтилевые темы\u003C\u002Fh3\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EРаньше для создания тем приходилось делать несколько версий \u003Ci\u003E*.css\u003C\u002Fi\u003E файлов и перезагружать страницу при смене темы, загружая нужный набор стилей. Сейчас все легко решается с помощью \u003Ca href=\"https:\u002F\u002Fdeveloper.mozilla.org\u002Fru\u002Fdocs\u002FWeb\u002FCSS\u002FUsing_CSS_custom_properties\" rel=\"nofollow\"\u003ECustom CSS Properties\u003C\u002Fa\u003E. Данную технологию поддерживают все целевые браузеры текущего приложения, но есть и полифиллы для IE.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EДопустим, будет 2 темы — light и dark, наборы цветов для которых будут находиться в\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cdiv class=\"spoiler\" role=\"button\" tabindex=\"0\"\u003E\n                        \u003Cb class=\"spoiler_title\"\u003Estyles\u002Fthemes.scss\u003C\u002Fb\u003E\n                        \u003Cdiv class=\"spoiler_text\"\u003E\u003Cpre\u003E\u003Ccode class=\"plaintext\"\u003E.light {\n  --n0: rgb(255, 255, 255);\n  --n100: rgb(186, 186, 186);\n  --n10: rgb(249, 249, 249);\n  --n10a3: rgba(249, 249, 249, 0.3);\n  --n20: rgb(245, 245, 245);\n  --n30: rgb(221, 221, 221);\n  --n500: rgb(136, 136, 136);\n  --n600: rgb(102, 102, 102);\n  --n900: rgb(0, 0, 0);\n\n  --b100: rgb(219, 237, 251);\n  --b300: rgb(179, 214, 252);\n  --b500: rgb(14, 123, 249);\n  --b500a3: rgba(14, 123, 249, 0.3);\n  --b900: rgb(32, 39, 57);\n\n  --g400: rgb(71, 215, 141);\n  --g500: rgb(61, 189, 125);\n  --g500a1: rgba(61, 189, 125, 0.1);\n  --g500a2: rgba(61, 189, 125, 0.2);\n\n  --r400: rgb(255, 100, 100);\n  --r500: rgb(255, 0, 0);\n  --r500a1: rgba(255, 0, 0, 0.1);\n  --r500a2: rgba(255, 0, 0, 0.2);\n}\n\n.dark {\n  --n0: rgb(25, 32, 48);\n  --n100: rgb(114, 126, 151);\n  --n10: rgb(39, 46, 62);\n  --n10a3: rgba(39, 46, 62, 0.3);\n  --n20: rgb(25, 44, 74);\n  --n30: rgb(67, 75, 111);\n  --n500: rgb(117, 128, 154);\n  --n600: rgb(255, 255, 255);\n  --n900: rgb(255, 255, 255);\n\n  --b100: rgb(219, 237, 251);\n  --b300: rgb(39, 46, 62);\n  --b500: rgb(14, 123, 249);\n  --b500a3: rgba(14, 123, 249, 0.3);\n  --b900: rgb(32, 39, 57);\n\n  --g400: rgb(0, 220, 103);\n  --g500: rgb(0, 197, 96);\n  --g500a1: rgba(0, 197, 96, 0.1);\n  --g500a2: rgba(0, 197, 96, 0.2);\n\n  --r400: rgb(248, 23, 1);\n  --r500: rgb(221, 23, 1);\n  --r500a1: rgba(221, 23, 1, 0.1);\n  --r500a2: rgba(221, 23, 1, 0.2);\n}\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003C\u002Fdiv\u003E\n                    \u003C\u002Fdiv\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EДля того, чтобы эти переменные применялись глобально, их нужно записать в \u003Ccode\u003Edocument.documentElement\u003C\u002Fcode\u003E, соответственно нужен небольшой парсер, чтобы преобразовать этот файл в javascript объект. Позже расскажу, почему так удобнее, чем сразу хранить в javascript.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cdiv class=\"spoiler\" role=\"button\" tabindex=\"0\"\u003E\n                        \u003Cb class=\"spoiler_title\"\u003Ewebpack-custom\u002Futils\u002FsassVariablesLoader.js\u003C\u002Fb\u003E\n                        \u003Cdiv class=\"spoiler_text\"\u003E\u003Cpre\u003E\u003Ccode class=\"javascript\"\u003Efunction convertSourceToJsObject(source) {\n  const themesObject = {};\n  const fullThemesArray = source.match(\u002F\\.([^}]|\\s)*}\u002Fg) || [];\n\n  fullThemesArray.forEach(fullThemeStr =\u003E {\n    const theme = fullThemeStr\n      .match(\u002F\\.\\w+\\s{\u002Fg)[0]\n      .replace(\u002F\\W\u002Fg, '');\n    themesObject[theme] = {};\n\n    const variablesMatches =\n      fullThemeStr.match(\u002F--(.*:[^;]*)\u002Fg) || [];\n\n    variablesMatches.forEach(varMatch =\u003E {\n      const [key, value] = varMatch.split(': ');\n      themesObject[theme][key] = value;\n    });\n  });\n\n  return themesObject;\n}\n\nfunction checkThemesEquality(themes) {\n  const themesArray = Object.keys(themes);\n\n  themesArray.forEach(themeStr =\u003E {\n    const themeObject = themes[themeStr];\n    const otherThemesArray = themesArray.filter(t =\u003E t !== themeStr);\n\n    Object.keys(themeObject).forEach(variableName =\u003E {\n      otherThemesArray.forEach(otherThemeStr =\u003E {\n        const otherThemeObject = themes[otherThemeStr];\n\n        if (!otherThemeObject[variableName]) {\n          throw new Error(\n            `checkThemesEquality: theme ${otherThemeStr} has no variable ${variableName}`\n          );\n        }\n      });\n    });\n  });\n}\n\nmodule.exports = function sassVariablesLoader(source) {\n  const themes = convertSourceToJsObject(source);\n\n  checkThemesEquality(themes);\n\n  return `module.exports = ${JSON.stringify(themes)}`;\n};\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003C\u002Fdiv\u003E\n                    \u003C\u002Fdiv\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EЗдесь же проверяется согласованность тем — то есть полное соответствие набора переменных, при различии которых сборка падает.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EПри использовании этого лоадера получается вполне красивый объект с параметрами, и достаточно пары строк для утилиты смены темы:\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cdiv class=\"spoiler\" role=\"button\" tabindex=\"0\"\u003E\n                        \u003Cb class=\"spoiler_title\"\u003Esrc\u002Futils\u002FsetTheme.js\u003C\u002Fb\u003E\n                        \u003Cdiv class=\"spoiler_text\"\u003E\u003Cpre\u003E\u003Ccode class=\"javascript\"\u003Eimport themes from 'styles\u002Fthemes.scss';\n\nconst root = document.documentElement;\n\nexport function setTheme(theme) {\n  Object.entries(themes[theme]).forEach(([key, value]) =\u003E {\n    root.style.setProperty(key, value);\n  });\n}\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003C\u002Fdiv\u003E\n                    \u003C\u002Fdiv\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EПредпочитаю перевести эти css-переменные в стандартные для \u003Ci\u003E*.scss\u003C\u002Fi\u003E:\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cdiv class=\"spoiler\" role=\"button\" tabindex=\"0\"\u003E\n                        \u003Cb class=\"spoiler_title\"\u003Esrc\u002Fstyles\u002Fconstants.scss\u003C\u002Fb\u003E\n                        \u003Cdiv class=\"spoiler_text\"\u003E\u003Cimg src=\"\u002Fimg\u002Fimage-loader.svg\" data-src=\"https:\u002F\u002Fhabrastorage.org\u002Fwebt\u002Fpy\u002Fb5\u002Fjf\u002Fpyb5jfs2g07r-ypnnkoudkdxe7s.png\"\u002F\u003E\u003Cbr\u002F\u003E\r\n\u003C\u002Fdiv\u003E\n                    \u003C\u002Fdiv\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EIDE WebStorm, как видно на скриншоте, показывает цвета на панели слева и по клику на цвет открывает палитру, где можно его сменить. Новый цвет автоматически подставится в \u003Ci\u003Ethemes.scss\u003C\u002Fi\u003E, сработает Hot Reload и приложение моментально преобразится. Это именно тот уровень удобства разработки, который и ожидается в 2019 году.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Ch3\u003EПринципы организации кода\u003C\u002Fh3\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EВ данном проекте буду придерживаться дублирования названий папок компонентов, файлов и стилей, например:\u003C\u002Fp\u003E\u003Cp\u003E\u003C\u002Fp\u003E\u003Cpre\u003E\u003Ccode class=\"pgsql\"\u003E.\n|-- components\n|   |-- Chart\n|   |   `-- Chart.js\n|   |   `-- Chart.scss\n|   |   `-- package.json\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EСоответственно, \u003Ci\u003Epackage.json\u003C\u002Fi\u003E будет иметь содержание \u003Ccode\u003E{ \"main\": \"Chart.js\" }\u003C\u002Fcode\u003E. Для компонентов с множественными именованными экспортами (например, утилит) название главного файла будет начинаться с подчеркивания:\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"pgsql\"\u003E.\n|-- utils\n|   `-- _utils.js\n|   `-- someUtil.js\n|   `-- anotherUtil.js\n|   `-- package.json\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EА остальные файлы будут экспортироваться в виде:\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"javascript\"\u003Eexport * from '.\u002FsomeUtil';\nexport * from '.\u002FanotherUtil';\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EЭто позволит избавиться от дублирования названий файлов, чтобы не теряться в десятке открытых \u003Ci\u003Eindex.js\u003C\u002Fi\u003E \u002F \u003Ci\u003Estyle.scss\u003C\u002Fi\u003E. Можно решить это и плагинами к IDE, но почему бы и не универсальным способом.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EКомпоненты буду группировать постранично, кроме общих вроде Message \u002F Link, а также по возможности использовать именованные экспорты (без \u003Ccode\u003Eexport default\u003C\u002Fcode\u003E) для поддержания однообразия названий, простоты рефакторинга и поиска по проекту.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Ch3\u003EНастройка рендеринга и хранилища MobX\u003C\u002Fh3\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EФайл, который служит entry point для Webpack, будет выглядеть следующим образом:\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cdiv class=\"spoiler\" role=\"button\" tabindex=\"0\"\u003E\n                        \u003Cb class=\"spoiler_title\"\u003Esrc\u002Fapp.js\u003C\u002Fb\u003E\n                        \u003Cdiv class=\"spoiler_text\"\u003E\u003Cpre\u003E\u003Ccode class=\"javascript\"\u003Eimport '.\u002Fpolyfill';\nimport '.\u002Fstyles\u002Freset.scss';\nimport '.\u002Fstyles\u002Fglobal.scss';\n\nimport { initSentry, renderToDOM } from 'utils';\nimport { initAutorun } from '.\u002Fautorun';\nimport { store } from 'stores';\n\nimport App from 'components\u002FApp';\n\ninitSentry();\ninitAutorun(store);\nrenderToDOM(App);\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003C\u002Fdiv\u003E\n                    \u003C\u002Fdiv\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EТак как при работе с observables в консоли выводится что-то вроде \u003Ccode\u003EProxy {0: \"btc\", 1: \"eth\", 2: \"usd\", 3: \"test\", Symbol(mobx administration): ObservableArrayAdministration}\u003C\u002Fcode\u003E, в полифиллах сделаю утилиту для приведения в стандартный вид:\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cdiv class=\"spoiler\" role=\"button\" tabindex=\"0\"\u003E\n                        \u003Cb class=\"spoiler_title\"\u003Esrc\u002Fpolyfill.js\u003C\u002Fb\u003E\n                        \u003Cdiv class=\"spoiler_text\"\u003E\u003Cpre\u003E\u003Ccode class=\"javascript\"\u003Eimport { toJS } from 'mobx';\n\nconsole.js = function consoleJsCustom(...args) {\n  console.log(...args.map(arg =\u003E toJS(arg)));\n};\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003C\u002Fdiv\u003E\n                    \u003C\u002Fdiv\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EТакже в основном файле подключаются глобальные стили и нормализация стилей для разных браузеров, при наличии ключа для Sentry в .env.frontend начинают логироваться ошибки, создается MobX хранилище, инициируется слежение за изменениями параметров с помощью autorun и обернутый в \u003Ci\u003Ereact-hot-loader\u003C\u002Fi\u003E компонент монтируется в DOM.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EСамо хранилище будет представлять из себя не-observable класс, параметрами которого будут не-observable классы с observable параметрами. Таким образом подразумевается, что набор параметров не будет динамическим — следовательно, приложение будет более предсказуемым. Это одно из немногих мест, где пригодится JSDoc, чтобы включить автодополнение в IDE.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cdiv class=\"spoiler\" role=\"button\" tabindex=\"0\"\u003E\n                        \u003Cb class=\"spoiler_title\"\u003Esrc\u002Fstores\u002FRootStore.js\u003C\u002Fb\u003E\n                        \u003Cdiv class=\"spoiler_text\"\u003E\u003Cpre\u003E\u003Ccode class=\"javascript\"\u003Eimport { I18nStore } from '.\u002FI18nStore';\nimport { RatesStore } from '.\u002FRatesStore';\nimport { GlobalStore } from '.\u002FGlobalStore';\nimport { RouterStore } from '.\u002FRouterStore';\nimport { CurrentTPStore } from '.\u002FCurrentTPStore';\nimport { MarketsListStore } from '.\u002FMarketsListStore';\n\n\u002F**\n * @name RootStore\n *\u002F\nexport class RootStore {\n  constructor() {\n    this.i18n = new I18nStore(this);\n    this.rates = new RatesStore(this);\n    this.global = new GlobalStore(this);\n    this.router = new RouterStore(this);\n    this.currentTP = new CurrentTPStore(this);\n    this.marketsList = new MarketsListStore(this);\n  }\n}\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003C\u002Fdiv\u003E\n                    \u003C\u002Fdiv\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EПример MobX стора можно разобрать на примере GlobalStore, у которого будет на данный момент единственное назначение — хранить и устанавливать текущую стилевую тему.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cdiv class=\"spoiler\" role=\"button\" tabindex=\"0\"\u003E\n                        \u003Cb class=\"spoiler_title\"\u003Esrc\u002Fstores\u002FGlobalStore.js\u003C\u002Fb\u003E\n                        \u003Cdiv class=\"spoiler_text\"\u003E\u003Cpre\u003E\u003Ccode class=\"javascript\"\u003Eimport { makeObservable, setTheme } from 'utils';\nimport themes from 'styles\u002Fthemes.scss';\n\nconst themesList = Object.keys(themes);\n\n@makeObservable\nexport class GlobalStore {\n  \u002F**\n   * @param rootStore {RootStore}\n   *\u002F\n  constructor(rootStore) {\n    this.rootStore = rootStore;\n\n    setTheme(themesList[0]);\n  }\n\n  themesList = themesList;\n  currentTheme = '';\n\n  setTheme(theme) {\n    this.currentTheme = theme;\n    setTheme(theme);\n  }\n}\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003C\u002Fdiv\u003E\n                    \u003C\u002Fdiv\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EИногда параметрам и методом класса вручную с помощью декораторов устанавливают тип, например:\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"javascript\"\u003Eexport class GlobalStore {\n  @observable\n  currentTheme = '';\n\n  @action.bound\n  setTheme(theme) {\n    this.currentTheme = theme;\n    setTheme(theme);\n  }\n}\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EНо смысла в этом не вижу, так как старый Proposal декораторов класса поддерживает их автоматическую трансформацию, поэтому достаточно следующей утилиты:\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cdiv class=\"spoiler\" role=\"button\" tabindex=\"0\"\u003E\n                        \u003Cb class=\"spoiler_title\"\u003Esrc\u002Futils\u002FmakeObservable.js\u003C\u002Fb\u003E\n                        \u003Cdiv class=\"spoiler_text\"\u003E\u003Cpre\u003E\u003Ccode class=\"javascript\"\u003Eimport { action, computed, decorate, observable } from 'mobx';\n\nexport function makeObservable(target) {\n  \u002F**\n   * Для методов - биндим контекст this + все изменения сторов\n   * выполняем в одной транзакции\n   *\n   * Для геттеров - оборачиваем в computed\n   *\n   *\u002F\n\n  const classPrototype = target.prototype;\n  const methodsAndGetters = Object.getOwnPropertyNames(classPrototype).filter(\n    methodName =\u003E methodName !== 'constructor'\n  );\n\n  for (const methodName of methodsAndGetters) {\n    const descriptor = Object.getOwnPropertyDescriptor(\n      classPrototype,\n      methodName\n    );\n\n    descriptor.value = decorate(classPrototype, {\n      [methodName]:\n        typeof descriptor.value === 'function' ? action.bound : computed,\n    });\n  }\n\n  return (...constructorArguments) =\u003E {\n    \u002F**\n     * Параметры, за исключением rootStore, трансформируем в\n     * observable\n     *\n     *\u002F\n\n    const store = new target(...constructorArguments);\n    const staticProperties = Object.keys(store);\n\n    staticProperties.forEach(propName =\u003E {\n      if (propName === 'rootStore') {\n        return false;\n      }\n\n      const descriptor = Object.getOwnPropertyDescriptor(store, propName);\n\n      Object.defineProperty(\n        store,\n        propName,\n        observable(store, propName, descriptor)\n      );\n    });\n\n    return store;\n  };\n}\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003C\u002Fdiv\u003E\n                    \u003C\u002Fdiv\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EДля использования необходимо откорректировать плагины в \u003Ci\u003EloaderBabel.js\u003C\u002Fi\u003E: \u003Ccode\u003E['@babel\u002Fplugin-proposal-decorators', { legacy: true }], ['@babel\u002Fplugin-proposal-class-properties', { loose: true }]\u003C\u002Fcode\u003E, а в настройках ESLint соответственно выставить \u003Ccode\u003EparserOptions.ecmaFeatures.legacyDecorators: true\u003C\u002Fcode\u003E. Без этих настроек в target декоратора передается только дескриптор класса без прототипа, и, несмотря на тщательное исследование \u003Ca href=\"https:\u002F\u002Ftc39.github.io\u002Fproposal-decorators\u002F\" rel=\"nofollow\"\u003Eтекущей версии Proposal\u003C\u002Fa\u003E, я не нашел способа обернуть методы и статические свойства.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EВ целом настройка хранилища закончена, но хорошо бы еще раскрыть потенциал MobX autorun. Для этого как нельзя лучше подойдут задачи типа «дождаться ответа от сервера авторизации» или «загрузить переводы с сервера», после чего записать ответы в стор и непосредственно отрендерить приложение в DOM. Поэтому забегу немного в будущее и создам стор с локализацией:\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cdiv class=\"spoiler\" role=\"button\" tabindex=\"0\"\u003E\n                        \u003Cb class=\"spoiler_title\"\u003Esrc\u002Fstores\u002FI18nStore.js\u003C\u002Fb\u003E\n                        \u003Cdiv class=\"spoiler_text\"\u003E\u003Cpre\u003E\u003Ccode class=\"javascript\"\u003Eimport { makeObservable } from 'utils';\nimport ru from 'localization\u002Fru.json';\nimport en from 'localization\u002Fen.json';\n\nconst languages = {\n  ru,\n  en,\n};\n\nconst languagesList = Object.keys(languages);\n\n@makeObservable\nexport class I18nStore {\n  \u002F**\n   * @param rootStore {RootStore}\n   *\u002F\n  constructor(rootStore) {\n    this.rootStore = rootStore;\n\n    setTimeout(() =\u003E {\n      this.setLocalization('ru');\n    }, 500);\n  }\n\n  i18n = {};\n  languagesList = languagesList;\n  currentLanguage = '';\n\n  setLocalization(language) {\n    this.currentLanguage = language;\n    this.i18n = languages[language];\n    this.rootStore.global.shouldAppRender = true;\n  }\n}\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003C\u002Fdiv\u003E\n                    \u003C\u002Fdiv\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EКак видно, есть некие файлы \u003Ci\u003E*.json\u003C\u002Fi\u003E с переводами, а в конструкторе класса эмулируется асинхронная загрузка с помощью setTimeout. При его выполнении в недавно созданном GlobalStore проставляется маркер \u003Ccode\u003Ethis.rootStore.global.shouldAppRender = true\u003C\u002Fcode\u003E.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EТаким образом, из \u003Ci\u003Eapp.js\u003C\u002Fi\u003E нужно перенести функцию рендеринга в файл \u003Ci\u003Eautorun.js\u003C\u002Fi\u003E:\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cdiv class=\"spoiler\" role=\"button\" tabindex=\"0\"\u003E\n                        \u003Cb class=\"spoiler_title\"\u003Esrc\u002Fautorun.js\u003C\u002Fb\u003E\n                        \u003Cdiv class=\"spoiler_text\"\u003E\u003Cpre\u003E\u003Ccode class=\"javascript\"\u003E\u002F* eslint-disable no-unused-vars *\u002F\n\nimport { autorun } from 'mobx';\n\nimport { renderToDOM } from 'utils';\nimport App from 'components\u002FApp';\n\nconst loggingEnabled = true;\n\nfunction logReason(autorunName, reaction) {\n  if (!loggingEnabled || reaction.observing.length === 0) {\n    return false;\n  }\n\n  const logString = reaction.observing.reduce(\n    (str, { name, value }) =\u003E `${str}${name} changed to ${value}; `,\n    ''\n  );\n\n  console.log(`autorun-${autorunName}`, logString);\n}\n\n\u002F**\n * @param store {RootStore}\n *\u002F\nexport function initAutorun(store) {\n  autorun(reaction =\u003E {\n    if (store.global.shouldAppRender) {\n      renderToDOM(App);\n    }\n\n    logReason('shouldAppRender', reaction);\n  });\n}\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003C\u002Fdiv\u003E\n                    \u003C\u002Fdiv\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EВ функции \u003Ci\u003EinitAutorun\u003C\u002Fi\u003E может быть сколько угодно \u003Ci\u003Eautorun\u003C\u002Fi\u003E конструкций с коллбэками, которые сработают только при собственной инициации и изменении переменной внутри конкретного коллбэка. В данном случае в консоль будет выведено \u003Ccode\u003Eautorun-shouldAppRender GlobalStore@3.shouldAppRender changed to true;\u003C\u002Fcode\u003E, и вызван рендеринг приложения в DOM. Мощный инструмент, позволяющий логировать все изменения в сторе и соответственно на них реагировать.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Ch3\u003EЛокализация и React Hooks\u003C\u002Fh3\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EПеревод на другие языки — одна из самых объемных задач, в небольших компаниях зачастую недооцененная в десятки раз, а в крупных — излишне переусложненная. От ее реализации зависит, сколько нервов и времени не будет потрачено впустую сразу у нескольких отделов в компании. Затрону в статье только клиентскую часть с заделом на будущую интеграцию с другими системами.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EДля удобства разработки фронтенда необходимо иметь возможность:\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cul\u003E\r\n\u003Cli\u003Eзадавать семантичные имена для констант;\u003C\u002Fli\u003E\r\n\u003Cli\u003Eвставлять динамические переменные;\u003C\u002Fli\u003E\r\n\u003Cli\u003Eуказывать единственное \u002F множественное число;\u003C\u002Fli\u003E\r\n\u003Cli\u003Eлегко подключать локализацию куда угодно — функцией или реакт-компонентом;\u003C\u002Fli\u003E\r\n\u003Cli\u003Eне думать о пересечении названий параметров в разных компонентах;\u003C\u002Fli\u003E\r\n\u003Cli\u003Eпри деплое собирать список всех добавленных \u002F измененных параметров;\u003C\u002Fli\u003E\r\n\u003Cli\u003Eотлаживать локально;\u003C\u002Fli\u003E\r\n\u003Cli\u003E(желательно) склонять по родам;\u003C\u002Fli\u003E\r\n\u003Cli\u003E(желательно) со стороны бэка получать сообщения только в виде констант, для всех из них имея маппер на текущий язык.\u003C\u002Fli\u003E\r\n\u003C\u002Ful\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EПод эти условия подходит, к примеру, следующая схема: в каждом компоненте с текстами будет лежать файл \u003Ci\u003Emessages.js\u003C\u002Fi\u003E с базовыми значениями для разработки (которые в идеале никогда не увидит клиент) в виде обычного объекта с параметрами. Вставка в компонент будет происходить однострочно с помощью хука. Полное название параметра будет формироваться автоматически по пути к файлу в проекте (при необходимости можно легко обфусцировать \u002F сократить), что исключит пересечение названий. Функции преобразования текста (вставка переменных, склонений, чисел) выполняются последовательно. Должно получиться удобно.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EТак как уже есть стор с локализацией, в котором лежит \u003Ci\u003EcurrentLanguage\u003C\u002Fi\u003E и объект \u003Ci\u003Ei18n\u003C\u002Fi\u003E с потенциально присутствующими переводами, можно написать хук, который будет получать оттуда тексты.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cdiv class=\"spoiler\" role=\"button\" tabindex=\"0\"\u003E\n                        \u003Cb class=\"spoiler_title\"\u003Esrc\u002Fcomponents\u002FTestLocalization.js\u003C\u002Fb\u003E\n                        \u003Cdiv class=\"spoiler_text\"\u003E\u003Cpre\u003E\u003Ccode class=\"javascript\"\u003Eimport React from 'react';\n\nimport { observer } from 'utils';\nimport { useLocalization } from 'hooks';\n\nconst messages = {\n  hello: 'У вас {count} {count: сообщение,сообщения,сообщений}',\n};\n\nfunction TestLocalization() {\n  const getLn = useLocalization(__filename, messages);\n\n  return &lt;div\u003E{getLn(messages.hello, { count: 1 })}&lt;\u002Fdiv\u003E;\n}\n\nexport const TestLocalizationConnected = observer(TestLocalization);\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003C\u002Fdiv\u003E\n                    \u003C\u002Fdiv\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EСам функциональный компонент имеет имя по названию файла, а на экспорт идет подключенный к MobX-стору автоматически обновляемый компонент с суффиксом, к примеру, Connected. Возможно, стоит внести подобное правило именования в ESLint, чтобы явно отличать подключенные к стору компоненты.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EДекоратор observer представляет собой обертку над \u003Ccode\u003Emobx-react-lite\u002FuseObserver\u003C\u002Fcode\u003E, которая при выключенном \u003Ci\u003EHOT_RELOAD\u003C\u002Fi\u003E оптимизирует обновление компонентов с помощью \u003Ci\u003EReact.memo\u003C\u002Fi\u003E (в прошлом \u003Ci\u003EPureMixin\u003C\u002Fi\u003E \u002F \u003Ci\u003EPureComponent\u003C\u002Fi\u003E), а при включенном просто оборачивает в \u003Ci\u003EuseObserver\u003C\u002Fi\u003E все содержимое компонента:\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cdiv class=\"spoiler\" role=\"button\" tabindex=\"0\"\u003E\n                        \u003Cb class=\"spoiler_title\"\u003Esrc\u002Futils\u002Fobserver.js\u003C\u002Fb\u003E\n                        \u003Cdiv class=\"spoiler_text\"\u003E\u003Cpre\u003E\u003Ccode class=\"javascript\"\u003Eimport { useObserver } from 'mobx-react-lite';\nimport React from 'react';\n\nfunction copyStaticProperties(base, target) {\n  const hoistBlackList = {\n    $$typeof: true,\n    render: true,\n    compare: true,\n    type: true,\n  };\n\n  Object.keys(base).forEach(key =\u003E {\n    if (base.hasOwnProperty(key) &amp;&amp; !hoistBlackList[key]) {\n      Object.defineProperty(\n        target,\n        key,\n        Object.getOwnPropertyDescriptor(base, key)\n      );\n    }\n  });\n}\n\nexport function observer(baseComponent, options) {\n  const baseComponentName = baseComponent.displayName || baseComponent.name;\n\n  function wrappedComponent(props, ref) {\n    return useObserver(function applyObserver() {\n      return baseComponent(props, ref);\n    }, baseComponentName);\n  }\n  wrappedComponent.displayName = baseComponentName;\n\n  let memoComponent = null;\n  if (HOT_RELOAD === 'true') {\n    memoComponent = wrappedComponent;\n  } else if (options.forwardRef) {\n    memoComponent = React.memo(React.forwardRef(wrappedComponent));\n  } else {\n    memoComponent = React.memo(wrappedComponent);\n  }\n\n  copyStaticProperties(baseComponent, memoComponent);\n  memoComponent.displayName = baseComponentName;\n\n  return memoComponent;\n}\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003C\u002Fdiv\u003E\n                    \u003C\u002Fdiv\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EВнимания заслуживает только передача \u003Ccode\u003EdisplayName\u003C\u002Fcode\u003E на каждом этапе, чтобы в React-инспекторе были красивые названия элементов (на stack trace ошибок не влияет).\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EТеперь нужен хук для вставки RootStore:\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cdiv class=\"spoiler\" role=\"button\" tabindex=\"0\"\u003E\n                        \u003Cb class=\"spoiler_title\"\u003Esrc\u002Fhooks\u002FuseStore.js\u003C\u002Fb\u003E\n                        \u003Cdiv class=\"spoiler_text\"\u003E\u003Cpre\u003E\u003Ccode class=\"javascript\"\u003Eimport React from 'react';\nimport { store } from 'stores';\n\nconst storeContext = React.createContext(store);\n\n\u002F**\n * @returns {RootStore}\n *\n *\u002F\nexport function useStore() {\n  return React.useContext(storeContext);\n}\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003C\u002Fdiv\u003E\n                    \u003C\u002Fdiv\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EКоторый можно легко использовать в любом компоненте, обернутом в observer:\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"javascript\"\u003Eimport React from 'react';\n\nimport { observer } from 'utils';\nimport { useStore } from 'hooks';\n\nfunction TestComponent() {\n  const store = useStore();\n\n  return &lt;div\u003E{store.i18n.currentLanguage}&lt;\u002Fdiv\u003E;\n}\n\nexport const TestComponentConnected = observer(TestComponent);\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EВозвращаясь к созданному выше компоненту TestLocalization — осталось лишь сделать хук useLocalization:\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cdiv class=\"spoiler\" role=\"button\" tabindex=\"0\"\u003E\n                        \u003Cb class=\"spoiler_title\"\u003Esrc\u002Fhooks\u002FuseLocalization.js\u003C\u002Fb\u003E\n                        \u003Cdiv class=\"spoiler_text\"\u003E\u003Cpre\u003E\u003Ccode class=\"javascript\"\u003Eimport _ from 'lodash';\n\nimport { declOfNum } from 'utils';\n\nimport { useStore } from '.\u002FuseStore';\n\nconst showNoTextMessage = false;\n\nfunction replaceDynamicParams(values, formattedMessage) {\n  if (!_.isPlainObject(values)) {\n    return formattedMessage;\n  }\n\n  let messageWithValues = formattedMessage;\n\n  Object.entries(values).forEach(([paramName, value]) =\u003E {\n    messageWithValues = formattedMessage.replace(`{${paramName}}`, value);\n  });\n\n  return messageWithValues;\n}\n\nfunction replacePlurals(values, formattedMessage) {\n  if (!_.isPlainObject(values)) {\n    return formattedMessage;\n  }\n\n  let messageWithPlurals = formattedMessage;\n\n  Object.entries(values).forEach(([paramName, value]) =\u003E {\n    const pluralPattern = new RegExp(`{${paramName}:\\\\s([^}]*)}`);\n    const pluralMatch = formattedMessage.match(pluralPattern);\n\n    if (pluralMatch &amp;&amp; pluralMatch[1]) {\n      messageWithPlurals = formattedMessage.replace(\n        pluralPattern,\n        declOfNum(value, pluralMatch[1].split(','))\n      );\n    }\n  });\n\n  return messageWithPlurals;\n}\n\nexport function useLocalization(filename, messages) {\n  const {\n    i18n: { i18n, currentLanguage },\n  } = useStore();\n\n  return function getLn(text, values) {\n    const key = _.findKey(messages, message =\u003E message === text);\n    const localizedText = _.get(i18n, [filename, key]);\n\n    if (!localizedText &amp;&amp; showNoTextMessage) {\n      console.error(\n        `useLocalization: no localization for lang '${currentLanguage}' in ${filename} ${key}`\n      );\n    }\n\n    let formattedMessage = localizedText || text;\n    formattedMessage = replaceDynamicParams(values, formattedMessage);\n    formattedMessage = replacePlurals(values, formattedMessage);\n\n    return formattedMessage;\n  };\n}\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003C\u002Fdiv\u003E\n                    \u003C\u002Fdiv\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EФункции \u003Ci\u003EreplaceDynamicParams\u003C\u002Fi\u003E и \u003Ci\u003EreplacePlurals\u003C\u002Fi\u003E написаны для конкретного примера — вместо них можно использовать любой шаблонизатор для конкретных языков проекта и поддерживающий, например, строки с включенными объектами, массивы, форматирование дат, склонение имен и городов и т.п.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EДанный хук принимает в себя системную константу от Webpack — \u003Ci\u003E__filename\u003C\u002Fi\u003E — и объект с сообщениями, а возвращает функцию, которая непосредственно сходит в стор за значением. При желании можно включить отображение сообщений об отсутствии переводов, хотя при разработке это не нужно — переводы будут приходить на стенды из системы локализации, соответственно локально их все равно не будет, а отобразится значение по умолчанию. Но если все же включить, то сейчас в консоли отобразится:\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"javascript\"\u003EuseLocalization: no localization for lang 'ru' in src\\components\\TestLocalization\\TestLocalization.js hello\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EЕсли же добавить локализацию для данного поля в \u003Ci\u003Eru.json\u003C\u002Fi\u003E:\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cdiv class=\"spoiler\" role=\"button\" tabindex=\"0\"\u003E\n                        \u003Cb class=\"spoiler_title\"\u003Esrc\u002Flocalization\u002Fru.json\u003C\u002Fb\u003E\n                        \u003Cdiv class=\"spoiler_text\"\u003E\u003Cpre\u003E\u003Ccode class=\"json\"\u003E{\n  \"src\\\\components\\\\TestLocalization\\\\TestLocalization.js\": {\n    \"hello\": \"У вас {count} {count: сообщение,сообщения,сообщений}\"\n  }\n}\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003C\u002Fdiv\u003E\n                    \u003C\u002Fdiv\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EТо все заработает, как и ожидалось. А при добавлении в файл \u003Ci\u003Esrc\u002Flocalization\u002Fen.json\u003C\u002Fi\u003E аналогичного перевода заработает и смена языков «на лету» с помощью метода \u003Ci\u003EsetLocalization\u003C\u002Fi\u003E из I18nStore.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EМожно сделать и «привычный» в экосистеме React компонент Message:\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cdiv class=\"spoiler\" role=\"button\" tabindex=\"0\"\u003E\n                        \u003Cb class=\"spoiler_title\"\u003Esrc\u002Fcomponents\u002FMessage\u002FMessage.js\u003C\u002Fb\u003E\n                        \u003Cdiv class=\"spoiler_text\"\u003E\u003Cpre\u003E\u003Ccode class=\"javascript\"\u003Eimport React from 'react';\n\nimport { observer } from 'utils';\nimport { useLocalization } from 'hooks';\n\nfunction Message(props) {\n  const { filename, messages, text, values } = props;\n\n  const getLn = useLocalization(filename, messages);\n\n  return getLn(text, values);\n}\n\nconst ConnectedMessage = observer(Message);\n\nexport function init(filename, messages) {\n  return function MessageHoc(props) {\n    const fullProps = { filename, messages, ...props };\n\n    return &lt;ConnectedMessage {...fullProps} \u002F\u003E;\n  };\n}\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003C\u002Fdiv\u003E\n                    \u003C\u002Fdiv\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EТак как нужно каждый раз передавать переменную __filename (либо каждый раз уникальный id как в страшном сне разработчика), то импорт этого компонента будет немного необычным, однако использование стандартным:\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"javascript\"\u003Econst Message = require('components\u002FMessage').init(\n  __filename,\n  messages\n);\n\n&lt;Message text={messages.hello} values={{ count: 1 }} \u002F\u003E\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EИз особенностей — при использовании в компоненте хука \u003Ci\u003EuseLocalization\u003C\u002Fi\u003E и смене языка обновится весь компонент (так как он подписывается на изменение \u003Ci\u003EcurrentLanguage\u003C\u002Fi\u003E, а при использовании компонента Message — только сам текст. Однако это редкая операция, да и затраты на перерендеринг приложения при смене языка копеечные, поэтому я бы пользовался напрямую хуком.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EВ завершение темы можно подумать, как удобнее в будущем состыковать этот подход с системой локализации (под ней подразумеваю административное приложение, в котором переводчики узнают о недостатках переводов, делают свои предложения в виде черновиков, менеджер \u002F тестировщик проводят проверку на стенде и прикрепляют определенные черновики к релизам приложения в production). Так как в текущей схеме уникальные id параметров привязаны к пути к файлу, то можно при деплое на стенд пробегаться по всем \u003Ci\u003Emessages.js\u003C\u002Fi\u003E и формировать \u003Ci\u003E*.json\u003C\u002Fi\u003E файл со списком всех переменных, привязанный к выкладываемой ветке. Затем этот файл автоматически загружать в систему локализации и дожидаться от переводчиков подходящих переводов (а в системе им подсветятся недостающие \u002F удаленные), после чего осуществлять выкладку в production. Семантичность названий параметров и указание на файлы, в которых были правки, очень поможет переводчикам.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EВ целом в связке MobX + Hooks клиентская локализация выглядит удобно. Для перевода констант и сообщений, приходящих с backend, нужно будет написать функцию, работающую непосредственно в сторе, с однотипным механизмом.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Ch3\u003EРабота с API\u003C\u002Fh3\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EКлючевой момент при работе с любыми сторонними данными (с backend, из открытых источников или от пользователя) — это надежная валидация, которая даст уверенность, что фронтенд будет работать предсказуемо. Также полезно иметь централизованный список всех возможных запросов, с описанными передаваемыми и приходящими параметрами. Я бы реализовал это так:\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cdiv class=\"spoiler\" role=\"button\" tabindex=\"0\"\u003E\n                        \u003Cb class=\"spoiler_title\"\u003Esrc\u002Fstores\u002FCurrentTPStore.js\u003C\u002Fb\u003E\n                        \u003Cdiv class=\"spoiler_text\"\u003E\u003Cpre\u003E\u003Ccode class=\"javascript\"\u003Eimport _ from 'lodash';\n\nimport { makeObservable } from 'utils';\nimport { apiRoutes, request } from 'api';\n\n@makeObservable\nexport class CurrentTPStore {\n  \u002F**\n   * @param rootStore {RootStore}\n   *\u002F\n  constructor(rootStore) {\n    this.rootStore = rootStore;\n  }\n\n  id = '';\n  symbol = '';\n  fullName = '';\n  currency = '';\n  tradedCurrency = '';\n  low24h = 0;\n  high24h = 0;\n  lastPrice = 0;\n  marketCap = 0;\n  change24h = 0;\n  change24hPercentage = 0;\n\n  fetchSymbol(params) {\n    const { tradedCurrency, id } = params;\n    const { marketsList } = this.rootStore;\n\n    const requestParams = {\n      id,\n      localization: false,\n      community_data: false,\n      developer_data: false,\n      tickers: false,\n    };\n\n    return request(apiRoutes.symbolInfo, requestParams)\n      .then(data =\u003E this.fetchSymbolSuccess(data, tradedCurrency))\n      .catch(this.fetchSymbolError);\n  }\n  fetchSymbolSuccess(data, tradedCurrency) {\n    const {\n      id,\n      symbol,\n      name,\n      market_data: {\n        high_24h,\n        low_24h,\n        price_change_24h_in_currency,\n        price_change_percentage_24h_in_currency,\n        market_cap,\n        current_price,\n      },\n    } = data;\n\n    this.id = id;\n    this.symbol = symbol;\n    this.fullName = name;\n    this.currency = symbol;\n    this.tradedCurrency = tradedCurrency;\n    this.lastPrice = current_price[tradedCurrency];\n    this.high24h = high_24h[tradedCurrency];\n    this.low24h = low_24h[tradedCurrency];\n    this.change24h = price_change_24h_in_currency[tradedCurrency];\n    this.change24hPercentage =\n      price_change_percentage_24h_in_currency[tradedCurrency];\n    this.marketCap = market_cap[tradedCurrency];\n\n    return Promise.resolve();\n  }\n  fetchSymbolError(error) {\n    console.error(error);\n  }\n}\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003C\u002Fdiv\u003E\n                    \u003C\u002Fdiv\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EК примеру, есть стор, содержащий информацию об открытой торговой паре. Для получения данных вызывается метод \u003Ci\u003EfetchSymbol\u003C\u002Fi\u003E, в который передается id необходимой валюты и валюта, к которой идет торговля. Далее выполняется запрос через утилиту, при успехе — в единой транзакции обновляются данные в сторе (так как все методы автоматически оборачиваются в \u003Ccode\u003E@action.bound\u003C\u002Fcode\u003E), а при ошибке она логируется в Sentry благодаря декоратору в функции инициализации:\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cdiv class=\"spoiler\" role=\"button\" tabindex=\"0\"\u003E\n                        \u003Cb class=\"spoiler_title\"\u003Esrc\u002Futils\u002FinitSentry.js\u003C\u002Fb\u003E\n                        \u003Cdiv class=\"spoiler_text\"\u003E\u003Cpre\u003E\u003Ccode class=\"javascript\"\u003Eimport * as Sentry from '@sentry\u002Fbrowser';\n\nexport function initSentry() {\n  if (SENTRY_URL !== 'false') {\n    Sentry.init({\n      dsn: SENTRY_URL,\n    });\n\n    const originalErrorLogger = console.error;\n    console.error = function consoleErrorCustom(...args) {\n      Sentry.captureException(...args);\n\n      return originalErrorLogger(...args);\n    };\n  }\n}\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003C\u002Fdiv\u003E\n                    \u003C\u002Fdiv\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EДанный запрос наиболее показателен, так как использует сразу весь функционал валидации запросов:\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cdiv class=\"spoiler\" role=\"button\" tabindex=\"0\"\u003E\n                        \u003Cb class=\"spoiler_title\"\u003Esrc\u002Fapi\u002F_api.js\u003C\u002Fb\u003E\n                        \u003Cdiv class=\"spoiler_text\"\u003E\u003Cpre\u003E\u003Ccode class=\"javascript\"\u003Eimport _ from 'lodash';\n\nimport {\n  omitParam,\n  validateRequestParams,\n  makeRequestUrl,\n  makeRequest,\n  validateResponse,\n} from 'api\u002Futils';\n\nexport function request(route, params) {\n  return Promise.resolve()\n    .then(validateRequestParams(route, params))\n    .then(makeRequestUrl(route, params))\n    .then(makeRequest)\n    .then(validateResponse(route, params));\n}\n\nexport const apiRoutes = {\n  symbolInfo: {\n    url: params =\u003E `https:\u002F\u002Fapi.coingecko.com\u002Fapi\u002Fv3\u002Fcoins\u002F${params.id}`,\n    params: {\n      id: omitParam,\n      localization: _.isBoolean,\n      community_data: _.isBoolean,\n      developer_data: _.isBoolean,\n      tickers: _.isBoolean,\n    },\n    responseObject: {\n      id: _.isString,\n      name: _.isString,\n      symbol: _.isString,\n      genesis_date: v =\u003E _.isString(v) || _.isNil(v),\n      last_updated: _.isString,\n      country_origin: _.isString,\n\n      coingecko_rank: _.isNumber,\n      coingecko_score: _.isNumber,\n      community_score: _.isNumber,\n      developer_score: _.isNumber,\n      liquidity_score: _.isNumber,\n      market_cap_rank: _.isNumber,\n      block_time_in_minutes: _.isNumber,\n      public_interest_score: _.isNumber,\n\n      image: _.isPlainObject,\n      links: _.isPlainObject,\n      description: _.isPlainObject,\n      market_data: _.isPlainObject,\n      localization(value, requestParams) {\n        if (requestParams.localization === false) {\n          return true;\n        }\n\n        return _.isPlainObject(value);\n      },\n      community_data(value, requestParams) {\n        if (requestParams.community_data === false) {\n          return true;\n        }\n\n        return _.isPlainObject(value);\n      },\n      developer_data(value, requestParams) {\n        if (requestParams.developer_data === false) {\n          return true;\n        }\n\n        return _.isPlainObject(value);\n      },\n      public_interest_stats: _.isPlainObject,\n\n      tickers(value, requestParams) {\n        if (requestParams.tickers === false) {\n          return true;\n        }\n\n        return _.isArray(value);\n      },\n      categories: _.isArray,\n      status_updates: _.isArray,\n    },\n  },\n};\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003C\u002Fdiv\u003E\n                    \u003C\u002Fdiv\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EСхема работы функции request следующая:\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Col\u003E\r\n\u003Cli\u003Eпринимает объект из apiRoutes и параметры для запроса;\u003C\u002Fli\u003E\r\n\u003Cli\u003Eпроверяет соответствие параметров запроса схеме, описанной в route.params, при этом опуская валидирующие функции, заданные с помощью \u003Ci\u003EomitParam\u003C\u002Fi\u003E;\u003C\u002Fli\u003E\r\n\u003Cli\u003Eформирует итоговый URL запроса исходя из \u003Ccode\u003Eroute.url\u003C\u002Fcode\u003E — если это функция, то передает в нее параметры запроса, если строка — то просто добавляет get-параметры к URL;\u003C\u002Fli\u003E\r\n\u003Cli\u003Eвыполняет запрос с помощью fetch, возвращая преобразованный в объект JSON;\u003C\u002Fli\u003E\r\n\u003Cli\u003Eпроверяет соответствие параметров ответа схеме, описанной в \u003Ccode\u003Eroute.responseObject\u003C\u002Fcode\u003E либо \u003Ccode\u003Eroute.responseArray\u003C\u002Fcode\u003E (если ожидается ответ в виде массива). Первым аргументом в функцию валидации передается значение, а вторым — исходные параметры запроса, чтобы иметь возможность динамической валидации;\u003C\u002Fli\u003E\r\n\u003Cli\u003Eпри любом несовпадении параметров запроса \u002F ответа \u002F адреса запроса \u002F статуса ответа выбрасывается исключение с понятным сообщением, которое ловится в методе стора (в данном случае \u003Ci\u003EfetchSymbolError\u003C\u002Fi\u003E) и логируется.\u003C\u002Fli\u003E\r\n\u003C\u002Fol\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EПодобная схема позволяет быть полностью уверенным в получаемых данных и оперативно реагировать на залогированные ошибки. Например, так выглядит сообщение в Sentry, если не совпал тип одной из переменных в response:\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003E\u003Cimg src=\"\u002Fimg\u002Fimage-loader.svg\" data-src=\"https:\u002F\u002Fhabrastorage.org\u002Fwebt\u002Fmk\u002F7y\u002F8s\u002Fmk7y8sh2cushkehhykrrufsvkre.png\"\u002F\u003E\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EВпоследствии необходимо будет внедрить глубокую валидацию ответа — на отзывчивость приложения выполнение простой функции несколько тысяч раз влияет слабо (при необходимости валидацию можно выполнять в отдельном потоке), но многократно повышает стабильность.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Ch3\u003EРоутинг и отказоустойчивость\u003C\u002Fh3\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EТема еще более объемная, и заслуживает отдельной статьи соразмерной с данной, но проговорить принципы и сделать минимальную реализацию можно. Так, для хорошего роутера нужны:\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cul\u003E\r\n\u003Cli\u003Eединое хранилище всех роутов с возможностью использовать элементы в ссылках;\u003C\u002Fli\u003E\r\n\u003Cli\u003Eдинамические параметры в pathname и search;\u003C\u002Fli\u003E\r\n\u003Cli\u003Eвалидация динамических параметров регулярным выражением \u002F функцией;\u003C\u002Fli\u003E\r\n\u003Cli\u003Eдвусторонняя синхронизация location и состояния приложения в сторах;\u003C\u002Fli\u003E\r\n\u003Cli\u003Eвозможность вызова асинхронных функций в beforeEnter, с передачей в компонент параметра isLoading, пока происходит выполнение;\u003C\u002Fli\u003E\r\n\u003Cli\u003Eвозможность указать стратегию отказоустойчивости в случаях: не совпала маска, не найден подходящий роут, не найден компонент, исключение в beforeEnter, исключение при асинхронных загрузках данных;\u003C\u002Fli\u003E\r\n\u003Cli\u003Eподдержка событий перехода назад \u002F вперед в браузере;\u003C\u002Fli\u003E\r\n\u003Cli\u003Eвозможность полного \u002F частичного отката до состояния перед переходом на роут;\u003C\u002Fli\u003E\r\n\u003Cli\u003Eподдержка анимации переходов между состояниями.\u003C\u002Fli\u003E\r\n\u003C\u002Ful\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EДля начала сделаю только «скелет», который позволит разблокировать развитие продукта и беспрепятственно начать писать компоненты и бизнес-логику, так как полнофункциональный роутинг — задача не на одну неделю. Для начала понадобятся файлы с конфигурацией роутов:\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cdiv class=\"spoiler\" role=\"button\" tabindex=\"0\"\u003E\n                        \u003Cb class=\"spoiler_title\"\u003Esrc\u002Froutes.js\u003C\u002Fb\u003E\n                        \u003Cdiv class=\"spoiler_text\"\u003E\u003Cpre\u003E\u003Ccode class=\"javascript\"\u003Eexport const routes = {\n  marketDetailed: {\n    name: 'marketDetailed',\n    path: '\u002Fmarket\u002F:market\u002F:pair',\n    masks: {\n      pair: \u002F^[a-zA-Z]{3,5}-[a-zA-Z]{3}$\u002F,\n      market: \u002F^[a-zA-Z]{3,4}$\u002F,\n    },\n    beforeEnter(route, store) {\n      const {\n        params: { pair, market },\n      } = route;\n      const [symbol, tradedCurrency] = pair.split('-');\n      const prevMarket = store.marketsList.currentMarket;\n\n      function optimisticallyUpdate() {\n        store.marketsList.currentMarket = market;\n      }\n\n      return Promise.resolve()\n        .then(optimisticallyUpdate)\n        .then(store.marketsList.fetchSymbolsList)\n        .then(store.rates.fetchRates)\n        .then(() =\u003E store.marketsList.fetchMarketList(market, prevMarket))\n        .then(() =\u003E\n          store.currentTP.fetchSymbol({\n            symbol,\n            tradedCurrency,\n          })\n        )\n        .catch(error =\u003E {\n          console.error(error);\n        });\n    },\n  },\n  error404: {\n    name: 'error404',\n    path: '\u002Ferror404',\n  },\n};\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003C\u002Fdiv\u003E\n                    \u003C\u002Fdiv\u003E\u003Cbr\u002F\u003E\r\n\u003Cdiv class=\"spoiler\" role=\"button\" tabindex=\"0\"\u003E\n                        \u003Cb class=\"spoiler_title\"\u003Esrc\u002FrouteComponents.js\u003C\u002Fb\u003E\n                        \u003Cdiv class=\"spoiler_text\"\u003E\u003Cpre\u003E\u003Ccode class=\"javascript\"\u003Eimport { MarketDetailed } from 'pages\u002FMarketDetailed';\nimport { Error404 } from 'pages\u002FError404';\n\nexport const routeComponents = {\n  marketDetailed: MarketDetailed,\n  error404: Error404,\n};\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003C\u002Fdiv\u003E\n                    \u003C\u002Fdiv\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EКомпоненты, соответствующие роутам, вынесены в отдельный файл для защиты от цикличной зависимости — если в компонентах использовать удобные конструкторы ссылок вида \u003Ccode\u003E&lt;Link route={routes.marketDetailed}\u003E\u003C\u002Fcode\u003E, то возникнет цикличный импорт. Webpack в некоторых случаях умеет справляться с этим, но лучше не полагаться на удачу.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EТеперь необходим стор, который двусторонне свяжет location и подходящий роут из списка выше.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cdiv class=\"spoiler\" role=\"button\" tabindex=\"0\"\u003E\n                        \u003Cb class=\"spoiler_title\"\u003Esrc\u002Fstores\u002FRouterStore.js\u003C\u002Fb\u003E\n                        \u003Cdiv class=\"spoiler_text\"\u003E\u003Cpre\u003E\u003Ccode class=\"javascript\"\u003Eimport _ from 'lodash';\n\nimport { makeObservable } from 'utils';\nimport { routes } from 'routes';\n\n@makeObservable\nexport class RouterStore {\n  \u002F**\n   * @param rootStore {RootStore}\n   *\u002F\n  constructor(rootStore) {\n    this.rootStore = rootStore;\n    this.currentRoute = this._fillRouteSchemaFromUrl();\n\n    window.addEventListener('popstate', () =\u003E {\n      this.currentRoute = this._fillRouteSchemaFromUrl();\n    });\n  }\n\n  currentRoute = null;\n\n  _fillRouteSchemaFromUrl() {\n    const pathnameArray = window.location.pathname.split('\u002F');\n    const routeName = this._getRouteNameMatchingUrl(pathnameArray);\n\n    if (!routeName) {\n      const currentRoute = routes.error404;\n      window.history.pushState(null, null, currentRoute.path);\n\n      return currentRoute;\n    }\n\n    const route = routes[routeName];\n    const routePathnameArray = route.path.split('\u002F');\n\n    const params = {};\n\n    routePathnameArray.forEach((pathParam, i) =\u003E {\n      const urlParam = pathnameArray[i];\n\n      if (pathParam.indexOf(':') === 0) {\n        const paramName = pathParam.replace(':', '');\n        params[paramName] = urlParam;\n      }\n    });\n\n    return Object.assign({}, route, { params, isLoading: true });\n  }\n\n  _getRouteNameMatchingUrl(pathnameArray) {\n    return _.findKey(routes, route =\u003E {\n      const routePathnameArray = route.path.split('\u002F');\n\n      if (routePathnameArray.length !== pathnameArray.length) {\n        return false;\n      }\n\n      for (let i = 0; i &lt; routePathnameArray.length; i++) {\n        const pathParam = routePathnameArray[i];\n        const urlParam = pathnameArray[i];\n\n        if (pathParam.indexOf(':') !== 0) {\n          if (pathParam !== urlParam) {\n            return false;\n          }\n        } else {\n          const paramName = pathParam.replace(':', '');\n          const paramMask = _.get(route.masks, paramName);\n\n          if (paramMask &amp;&amp; !paramMask.test(urlParam)) {\n            return false;\n          }\n        }\n      }\n\n      return true;\n    });\n  }\n\n  replaceDynamicParams(route, params) {\n    return Object.entries(params).reduce((pathname, [paramName, value]) =\u003E {\n      return pathname.replace(`:${paramName}`, value);\n    }, route.path);\n  }\n\n  goTo(route, params) {\n    if (route.name === this.currentRoute.name) {\n      if (_.isEqual(this.currentRoute.params, params)) {\n        return false;\n      }\n\n      this.currentRoute.isLoading = true;\n      this.currentRoute.params = params;\n\n      const newPathname = this.replaceDynamicParams(this.currentRoute, params);\n\n      window.history.pushState(null, null, newPathname);\n\n      return false;\n    }\n\n    const newPathname = this.replaceDynamicParams(route, params);\n\n    window.history.pushState(null, null, newPathname);\n\n    this.currentRoute = this._fillRouteSchemaFromUrl();\n  }\n}\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003C\u002Fdiv\u003E\n                    \u003C\u002Fdiv\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EСхема работает достаточно просто — в конструкторе стора осуществляется поиск подходящего роута из \u003Ci\u003Eroutes.js\u003C\u002Fi\u003E и проверка всех динамических параметров по маске. Если роут не найдет или параметр не соответствует маске — происходит редирект на страницу с ошибкой 404. Разумеется, при развитии роутера нужно включить возможность «найти максимально похожий роут и перейти на него с дефолтными параметрами», и эту же стратегию использовать, если данные все же прошли маску, но некорректные — например, пользователь попробовал запросить данные по торговой паре 'test-test'.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EДалее в \u003Ci\u003EcurrentRoute\u003C\u002Fi\u003E записывается подходящий роут, обогащенный объектом \u003Ci\u003Eparams\u003C\u002Fi\u003E (значения переменных из URL) и \u003Ccode\u003EisLoading: true\u003C\u002Fcode\u003E. Теперь свою работу может начать React-компонент Router:\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cdiv class=\"spoiler\" role=\"button\" tabindex=\"0\"\u003E\n                        \u003Cb class=\"spoiler_title\"\u003Esrc\u002Fcomponents\u002FRouter.js\u003C\u002Fb\u003E\n                        \u003Cdiv class=\"spoiler_text\"\u003E\u003Cpre\u003E\u003Ccode class=\"javascript\"\u003Eimport React from 'react';\nimport _ from 'lodash';\n\nimport { useStore } from 'hooks';\nimport { observer } from 'utils';\nimport { routeComponents } from 'routeComponents';\n\nfunction getRouteComponent(route, isLoading) {\n  const Component = routeComponents[route.name];\n\n  if (!Component) {\n    console.error(\n      `getRouteComponent: component for ${\n        route.name\n      } is not defined in routeComponents`\n    );\n\n    return null;\n  }\n\n  return &lt;Component isLoading={isLoading} \u002F\u003E;\n}\n\nfunction useBeforeEnter() {\n  const store = useStore();\n  const { currentRoute } = store.router;\n\n  React.useEffect(() =\u003E {\n    if (currentRoute.isLoading) {\n      const beforeEnter = _.get(currentRoute, 'beforeEnter');\n\n      if (_.isFunction(beforeEnter)) {\n        Promise.resolve()\n          .then(() =\u003E beforeEnter(currentRoute, store))\n          .then(() =\u003E {\n            currentRoute.isLoading = false;\n          })\n          .catch(error =\u003E console.error(error));\n      } else {\n        currentRoute.isLoading = false;\n      }\n    }\n  });\n\n  return currentRoute.isLoading;\n}\n\nfunction Router() {\n  const {\n    router: { currentRoute },\n  } = useStore();\n  const isLoading = useBeforeEnter();\n\n  return getRouteComponent(currentRoute, isLoading);\n}\n\nexport const RouterConnected = observer(Router);\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003C\u002Fdiv\u003E\n                    \u003C\u002Fdiv\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EКогда рендерится этот компонент, хранилище уже давно инициализировалось и нашло подходящий роут, поэтому смысла проверять на \u003Ccode\u003EcurrentRoute == null\u003C\u002Fcode\u003E нет. Основная идея компонента — если у текущего роута параметр \u003Ccode\u003EisLoading === true\u003C\u002Fcode\u003E, то передавать этот параметр в компонент и менять его на false только после того, как полностью выполнится \u003Ccode\u003Eroute.beforeEnter\u003C\u002Fcode\u003E (если есть). Вместо описанной в принципах роутинга необходимости применять стратегии отказоустойчивости здесь постыдный \u003Ccode\u003Econsole.error\u003C\u002Fcode\u003E, как напоминание о том, что работы еще предстоит море.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EСледующий вопрос, который предстоит решить — где и когда запрашивать данные, необходимые для страницы. В React-сообществе распространены 2 подхода:\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Col\u003E\r\n\u003Cli\u003Eкомпоненты в цикле componentWillMount \u002F componentDidMount \u002F useEffect сами определяют, какие методы у сторов вызвать, чтобы получить данные. В этом случае они могут работать модульно — показывать внутри себя анимированные лоадеры, при ошибке одного из запросов показывать заглушку и кнопку «перезагрузить». Слабое место — когда нескольким компонентам нужны одинаковые данные — исправляется вынесением общих запросов на уровень общего родителя;\u003C\u002Fli\u003E\r\n\u003Cli\u003Eглобальный компонент страницы (либо роут) в едином месте делает все запросы за данными, которые нужны потомкам. Преимущество — возможность использовать общую стратегию отказоустойчивости — особенно полезно, когда абсолютно все данные и компоненты на странице должны работать. Слабое место — невозможность обновить данные конкретного компонента \u002F виджета — решается настройкой real-time обновления по запросам, на которые страница подписывается \u002F отписывается в едином месте.\u003C\u002Fli\u003E\r\n\u003C\u002Fol\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EМожно удобно реализовать любой из этих подходов, но для торгового интерфейса все же выберу второй — раньше у бирж встречал модульность (когда работает все, кроме графика, или работает только график без балансов и списка торговых пар и т.п.), но со временем они тоже отказались от этого подхода.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EПоэтому все запросы буду делать в методе \u003Ci\u003EbeforeEnter\u003C\u002Fi\u003E, по схеме: «оптимистичное обновление», последовательные запросы за данными (в будущем, конечно, необходимо использовать параллельные с возможностью прерывания), при различных ошибках — различные стратегии исправления (блокирование всей страницы с перезапросом всех данных несколько раз — если сервер отвечает 500 ошибками; откат до предыдущего состояния приложения если сервер отвечает некорректными данными; нотификация о том, что определенный блок с данными сейчас недоступен; редирект на роут с дефолтными параметрами и т.п.). В данном «скелете» приложения это все не реализовано, так как для самого продукта на этапе MVP пользы принесет мало.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EПоследним элементом роутинга будет компонент для создания ссылок:\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cdiv class=\"spoiler\" role=\"button\" tabindex=\"0\"\u003E\n                        \u003Cb class=\"spoiler_title\"\u003Esrc\u002Fcomponents\u002FLink.js\u003C\u002Fb\u003E\n                        \u003Cdiv class=\"spoiler_text\"\u003E\u003Cpre\u003E\u003Ccode class=\"javascript\"\u003Eimport React from 'react';\nimport _ from 'lodash';\n\nimport { useStore } from 'hooks';\nimport { observer } from 'utils';\n\nfunction checkRouteParamsWithMasks(route, params) {\n  if (route.masks) {\n    Object.entries(route.masks).forEach(([paramName, paramMask]) =\u003E {\n      const value = _.get(params, paramName);\n\n      if (paramMask &amp;&amp; !paramMask.test(value)) {\n        console.error(\n          `checkRouteParamsWithMasks: wrong param for ${paramName} in Link to ${\n            route.name\n          }: ${value}`\n        );\n      }\n    });\n  }\n}\n\nfunction Link(props) {\n  const store = useStore();\n  const { currentRoute } = store.router;\n  const { route, params, children, onClick, ...otherProps } = props;\n\n  checkRouteParamsWithMasks(route, params);\n\n  const filledPath = store.router.replaceDynamicParams(route, params);\n\n  return (\n    &lt;a\n      href={filledPath}\n      onClick={e =\u003E {\n        e.preventDefault();\n\n        if (currentRoute.isLoading) {\n          return false;\n        }\n\n        store.router.goTo(route, params);\n\n        if (onClick) {\n          onClick();\n        }\n      }}\n      {...otherProps}\n    \u003E\n      {children}\n    &lt;\u002Fa\u003E\n  );\n}\n\nexport const LinkConnected = observer(Link);\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003C\u002Fdiv\u003E\n                    \u003C\u002Fdiv\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EЭтот компонент принимает параметр \u003Ci\u003Eroute\u003C\u002Fi\u003E, валидирует переданные динамические \u003Ci\u003Eparams\u003C\u002Fi\u003E (если есть) на этапе создания ссылки (чтобы фронтенд сам себя не смог поломать при клике) и заполняет \u003Ci\u003Ehref\u003C\u002Fi\u003E заполненным адресом. Кроме этого, если у текущего роута все еще загружаются данные в методе \u003Ci\u003EbeforeEnter\u003C\u002Fi\u003E, переход по ссылке блокируется. Можно показывать нотификацию из разряда «подождите, идет загрузка», либо откладывать переход до завершения текущей загрузки, либо прерывать все запросы и форсированно переходить на новую страницу — в зависимости от потребности.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Ch3\u003EМетрики\u003C\u002Fh3\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EКасательно бизнес-метрик (переходы на страницы, клики по кнопкам, отправка заполненных форм, количество возникновения ошибок, поведение пользователя на странице) в общем случае достаточно Яндекс.Вебвизор или аналога с автоматическим сбором. Для приложения биржи не нужна система замера сложнодостижимых целей вроде заполнения многостраничных форм и выполнения комплекса действий.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EА вот отзывчивость приложения — время полной отрисовки страницы и длительность запросов за данными, включая валидацию — измерять необходимо, чтобы иметь возможность сделать эффективную точечную оптимизацию. Измерить длительность запросов можно было бы такой утилитой:\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cdiv class=\"spoiler\" role=\"button\" tabindex=\"0\"\u003E\n                        \u003Cb class=\"spoiler_title\"\u003Esrc\u002Fapi\u002Futils\u002Fmetrics.js\u003C\u002Fb\u003E\n                        \u003Cdiv class=\"spoiler_text\"\u003E\u003Cpre\u003E\u003Ccode class=\"javascript\"\u003Eimport _ from 'lodash';\n\nlet metricsArray = [];\nlet sendMetricsCallback = null;\n\nexport function startMetrics(route, apiRoutes) {\n  return function promiseCallback(data) {\n    clearTimeout(sendMetricsCallback);\n    const apiRouteName = _.findKey(apiRoutes, route);\n\n    metricsArray.push({\n      id: apiRouteName,\n      time: new Date().getTime(),\n    });\n\n    return data;\n  };\n}\n\nexport function stopMetrics(route, apiRoutes) {\n  return function promiseCallback(data) {\n    const apiRouteName = _.findKey(apiRoutes, route);\n    const metricsData = _.find(metricsArray, ['id', apiRouteName]);\n\n    metricsData.time = new Date().getTime() - metricsData.time;\n\n    clearTimeout(sendMetricsCallback);\n    sendMetricsCallback = setTimeout(() =\u003E {\n      console.log('Metrics sent:', metricsArray);\n      metricsArray = [];\n    }, 2000);\n\n    return data;\n  };\n}\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003C\u002Fdiv\u003E\n                    \u003C\u002Fdiv\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EИ включив эти две middleware в функцию \u003Ci\u003Erequest\u003C\u002Fi\u003E:\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"javascript\"\u003Eexport function request(route, params) {\n  return Promise.resolve()\n    .then(startMetrics(route, apiRoutes))\n    .then(validateRequestParams(route, params))\n    .then(makeRequestUrl(route, params))\n    .then(makeRequest)\n    .then(validateResponse(route, params))\n    .then(stopMetrics(route, apiRoutes))\n    .catch(error =\u003E {\n      stopMetrics(route, apiRoutes)();\n\n      throw error;\n    });\n}\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EТаким образом, длительность запросов аггрегируется, если перерыв между ними составил более 2 секунд, и отправится в некую систему мониторинга (в данном случае в консоль) единым массивом. Часто замеры производительности производится только на сервере — от поступления запроса до отдачи результата, но эта практика дает однобокую статистику — в реальности у клиента запрос может выполняться в разы дольше, и нужно собирать детализированную (в идеале) статистику по каждому этапу запроса, исходя из клиентского опыта.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EТеперь можно приступать к кодированию бизнес-логики и компонентов — в этом \u003Ca href=\"https:\u002F\u002Fdkazakov8.github.io\u002Fexchange_habr\u002Fdist\u002F\" rel=\"nofollow\"\u003Eдемо\u003C\u002Fa\u003E полностью реализовал первоначальное задание заказчика.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Ch3\u003EИнтеграционные тесты\u003C\u002Fh3\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EПро принципы и значение end-to-end тестирования информации много, в том числе в \u003Ca href=\"https:\u002F\u002Fdocs.cypress.io\u002Fguides\u002Foverview\u002Fwhy-cypress.html\" rel=\"nofollow\"\u003Eдокументации\u003C\u002Fa\u003E к выбранному инструменту Cypress. С точки зрения разработки в них важны: легкость развертывания; удобство поддержки и развития, в том числе для тестировщиков; легкость встраивания в Continious Integration.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EТак как данный инструмент состоит всего из одного пакета и написан на javascript с похожим на Chai \u002F Sinon синтаксисом, обычно проблем с развитием инструментария не возникает. Однако не радует долгая установка самого пакета, поэтому устанавливать желательно в отдельную папку, в моем случае — .\u002Ftests, в \u003Ci\u003Epackage.json\u003C\u002Fi\u003E которого будет единственная зависимость — \u003Ccode\u003E\"dependencies\": { \"cypress\": \"3.2.0\" }\u003C\u002Fcode\u003E\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EПосле установки инструмент сам создаст структуру папок с многочисленными примерами для обучения. Для максимального удобства нужно синхронизировать возможности встроенного в него Webpack и общей конфигурации проекта:\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cdiv class=\"spoiler\" role=\"button\" tabindex=\"0\"\u003E\n                        \u003Cb class=\"spoiler_title\"\u003Etests\u002Fcypress\u002Fplugins\u002Findex.js\u003C\u002Fb\u003E\n                        \u003Cdiv class=\"spoiler_text\"\u003E\u003Cpre\u003E\u003Ccode class=\"javascript\"\u003Econst webpack = require('..\u002F..\u002F..\u002Fnode_modules\u002F@cypress\u002Fwebpack-preprocessor');\nconst webpackConfig = require('..\u002F..\u002F..\u002Fwebpack-custom\u002Fwebpack.config');\n\nmodule.exports = on =\u003E {\n  const options = webpack.defaultOptions;\n\n  options.webpackOptions.module = webpackConfig.module;\n  options.webpackOptions.resolve = webpackConfig.resolve;\n\n  on('file:preprocessor', webpack(options));\n};\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003C\u002Fdiv\u003E\n                    \u003C\u002Fdiv\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EДля этого потребовалась установка всего лишь одного пакета в основной проект. Синхронизировать достаточно лишь \u003Ci\u003Emodule\u003C\u002Fi\u003E (для использования идентичного синтаксиса) и \u003Ci\u003Eresolve\u003C\u002Fi\u003E (чтобы работали все алиасы и импорты файлов как в основном проекте). В плагинах ESLint для корректного распознавания глобальных переменных (вроде \u003Ci\u003Edescribe\u003C\u002Fi\u003E, \u003Ci\u003Ecy\u003C\u002Fi\u003E) нужен дополнительный плагин \u003Ci\u003Eeslint-plugin-cypress\u003C\u002Fi\u003E. На этом настройка закончена, и вот так может выглядеть проверочный тест:\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cdiv class=\"spoiler\" role=\"button\" tabindex=\"0\"\u003E\n                        \u003Cb class=\"spoiler_title\"\u003Etests\u002Fcypress\u002Fintegration\u002Fmixed.js\u003C\u002Fb\u003E\n                        \u003Cdiv class=\"spoiler_text\"\u003E\u003Cpre\u003E\u003Ccode class=\"javascript\"\u003Edescribe('Market Listing good scenarios', () =\u003E {\n  it('Lots of mixed tests', () =\u003E {\n    cy.visit('\u002Fmarket\u002Fusd\u002Fbch-usd');\n    cy.location('pathname').should('equal', '\u002Fmarket\u002Fusd\u002Fbch-usd');\n\n    \u002F\u002F Проверка ответа на запрос, хотя для этого уже есть валидаторы\n    cy.wait('@symbolsList')\n      .its('response.body')\n      .should(data =\u003E {\n        expect(data).to.be.an('array');\n      });\n\n    \u002F\u002F Дожидаемся всех запросов\n    cy.wait('@rates');\n    cy.wait('@marketsList');\n    cy.wait('@symbolInfo');\n    cy.wait('@chartData');\n\n    \u002F\u002F Проверяем переход на другую торгуемую валюту\n    cy.get('#marketTab-eth').click();\n    cy.location('pathname').should('equal', '\u002Fmarket\u002Feth\u002Fbch-usd');\n    cy.wait('@rates');\n    cy.wait('@marketsList');\n\n    \u002F\u002F Проверяем изменение локализации\n    cy.contains('Рынки');\n    cy.get('#langSwitcher-en').click();\n    cy.contains('Markets list');\n\n    \u002F\u002F Проверяем изменение темы\n    cy.get('body').should('have.class', 'light');\n    cy.get('#themeSwitcher-dark').click();\n    cy.get('body').should('have.class', 'dark');\n  });\n});\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003C\u002Fdiv\u003E\n                    \u003C\u002Fdiv\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EТак как на текущий момент Cypress не поддерживает протокол fetch, можно применить полифилл, и заодно указать роуты для запросов:\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cdiv class=\"spoiler\" role=\"button\" tabindex=\"0\"\u003E\n                        \u003Cb class=\"spoiler_title\"\u003Etests\u002Fcypress\u002Fsupport\u002Findex.js\u003C\u002Fb\u003E\n                        \u003Cdiv class=\"spoiler_text\"\u003E\u003Cpre\u003E\u003Ccode class=\"javascript\"\u003Eimport { apiRoutes } from 'api';\n\nlet polyfill = null;\n\nbefore(() =\u003E {\n  const polyfillUrl = 'https:\u002F\u002Funpkg.com\u002Funfetch\u002Fdist\u002Funfetch.umd.js';\n  cy.request(polyfillUrl).then(response =\u003E {\n    polyfill = response.body;\n  });\n});\n\nCypress.on('window:before:load', window =\u003E {\n  delete window.fetch;\n  window.eval(polyfill);\n  window.fetch = window.unfetch;\n});\n\nbefore(() =\u003E {\n  cy.server();\n  cy.route(`${apiRoutes.symbolsList.url}**`).as('symbolsList');\n  cy.route(`${apiRoutes.rates.url}**`).as('rates');\n  cy.route(`${apiRoutes.marketsList.url}**`).as('marketsList');\n  cy.route(`${apiRoutes.symbolInfo.url({ id: 'bitcoin-cash' })}**`).as(\n    'symbolInfo'\n  );\n  cy.route(`${apiRoutes.chartData.url}**`).as('chartData');\n});\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003C\u002Fdiv\u003E\n                    \u003C\u002Fdiv\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EСобственно все, можно создавать удобные команды и обучать тестировщиков.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Ch3\u003EВсего лишь, так просто?\u003C\u002Fh3\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EДа, на этом шаге создана неблокирующая бизнес-разработку архитектура. Можно написать небольшую документацию по использованию и заложенным принципам, составить стандарты кодирования и приема качества, и привлечь коллег-разработчиков для кодирования компонентов \u002F бизнес-логики \u002F стилей.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EА в это время, честно отдавая себе отчет, что по описанным принципам работа сделана едва ли на половину, месяц-два добрабатывать, тщательно покрывая юнит-тестами утилиты перед тем, как переходить к следующим этапам архитектуры (real-time взаимодействие, подключение serviceWorker, интеграция в CI, кроссбраузерность и полифиллы, гибкое управление правами отображения и функционирования элементов, настройка бизнес-метрик, мобильная версия, автоматизация рутинных задач и т.п.).\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EРазмеры итоговых файлов (с Gzip) вполне адекватны:\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003E\u003Cimg src=\"\u002Fimg\u002Fimage-loader.svg\" data-src=\"https:\u002F\u002Fhabrastorage.org\u002Fwebt\u002Fp6\u002Fim\u002Ffk\u002Fp6imfkqh0-lf8zlr2apy_8zjqcm.png\"\u002F\u003E\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EИ структура компонентов в React Developer Tools выглядит очень приятно:\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003E\u003Cimg src=\"\u002Fimg\u002Fimage-loader.svg\" data-src=\"https:\u002F\u002Fhabrastorage.org\u002Fwebt\u002Fim\u002Fjn\u002F_l\u002Fimjn_lzweyq7yijk7ohnlafcpgo.png\"\u002F\u003E\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EВ целом работать в связке React Hooks + MobX понравилось намного больше, чем с Redux. Надеюсь, мой взгляд на архитектуру приложения поможет избежать лишних затрат времени. Если же выпустить продукт хотя бы без одного из описанных элементов, велика вероятность, что он понадобится в то время, когда внедрение займет месяцы и будет сопряжено со сложным рефакторингом. Лучше спроектировать это на этапе создания архитектуры. Всем интересной разработки!\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003E\u003Ca href=\"https:\u002F\u002Fgithub.com\u002Fdkazakov8\u002Fhabr_exchange\" rel=\"nofollow\"\u003EВесь код\u003C\u002Fa\u003E\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Ch3\u003EUpdate 13.07.2019\u003C\u002Fh3\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EБлагодарю сообщество за конструктивные комментарии и письма, после использования описанной выше архитектуры назрел довольно большой список доработок, которыми рад поделиться:\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003E1. Отсутствие \u003Ci\u003Eyarn.lock\u003C\u002Fi\u003E приводило к разным хешам после сборки, как и использование \u003Ccode\u003Eyarn install --force\u003C\u002Fcode\u003E, но проблема легко решилась скриптом \u003Ccode\u003E\"upd\": \"yarn install &amp;&amp; yarn add file:.\u002Feslint-custom &amp;&amp; yarn add file:.\u002Fwebpack-custom\"\u003C\u002Fcode\u003E. В данном случае обновляются зависимости только у не влияющих на итоговую сборку ESLint и Webpack.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003E2. Пути к папкам в webpack-custom\u002Fconfig\u002FconfigOptimization.js, описаны не кроссплатформенно, и вместо\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"javascript\"\u003Elodash: {\n  test: module =\u003E module.context.indexOf('node_modules\\\\lodash') !== -1,\n  name: 'lodash',\n  chunks: 'all',\n  enforce: true,\n}\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003Eдолжно быть\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"javascript\"\u003Elodash: {\n  test: \u002Fnode_modules[\\\\\u002F]lodash\u002F,\n  name: 'lodash',\n  chunks: 'all',\n  enforce: true,\n}\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003E3. При работе с локализацией передавать каждый раз параметры в \u003Ccode\u003EuseLocalization(__filename, messages)\u003C\u002Fcode\u003E утомительно, выход — переделать параметры в объекты вида\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"javascript\"\u003Econst messages = {\n  hello: {\n    value: 'У вас {count} {count: сообщение,сообщения,сообщений}',\n    name: \"src\u002Fcomponents\u002FTestLocalization\u002FTestLocalization.hello\",\n  }\n};\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003Eнапример, с помощью функции\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"javascript\"\u003Econst messagesDefault = {\n  hello: 'У вас {count} {count: сообщение,сообщения,сообщений}',\n};\n\nexport const messages = Object.keys(messagesDefault).reduce((acc, key) =\u003E {\n  acc[key] = {\n   value: messagesDefault[key],\n   name: __dirname.toLowerCase().replace(\u002F\\\\\\\\\u002Fg, '\u002F') + '.' + key,\n  };\n\n  return acc;\n}, {});\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EНо так как в IDE в таком случае перестает работать автодополнение, это преобразование можно выполнять в лоадере Webpack:\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cdiv class=\"spoiler\" role=\"button\" tabindex=\"0\"\u003E\n                        \u003Cb class=\"spoiler_title\"\u003Ewebpack-custom\u002Futils\u002FmessagesLoader.js\u003C\u002Fb\u003E\n                        \u003Cdiv class=\"spoiler_text\"\u003E\u003Cpre\u003E\u003Ccode class=\"javascript\"\u003Emodule.exports = function messagesLoader(source) {\n  if (source.indexOf('export const messages = messagesDefault;') !== -1) {\n    return source.replace(\n      'export const messages = messagesDefault;',\n      `\n  export const messages = Object.keys(messagesDefault).reduce((acc, key) =\u003E {\n    acc[key] = {\n      value: messagesDefault[key],\n      name: __dirname.toLowerCase().replace(\u002F\\\\\\\\\u002Fg, '\u002F') + '.' + key,\n    };\n    return acc;\n  }, {});\n    `\n    );\n  }\n\n  return source;\n};\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003C\u002Fdiv\u003E\n                    \u003C\u002Fdiv\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EСоответственно, файлы \u003Ci\u003Emessages.js\u003C\u002Fi\u003E теперь имеют содержание:\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"javascript\"\u003Econst messagesDefault = {\n  someText: 'Завершить',\n};\n\nexport const messages = messagesDefault;\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EТакже для повышения удобства работы с текстами очень пригодилась утилита, вызываемая в \u003Ci\u003Eapp.js\u003C\u002Fi\u003E, которая пробегается по всем файлам \u003Ci\u003Emessages.js\u003C\u002Fi\u003E и показывает, каких ключей не хватает в \u003Ci\u003E*.json\u003C\u002Fi\u003E файлах локализации:\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cdiv class=\"spoiler\" role=\"button\" tabindex=\"0\"\u003E\n                        \u003Cb class=\"spoiler_title\"\u003Esrc\u002Futils\u002FcheckLocalization.js\u003C\u002Fb\u003E\n                        \u003Cdiv class=\"spoiler_text\"\u003E\u003Cpre\u003E\u003Ccode class=\"javascript\"\u003Eimport _ from 'lodash';\n\nimport ru from 'localization\u002Fru.json';\n\nconst showNoTextMessage = true;\n\nexport function checkLocalization() {\n  const context = require.context('..\u002F', true, \u002Fmessages\\.js\u002F);\n  const messagesFiles = context.keys();\n  const notLocalizedObject = {};\n\n  messagesFiles.forEach(path =\u003E {\n    const fileExports = context(path);\n    const { messages } = fileExports;\n    _.values(messages).forEach(({ name, value }) =\u003E {\n      if (ru[name] == null) {\n        notLocalizedObject[name] = value;\n      }\n    });\n  });\n\n  if (showNoTextMessage &amp;&amp; _.size(notLocalizedObject) \u003E 0) {\n    console.log(\n      'No localization for lang ru:',\n      JSON.stringify(notLocalizedObject, null, 2)\n    );\n  }\n}\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003C\u002Fdiv\u003E\n                    \u003C\u002Fdiv\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EТаким образом, в консоли всплывет сообщение вида\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"plaintext\"\u003ENo localization for lang ru: {\n  \"src\u002Fcomponents\u002FTestLocalization\u002FTestLocalization.hello\": \"У вас {count} {count: сообщение,сообщения,сообщений}\"\n}\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003Eкоторое нужно просто скопировать в соответствующий \u003Ci\u003E*.json\u003C\u002Fi\u003E файл — разумеется, только если в проекте нет отдельной системы для работы с переводами, а тексты лежат в репозитории.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003E3. Валидаторы для АПИ в виде функций Lodash вроде \u003Ccode\u003EsomeResponseParam: _.isString\u003C\u002Fcode\u003E хотя и работают, но не расширяемы и не дают возможность вывести текст ошибки в удобном виде. Поэтому лучше обернуть их в кастомный объект:\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cdiv class=\"spoiler\" role=\"button\" tabindex=\"0\"\u003E\n                        \u003Cb class=\"spoiler_title\"\u003Esrc\u002Futils\u002FvalidateObjects.js\u003C\u002Fb\u003E\n                        \u003Cdiv class=\"spoiler_text\"\u003E\u003Cpre\u003E\u003Ccode class=\"javascript\"\u003Eimport _ from 'lodash';\n\nimport { createError } from '.\u002FcreateError';\nimport { errorsNames } from 'const';\n\nexport const validators = {\n  isArray(v) {\n    return _.isArray(v);\n  },\n  isString(v) {\n    return _.isString(v);\n  },\n  isNumber(v) {\n    return _.isNumber(v);\n  },\n  isBoolean(v) {\n    return _.isBoolean(v);\n  },\n  isPlainObject(v) {\n    return _.isPlainObject(v);\n  },\n\n  isArrayNotRequired(v) {\n    return _.isArray(v) || _.isNil(v);\n  },\n  isStringNotRequired(v) {\n    return _.isString(v) || _.isNil(v);\n  },\n  isNumberNotRequired(v) {\n    return _.isNumber(v) || _.isNil(v);\n  },\n  isBooleanNotRequired(v) {\n    return _.isBoolean(v) || _.isNil(v);\n  },\n  isPlainObjectNotRequired(v) {\n    return _.isPlainObject(v) || _.isNil(v);\n  },\n\n  omitParam() {\n    return true;\n  },\n};\n\nvalidators.isArray.notRequired = validators.isArrayNotRequired;\nvalidators.isString.notRequired = validators.isStringNotRequired;\nvalidators.isNumber.notRequired = validators.isNumberNotRequired;\nvalidators.isBoolean.notRequired = validators.isBooleanNotRequired;\nvalidators.isPlainObject.notRequired = validators.isPlainObjectNotRequired;\n\nexport function validateObjects(\n  { validatorsObject, targetObject, prefix },\n  otherArg\n) {\n  if (!_.isPlainObject(validatorsObject)) {\n    throw new Error(`validateObjects: validatorsObject is not an object`);\n  }\n\n  if (!_.isPlainObject(targetObject)) {\n    throw new Error(`validateObjects: targetObject is not an object`);\n  }\n\n  Object.entries(validatorsObject).forEach(([paramName, validator]) =\u003E {\n    const paramValue = targetObject[paramName];\n\n    if (!validator(paramValue, otherArg)) {\n      const validatorName = _.findKey(validators, v =\u003E v === validator);\n      throw createError(\n        errorsNames.VALIDATION,\n        `${prefix || ''}${paramName}${\n          _.isString(validatorName) ? ` [${validatorName}]` : ''\n        }`\n      );\n    }\n  });\n}\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003C\u002Fdiv\u003E\n                    \u003C\u002Fdiv\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EТакая небольшая обертка позволяет включать название валидатора в текст ошибки — например, \u003Ccode\u003Eс сервера пришел некорректный параметр someResponseParam [isString]\u003C\u002Fcode\u003E, сразу давая понять, какой тип был ожидаем. Также можно указать \u003Ccode\u003EsomeResponseParam: validators.isString.notRequired\u003C\u002Fcode\u003E, что сделает параметр необязательным. В реальном проекте в дополнение к этим валидаторам понадобились динамические, которые выбирают тип ответа в зависимости от отправленных параметров, а также проверки массивов вида \u003Ccode\u003EsomeResponseArray: arrayShape({ someParam: isString })\u003C\u002Fcode\u003E, которые без проблем интегрируются в подобную схему.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003E5. Роутинг, как и ожидалось, потребовалось значительно развить. Основное изменение — поддержка анимированных переходов между страницами (добавление к \u003Ccode\u003Ebody\u003C\u002Fcode\u003E классов \u003Ccode\u003EisEntering\u003C\u002Fcode\u003E, \u003Ccode\u003EisLeaving\u003C\u002Fcode\u003E с соответствующей задержкой) и запрет перехода на другие страницы в виде функции beforeLeave (аналог Prompt из \u003Ci\u003Ereact-router\u003C\u002Fi\u003E), в которой можно выводить предупреждения и блокировать переход при возврате false-значения в промисе, например\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"javascript\"\u003EsomePage: {\n  path: '\u002Fsome-page',\n  beforeLeave(store) {\n    return store.modals.raiseConfirm('Вы действительно хотите покинуть страницу?');\n  },\n}\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EВ целом получилось крайне удобно, когда роуты сами ходят за данными и могут многократно редиректить на другие без рендеринга каких-либо компонентов. Например, на одной из страниц использовалась следующая цепочка:\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003E — при заходе на \u003Ccode\u003E\u002Fsome\u002Flong\u002Fauth\u002Fpath\u003C\u002Fcode\u003E ее beforeEnter редиректит на алиас \u003Ccode\u003E\u002Fauth\u003C\u002Fcode\u003E\u003Cbr\u002F\u003E\r\n — beforeEnter роута \u003Ccode\u003E\u002Fauth\u003C\u002Fcode\u003E проверяет авторизацию, и если человек авторизован — то редиректит на \u003Ccode\u003E\u002Fprofile\u003C\u002Fcode\u003E\u003Cbr\u002F\u003E\r\n — beforeEnter роута \u003Ccode\u003E\u002Fprofile\u003C\u002Fcode\u003E делает запрос за данными, и если видит, что у пользователя не заполнено имя, редиректит на \u003Ccode\u003E\u002Fprofile\u002Fedit\u003C\u002Fcode\u003E\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EЭти редиректы проходят быстро и незаметно, при необходимости можно не сохранять их в истории браузера — то есть вместо \u003Ccode\u003Ewindow.history.pushState\u003C\u002Fcode\u003E использовать \u003Ccode\u003Elocation.replace\u003C\u002Fcode\u003E. При этом зоны ответственности четко разграничены, и любое комбинирование редиректов линейно приведет к единственно верному адресу страницы. В этом подход «ходить за данными в роутере» на голову выше подхода «ходить за данными в componentDidMount компонента», если иметь в виду критически важные для отображения запросы, а не загрузку словаря для селекта при его первичном рендере.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003E6. Классическая задача по отображению лоадера в кнопках при отправке запроса (например, при сабмите форм) элегантно решилась одним декоратором:\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cdiv class=\"spoiler\" role=\"button\" tabindex=\"0\"\u003E\n                        \u003Cb class=\"spoiler_title\"\u003Esrc\u002Futils\u002FwithState.js\u003C\u002Fb\u003E\n                        \u003Cdiv class=\"spoiler_text\"\u003E\u003Cpre\u003E\u003Ccode class=\"javascript\"\u003Eexport function withState(target, fnName, fnDescriptor) {\n  const original = fnDescriptor.value;\n\n  fnDescriptor.value = function fnWithState(...args) {\n    if (this.executions[fnName]) {\n      return Promise.resolve();\n    }\n\n    return Promise.resolve()\n      .then(() =\u003E {\n        this.executions[fnName] = true;\n      })\n      .then(() =\u003E original.apply(this, args))\n      .then(data =\u003E {\n        this.executions[fnName] = false;\n        return data;\n      })\n      .catch(error =\u003E {\n        this.executions[fnName] = false;\n        throw error;\n      });\n  };\n\n  return fnDescriptor;\n}\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003C\u002Fdiv\u003E\n                    \u003C\u002Fdiv\u003E\u003Cbr\u002F\u003E\r\n\u003Cdiv class=\"spoiler\" role=\"button\" tabindex=\"0\"\u003E\n                        \u003Cb class=\"spoiler_title\"\u003Esrc\u002Fstores\u002FCurrentTPStore.js\u003C\u002Fb\u003E\n                        \u003Cdiv class=\"spoiler_text\"\u003E\u003Cpre\u003E\u003Ccode class=\"javascript\"\u003Eimport _ from 'lodash';\n\nimport { makeObservable, withState } from 'utils';\nimport { apiRoutes, request } from 'api';\n\n@makeObservable\nexport class CurrentTPStore {\n  \u002F**\n   * @param rootStore {RootStore}\n   *\u002F\n  constructor(rootStore) {\n    this.rootStore = rootStore;\n    this.executions = {};\n  }\n\n  @withState\n  fetchSymbol() {\n    return request(apiRoutes.symbolInfo)\n      .then(this.fetchSymbolSuccess)\n      .catch(this.fetchSymbolError);\n  }\n  fetchSymbolSuccess(data) {\n    return Promise.resolve();\n  }\n  fetchSymbolError(error) {\n    console.error(error);\n  }\n}\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003C\u002Fdiv\u003E\n                    \u003C\u002Fdiv\u003E\u003Cbr\u002F\u003E\r\n\u003Cdiv class=\"spoiler\" role=\"button\" tabindex=\"0\"\u003E\n                        \u003Cb class=\"spoiler_title\"\u003Esrc\u002Fcomponents\u002FTestComponent.js\u003C\u002Fb\u003E\n                        \u003Cdiv class=\"spoiler_text\"\u003E\u003Cpre\u003E\u003Ccode class=\"javascript\"\u003Eimport React from 'react';\n\nimport { observer } from 'utils';\nimport { useStore } from 'hooks';\n\nfunction TestComponent() {\n  const store = useStore();\n  const { currentTP: { executions } } = store;\n\n  return &lt;div\u003E{executions.fetchSymbol ? 'Загружается...' : 'Загружен'}&lt;\u002Fdiv\u003E;\n}\n\nexport const TestComponentConnected = observer(TestComponent);\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003C\u002Fdiv\u003E\n                    \u003C\u002Fdiv\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EТакой подход освобождает от создания и обновления дополнительных параметров, по сути лишних.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EВторой репозиторий с обновленным кодом создавать не буду, так как изменений много, и итоговый код уже не будет соответствовать статье. Лучше потрачу это время на новую статью — интерес к приведенному стеку оказался высок, и есть множество сложных тем, в которых, возможно, мой опыт будет кому-то полезен.\u003C\u002Fp\u003E\u003C\u002Fdiv\u003E","tags":[{"titleHtml":"javascript"},{"titleHtml":"react"},{"titleHtml":"mobx"},{"titleHtml":"cypress"},{"titleHtml":"webpack 4"}],"metadata":{"stylesUrls":[],"scriptUrls":[],"shareImageUrl":"https:\u002F\u002Fhabr.com\u002Fshare\u002Fpublication\u002F450360\u002F0144674fee64238036a0c969749ef698\u002F","shareImageWidth":1200,"shareImageHeight":630,"vkShareImageUrl":"https:\u002F\u002Fhabr.com\u002Fshare\u002Fpublication\u002F450360\u002F0144674fee64238036a0c969749ef698\u002F?format=vk","schemaJsonLd":"{\"@context\":\"http:\\\u002F\\\u002Fschema.org\",\"@type\":\"Article\",\"mainEntityOfPage\":{\"@type\":\"WebPage\",\"@id\":\"https:\\\u002F\\\u002Fhabr.com\\\u002Fru\\\u002Fpost\\\u002F450360\\\u002F\"},\"headline\":\"Архитектура SPA-приложения биржи в 2019 году\",\"datePublished\":\"2019-05-02T22:27:53+03:00\",\"dateModified\":\"2020-06-19T13:21:49+03:00\",\"author\":{\"@type\":\"Person\",\"name\":\"Дмитрий Казаков\"},\"publisher\":{\"@type\":\"Organization\",\"name\":\"Habr\",\"logo\":{\"@type\":\"ImageObject\",\"url\":\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fwebt\\\u002Fa_\\\u002Flk\\\u002F9m\\\u002Fa_lk9mjkccjox-zccjrpfolmkmq.png\"}},\"description\":\"Приветствую, хабровчане! Читаю данный ресурс со времени основания, но время на написание статьи появилось только сейчас, а значит пора поделиться своим опытом с...\",\"url\":\"https:\\\u002F\\\u002Fhabr.com\\\u002Fru\\\u002Fpost\\\u002F450360\\\u002F#post-content-body\",\"about\":[\"h_webdev\",\"h_javascript\",\"h_reactjs\",\"f_develop\"],\"image\":[\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fwebt\\\u002Fpy\\\u002Fb5\\\u002Fjf\\\u002Fpyb5jfs2g07r-ypnnkoudkdxe7s.png\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fwebt\\\u002Fmk\\\u002F7y\\\u002F8s\\\u002Fmk7y8sh2cushkehhykrrufsvkre.png\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fwebt\\\u002Fp6\\\u002Fim\\\u002Ffk\\\u002Fp6imfkqh0-lf8zlr2apy_8zjqcm.png\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fwebt\\\u002Fim\\\u002Fjn\\\u002F_l\\\u002Fimjn_lzweyq7yijk7ohnlafcpgo.png\"]}","metaDescription":"Приветствую, хабровчане!\r\nЧитаю данный ресурс со времени основания, но время на написание статьи появилось только сейчас, а значит пора поделиться своим опытом с сообществом. Начинающим разработчикам,...","mainImageUrl":null,"amp":false},"polls":[],"commentsEnabled":true,"rulesRemindEnabled":false,"votesEnabled":true,"status":"published","plannedPublishTime":null,"checked":null,"isEditorial":false}},"articlesIds":{},"isLoading":false,"pagesCount":{},"route":{},"reasonsList":null,"view":"cards","lastVisitedRoute":{},"ssrCommentsArticleIds":[""],"karma":{}},"authorContribution":{"authors":{}},"betaTest":{"currentAnnouncement":null,"announcements":{},"announcementCards":null,"announcementComments":{},"announcementCommentThreads":{},"announcementCommentingStatuses":{},"archivedList":[]},"authorStatistics":{"articleRefs":{},"articleIds":{},"pagesCount":{},"route":{},"viewsCount":[],"maxStatsCount":{}},"career":{"seoLandings":[],"hubs":"webdev,javascript,reactjs"},"comments":{"articleComments":{},"searchCommentsResults":null,"previewComment":null,"pagesCount":null,"commentAccess":{},"scrollParents":{},"pageArticleComments":{"lastViewedComment":0,"postId":null,"lastCommentTimestamp":"","moderated":[],"moderatedIds":[],"commentRoute":""}},"companies":{"companyRefs":{},"companyIds":{},"companyTopIds":{},"pagesCount":{},"companyProfiles":{},"companiesCategories":[],"companiesCategoriesTotalCount":0,"companiesWidgets":{},"companiesWorkers":{},"companiesFans":{},"route":{},"isLoading":false,"companyWorkersLoading":false,"companyFansLoading":false,"vacancies":{}},"companiesContribution":{"hubs":{},"flows":{},"companyRefs":{}},"companyHubsContribution":{"contributionRefs":{"hubRefs":{},"hubIds":{}}},"conversation":{"messages":[],"respondent":null,"isLoadMore":false},"conversations":{"conversations":[],"unreadCount":0,"pagesCount":0,"isLoadMore":false},"desktopState":{"desktopFl":null,"desktopHl":null,"isChecked":false,"isLoginDemanded":false},"dfp":{"slotsDict":{}},"docs":{"menu":{},"articles":{},"mainMenu":[],"loading":{"main":false,"dropdown":false,"article":false}},"feature":{"isProbablyVisible":"true"},"flows":{"flows":[{"alias":"develop","id":1,"route":{"name":"FLOW_PAGE","params":{"flowName":"develop"}}},{"alias":"admin","id":6,"route":{"name":"FLOW_PAGE","params":{"flowName":"admin"}}},{"alias":"design","id":2,"route":{"name":"FLOW_PAGE","params":{"flowName":"design"}}},{"alias":"management","id":3,"route":{"name":"FLOW_PAGE","params":{"flowName":"management"}}},{"alias":"marketing","id":4,"route":{"name":"FLOW_PAGE","params":{"flowName":"marketing"}}},{"alias":"popsci","id":7,"route":{"name":"FLOW_PAGE","params":{"flowName":"popsci"}}}]},"global":{"isPwa":false,"device":"desktop","isHabrCom":true},"hubs":{"hubRefs":{},"hubIds":{},"pagesCount":{},"isLoading":false,"route":{}},"hubsBlock":{"hubRefs":{},"hubIds":{}},"i18n":{"fl":"ru","hl":"ru"},"info":{"infoPage":{},"isLoading":true},"location":{"urlStruct":{"protocol":null,"slashes":null,"auth":null,"host":null,"port":null,"hostname":null,"hash":null,"search":null,"query":{},"pathname":null,"path":null,"href":""},"searchQuery":null},"me":{"user":null,"ppgDemanded":false,"karmaResetInfo":{"canReincarnate":null,"wasReincarnated":null,"currentScore":null},"notes":null},"mostReadingList":{"mostReadingListIds":[],"mostReadingListRefs":null,"promoPost":null},"pinnedPost":{"pinnedPost":null},"ppa":{"articles":{},"card":null,"transactions":null,"totalTransactions":null,"isAccessible":null},"projectsBlocks":{"activeBlocks":{}},"pullRefresh":{"shouldRefresh":false},"sandbox":{"articleIds":[],"articleRefs":{},"pagesCount":null,"route":{},"lastVisitedRoute":{},"isLoading":false},"settingsOther":{"inputs":{"uiLang":{"errors":[],"ref":null,"value":""},"articlesLangEnglish":{"errors":[],"ref":null,"value":false},"articlesLangRussian":{"errors":[],"ref":null,"value":false},"agreement":{"errors":[],"ref":null,"value":false},"email":{"errors":[],"ref":null,"value":true},"digest":{"errors":[],"ref":null,"value":true}}},"similarList":{"similarListIds":[],"similarListRefs":null},"ssr":{"error":null,"isDataLoaded":false,"isDataLoading":false,"isHydrationFailed":false,"isServer":false},"userHubsContribution":{"contributionRefs":{"hubRefs":{},"hubIds":{}}},"userInvites":{"availableInvites":0,"usedInvitesIds":[],"usedInvitesRefs":{},"usedInvitesPagesCount":0,"unusedInvitesIds":[],"unusedInvitesRefs":{},"unusedInvitesPagesCount":0},"users":{"authorRefs":{},"authorIds":{},"pagesCount":{},"authorProfiles":{},"userHubs":{},"userInvitations":{},"authorFollowers":{},"authorFollowed":{},"karmaStats":[],"statistics":null,"isLoading":false,"authorFollowersLoading":false,"authorFollowedLoading":false,"userHubsLoading":false,"userInvitationsLoading":false,"route":{}},"viewport":{"prevScrollY":{},"scrollY":0,"width":0},"tracker":{"items":{},"pagesCache":{},"markedViewedSilently":{},"markedRead":{},"unreadCounters":{"applications":null,"system":null,"mentions":null,"subscribers":null,"posts_and_comments":null},"unviewedCounters":{"applications":null,"system":null,"mentions":null,"subscribers":null,"posts_and_comments":null}}};(function(){var s;(s=document.currentScript||document.scripts[document.scripts.length-1]).parentNode.removeChild(s);}());</script>
<script src="https://assets.habr.com/habr-web/js/chunk-vendors.c2c3fc9a.js" defer></script><script src="https://assets.habr.com/habr-web/js/app.c0af73e7.js" defer></script>



    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
        (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
        m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
    </script>
  
  <script type="text/javascript" >
    (function(m,e,t,r,i,k,a){m[i]=m[i]||function(){(m[i].a=m[i].a||[]).push(arguments)};
    m[i].l=1*new Date();k=e.createElement(t),a=e.getElementsByTagName(t)[0],k.async=1,k.src=r,a.parentNode.insertBefore(k,a)})
    (window, document, "script", "https://mc.yandex.ru/metrika/tag.js", "ym");

    ym(24049213, "init", {
      defer:true,
      trackLinks:true,
      accurateTrackBounce:true,
      webvisor:false,
    });
  </script>
  <noscript>
    <div>
      <img src="https://mc.yandex.ru/watch/24049213" style="position:absolute; left:-9999px;" alt="" />
    </div>
  </noscript>
  
    <script type="text/javascript">
      window.addEventListener('load', function () {
        setTimeout(() => {
          const img = new Image();
          img.src = 'https://vk.com/rtrg?p=VK-RTRG-421343-57vKE';
        }, 0);
      });
    </script>
  
</body>
</html>
